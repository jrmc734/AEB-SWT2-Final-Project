{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;\red0\green128\blue0;\red96\green64\blue32;\rede0\green128\blue0;\red128\green0\blue0;\red128\green96\blue32;\red0\green32\blue128;\red0\green128\blue128;\red255\green0\blue255;\red0\green0\blue0;\red112\green0\blue112;\red255\green0\blue0;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext50 Code Example 9;}
{\s50\li3600\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext51 Code Example 10;}
{\s51\li3960\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext52 Code Example 11;}
{\s52\li4320\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 12;}
{\s53\li4680\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 13;}
{\s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext61 List Continue 0;}
{\s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext62 List Continue 1;}
{\s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext63 List Continue 2;}
{\s63\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext64 List Continue 3;}
{\s64\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext65 List Continue 4;}
{\s65\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext66 List Continue 5;}
{\s66\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext67 List Continue 6;}
{\s67\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext68 List Continue 7;}
{\s68\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext69 List Continue 8;}
{\s69\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext70 List Continue 9;}
{\s70\li3600\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext71 List Continue 10;}
{\s71\li3960\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext72 List Continue 11;}
{\s72\li4320\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 12;}
{\s73\li4680\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 13;}
{\s80\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext81 DescContinue 0;}
{\s81\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext82 DescContinue 1;}
{\s82\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext83 DescContinue 2;}
{\s83\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext84 DescContinue 3;}
{\s84\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext85 DescContinue 4;}
{\s85\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext86 DescContinue 5;}
{\s86\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext87 DescContinue 6;}
{\s87\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext88 DescContinue 7;}
{\s88\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext89 DescContinue 8;}
{\s89\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext90 DescContinue 9;}
{\s90\li3600\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext91 DescContinue 10;}
{\s91\li3960\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext92 DescContinue 11;}
{\s92\li4320\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 12;}
{\s93\li4680\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 13;}
{\s100\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext101 LatexTOC 0;}
{\s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext102 LatexTOC 1;}
{\s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext103 LatexTOC 2;}
{\s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext104 LatexTOC 3;}
{\s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext105 LatexTOC 4;}
{\s105\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext106 LatexTOC 5;}
{\s106\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext107 LatexTOC 6;}
{\s107\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext108 LatexTOC 7;}
{\s108\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext109 LatexTOC 8;}
{\s109\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext110 LatexTOC 9;}
{\s110\li3600\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext111 LatexTOC 10;}
{\s111\li3960\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext112 LatexTOC 11;}
{\s112\li4320\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 12;}
{\s113\li4680\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 13;}
{\s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext121 \sautoupd List Bullet 0;}
{\s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext122 \sautoupd List Bullet 1;}
{\s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext123 \sautoupd List Bullet 2;}
{\s123\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext124 \sautoupd List Bullet 3;}
{\s124\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext125 \sautoupd List Bullet 4;}
{\s125\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext126 \sautoupd List Bullet 5;}
{\s126\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext127 \sautoupd List Bullet 6;}
{\s127\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext128 \sautoupd List Bullet 7;}
{\s128\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext129 \sautoupd List Bullet 8;}
{\s129\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext130 \sautoupd List Bullet 9;}
{\s130\fi-360\li3960\widctlpar\jclisttab\tx3960{\*\pn \pnlvlbody\ilvl0\ls11\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext131 \sautoupd List Bullet 10;}
{\s131\fi-360\li4320\widctlpar\jclisttab\tx4320{\*\pn \pnlvlbody\ilvl0\ls12\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext132 \sautoupd List Bullet 11;}
{\s132\fi-360\li4680\widctlpar\jclisttab\tx4680{\*\pn \pnlvlbody\ilvl0\ls13\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 12;}
{\s133\fi-360\li5040\widctlpar\jclisttab\tx5040{\*\pn \pnlvlbody\ilvl0\ls14\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 13;}
{\s140\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext141 \sautoupd List Enum 0;}
{\s141\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext142 \sautoupd List Enum 1;}
{\s142\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext143 \sautoupd List Enum 2;}
{\s143\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext144 \sautoupd List Enum 3;}
{\s144\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext145 \sautoupd List Enum 4;}
{\s145\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext146 \sautoupd List Enum 5;}
{\s146\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext147 \sautoupd List Enum 6;}
{\s147\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext148 \sautoupd List Enum 7;}
{\s148\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext149 \sautoupd List Enum 8;}
{\s149\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext150 \sautoupd List Enum 9;}
{\s150\fi-360\li3960\widctlpar\fs20\cgrid \sbasedon0 \snext151 \sautoupd List Enum 10;}
{\s151\fi-360\li4320\widctlpar\fs20\cgrid \sbasedon0 \snext152 \sautoupd List Enum 11;}
{\s152\fi-360\li4680\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 12;}
{\s153\fi-360\li5040\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 13;}
}
{\info 
{\title {\comment AEB Controller  {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
1.0.0 \par
}}AEB Controller}
{\comment Generated by doxygen1.9.1.}
{\creatim \yr2025\mo3\dy26\hr23\min9\sec21}
}\pard\plain 
\sectd\pgnlcrm
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\vertalc\qc\par\par\par\par\par\par\par
\pard\plain \s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid 
{\field\fldedit {\*\fldinst TITLE \\*MERGEFORMAT}{\fldrslt AEB Controller}}\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\par
\par\par\par\par\par\par\par\par\par\par\par\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
{\field\fldedit {\*\fldinst AUTHOR \\*MERGEFORMAT}{\fldrslt AUTHOR}}\par
Version 1.0.0\par{\field\fldedit {\*\fldinst CREATEDATE \\*MERGEFORMAT}{\fldrslt Wed Mar 26 2025 }}\par
\page\page\vertalt
\pard\plain 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Table of Contents\par
\pard\plain \par
{\field\fldedit {\*\fldinst TOC \\f \\*MERGEFORMAT}{\fldrslt Table of contents}}\par
\pard\plain 
\sect \sbkpage \pgndec \pgnrestart
\sect \sectd \sbknone
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Project Description\par \pard\plain 
{\tc \v Project Description}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\bkmkstart AAAAAAABOL}
{\bkmkend AAAAAAABOL}
 {\b AEB}  is an advanced active safety system that assists drivers in avoiding or mitigating collisions with other vehicles or obstacles. It detects potential frontal collisions and automatically engages the vehicle's braking system to reduce speed or come to a complete stop, aiming to prevent or minimize impact.\par
To implement this system, {\b POSIX}  (Portable Operating System Interface) concepts are employed. POSIX defines programming interfaces and operating system interfaces to maintain compatibility between different operating systems, facilitating portability and interoperability of applications.\par
{\bkmkstart AAAAAAABOM}
{\bkmkend AAAAAAABOM}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Project Objective
\par}
{\tc\tcl2 \v Project Objective}
This project is part of the final course in Automotive Propulsion Engineering, aka {\b Resid\'EAncia Tecnol\'F3gica Stellantis 2024, SWT2} . It is dedicated to the development of an Automotive Emergency Braking (AEB) system, aligning with Stellantis\'92 interests. The project takes a multidisciplinary approach, demonstrating the student's understanding of various topics covered during the course. Key topics include Vehicle Modeling and Simulation, Agile Methodologies, Vehicular Networks, Vehicle Function Allocation, Automotive Embedded Software Modeling and Testing, and the Implementation of Automotive Control Systems.\par}
{\bkmkstart AAAAAAABON}
{\bkmkend AAAAAAABON}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Main Features
\par}
{\tc\tcl2 \v Main Features}
{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Collision Detection} : Continuous monitoring of the vehicle's frontal environment to identify potential imminent collisions.\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Automatic Braking Activation} : In the event of a collision risk detection, the system automatically engages the brakes to reduce speed or stop the vehicle.\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Driver Notifications} : Visual and audible alerts to inform the driver about potential hazards and actions taken by the system.\par}
\par
\par}
{\bkmkstart AAAAAAABOO}
{\bkmkend AAAAAAABOO}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Technologies Used
\par}
{\tc\tcl2 \v Technologies Used}
{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Programming Language} : C, leveraging POSIX-compatible libraries and system calls to ensure portability and efficiency.\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b POSIX-Compatible Operating Systems} : Development is focused on systems adhering to POSIX standards, ensuring greater code compatibility and portability.\par}
\par
\par}
{\bkmkstart AAAAAAABOP}
{\bkmkend AAAAAAABOP}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Project Structure
\par}
{\tc\tcl2 \v Project Structure}
The project's directory structure is organized as follows:\par
{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
**{\f2 src/} **: Contains the main source code of the AEB system.\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
**{\f2 test/} **: Holds unit tests for validating the system's modules.\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
**{\f2 docs/} **: Dedicated to project documentation, including specifications and manuals.\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
**{\f2 .github/} **: Utilized for GitHub workflows and automated actions.\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
**{\f2 bin/} **: Stores binary files generated during the build process.\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
**{\f2 cts/} **: Specific generated databases.\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
**{\f2 inc/} **: Contains header files used in the source code.\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
**{\f2 obj/} **: Holds object files created during compilation.\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
**{\f2 Makefile} **: Script to automate the build process and execute tests.\par}
\par
This organization enhances code navigation and maintenance, ensuring a clear separation of responsibilities among different project components.\par}
{\bkmkstart AAAAAAABOQ}
{\bkmkend AAAAAAABOQ}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Setup and Execution
\par}
{\tc\tcl2 \v Setup and Execution}
To build and run the project, follow the steps below:\par
{
\par
\pard\plain \s140\fi-360\li360\widctlpar\fs20\cgrid 
1.\tab {\b Prerequisites} :{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
A POSIX-compliant operating system.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
A C compiler (e.g., GCC) installed on your system.\par}
\pard\plain \s140\fi-360\li360\widctlpar\fs20\cgrid 
2.\tab {\b Building the Project} :{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Navigate to the project's root directory.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Run {\f2 make}  to compile the source code.\par}
\pard\plain \s140\fi-360\li360\widctlpar\fs20\cgrid 
3.\tab {\b Running the System} :{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
After a successful build, execute the system with {\f2 ./aeb_system} .\par}
\pard\plain \s140\fi-360\li360\widctlpar\fs20\cgrid 
4.\tab {\b Running Tests} :{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
To execute unit tests, use {\f2 make test} .\par}
}
\par
\par}
{\bkmkstart AAAAAAABOR}
{\bkmkend AAAAAAABOR}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Contribution
\par}
{\tc\tcl2 \v Contribution}
Contributions are welcome! To contribute:\par
{
\par
\pard\plain \s140\fi-360\li360\widctlpar\fs20\cgrid 
1.\tab Fork this repository.\par
\pard\plain \s140\fi-360\li360\widctlpar\fs20\cgrid 
2.\tab Create a new branch for your feature or fix: {\f2 git checkout -b my-feature} .\par
\pard\plain \s140\fi-360\li360\widctlpar\fs20\cgrid 
3.\tab Make the desired changes and commit: \'91git commit -m 'My new feature\'92{\f2 .} \par
\pard\plain \s140\fi-360\li360\widctlpar\fs20\cgrid 
4.\tab {\f2 Push to the remote repository:} git push origin my-feature`.\par
\pard\plain \s140\fi-360\li360\widctlpar\fs20\cgrid 
5.\tab Open a Pull Request for review.\par}
\par
\par}
{\bkmkstart AAAAAAABOS}
{\bkmkend AAAAAAABOS}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
License
\par}
{\tc\tcl2 \v License}
This project is licensed under the MIT License. For more details, refer to the {\f2 LICENSE}  file in the repository.\par
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
 \par}
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Index\par \pard\plain 
{\tc \v Class Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Class List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here are the classes, structs, unions and interfaces with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b actuators_abstraction} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABNF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b can_msg} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABNL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b sensors_input_data} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABNO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b UNITY_STORAGE_T} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABNW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Index\par \pard\plain 
{\tc \v File Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
File List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all files with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b inc/{\b actuators.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b inc/{\b constants.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b inc/{\b dbc.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b inc/{\b file_reader.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b inc/{\b log_utils.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b inc/{\b mq_utils.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b inc/{\b sensors_input.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b inc/{\b ttc_control.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b actuators.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b aeb_controller.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b dbc.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b file_reader.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b log_utils.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b main.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b mq_utils.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b sensors.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b ttc_control.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b test/{\b test_mq_utils.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b test/{\b test_mq_utils_read.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b test/{\b test_ttc.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b test/{\b unity.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b test/{\b unity.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b test/{\b unity_internals.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABAF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Documentation{\tc \v Class Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
actuators_abstraction Struct Reference\par \pard\plain 
{\tc\tcl2 \v actuators_abstraction}
{\xe \v actuators_abstraction}
{\bkmkstart AAAAAAABNF}
{\bkmkend AAAAAAABNF}
\par
{
{\f2 #include <actuators.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b belt_tightness}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b door_lock}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b should_activate_abs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b alarm_led}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b alarm_buzzer}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 6 of file actuators.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v alarm_buzzer\:actuators_abstraction}
{\xe \v actuators_abstraction\:alarm_buzzer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool actuators_abstraction::alarm_buzzer}}
\par
{\bkmkstart AAAAAAABNG}
{\bkmkend AAAAAAABNG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 11 of file actuators.h.}\par
}
{\xe \v alarm_led\:actuators_abstraction}
{\xe \v actuators_abstraction\:alarm_led}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool actuators_abstraction::alarm_led}}
\par
{\bkmkstart AAAAAAABNH}
{\bkmkend AAAAAAABNH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 10 of file actuators.h.}\par
}
{\xe \v belt_tightness\:actuators_abstraction}
{\xe \v actuators_abstraction\:belt_tightness}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool actuators_abstraction::belt_tightness}}
\par
{\bkmkstart AAAAAAABNI}
{\bkmkend AAAAAAABNI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 7 of file actuators.h.}\par
}
{\xe \v door_lock\:actuators_abstraction}
{\xe \v actuators_abstraction\:door_lock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool actuators_abstraction::door_lock}}
\par
{\bkmkstart AAAAAAABNJ}
{\bkmkend AAAAAAABNJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 8 of file actuators.h.}\par
}
{\xe \v should_activate_abs\:actuators_abstraction}
{\xe \v actuators_abstraction\:should_activate_abs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool actuators_abstraction::should_activate_abs}}
\par
{\bkmkstart AAAAAAABNK}
{\bkmkend AAAAAAABNK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9 of file actuators.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
inc/{\b actuators.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
can_msg Struct Reference\par \pard\plain 
{\tc\tcl2 \v can_msg}
{\xe \v can_msg}
{\bkmkstart AAAAAAABNL}
{\bkmkend AAAAAAABNL}
\par
{
{\f2 #include <dbc.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b identifier}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b dataFrame} [8]\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 23 of file dbc.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v dataFrame\:can_msg}
{\xe \v can_msg\:dataFrame}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char can_msg::dataFrame[8]}}
\par
{\bkmkstart AAAAAAABNM}
{\bkmkend AAAAAAABNM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 26 of file dbc.h.}\par
}
{\xe \v identifier\:can_msg}
{\xe \v can_msg\:identifier}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t can_msg::identifier}}
\par
{\bkmkstart AAAAAAABNN}
{\bkmkend AAAAAAABNN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 25 of file dbc.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
inc/{\b dbc.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
sensors_input_data Struct Reference\par \pard\plain 
{\tc\tcl2 \v sensors_input_data}
{\xe \v sensors_input_data}
{\bkmkstart AAAAAAABNO}
{\bkmkend AAAAAAABNO}
\par
{
{\f2 #include <sensors_input.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b vehicle_velocity}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b has_obstacle}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b obstacle_distance}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b brake_pedal}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b accelerator_pedal}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b on_off_aeb_system}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b reverseEnabled}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 6 of file sensors_input.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v accelerator_pedal\:sensors_input_data}
{\xe \v sensors_input_data\:accelerator_pedal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int sensors_input_data::accelerator_pedal}}
\par
{\bkmkstart AAAAAAABNP}
{\bkmkend AAAAAAABNP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 11 of file sensors_input.h.}\par
}
{\xe \v brake_pedal\:sensors_input_data}
{\xe \v sensors_input_data\:brake_pedal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int sensors_input_data::brake_pedal}}
\par
{\bkmkstart AAAAAAABNQ}
{\bkmkend AAAAAAABNQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 10 of file sensors_input.h.}\par
}
{\xe \v has_obstacle\:sensors_input_data}
{\xe \v sensors_input_data\:has_obstacle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int sensors_input_data::has_obstacle}}
\par
{\bkmkstart AAAAAAABNR}
{\bkmkend AAAAAAABNR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 8 of file sensors_input.h.}\par
}
{\xe \v obstacle_distance\:sensors_input_data}
{\xe \v sensors_input_data\:obstacle_distance}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double sensors_input_data::obstacle_distance}}
\par
{\bkmkstart AAAAAAABNS}
{\bkmkend AAAAAAABNS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9 of file sensors_input.h.}\par
}
{\xe \v on_off_aeb_system\:sensors_input_data}
{\xe \v sensors_input_data\:on_off_aeb_system}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int sensors_input_data::on_off_aeb_system}}
\par
{\bkmkstart AAAAAAABNT}
{\bkmkend AAAAAAABNT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 12 of file sensors_input.h.}\par
}
{\xe \v reverseEnabled\:sensors_input_data}
{\xe \v sensors_input_data\:reverseEnabled}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int sensors_input_data::reverseEnabled}}
\par
{\bkmkstart AAAAAAABNU}
{\bkmkend AAAAAAABNU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 13 of file sensors_input.h.}\par
}
{\xe \v vehicle_velocity\:sensors_input_data}
{\xe \v sensors_input_data\:vehicle_velocity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double sensors_input_data::vehicle_velocity}}
\par
{\bkmkstart AAAAAAABNV}
{\bkmkend AAAAAAABNV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 7 of file sensors_input.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
inc/{\b sensors_input.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
UNITY_STORAGE_T Struct Reference\par \pard\plain 
{\tc\tcl2 \v UNITY_STORAGE_T}
{\xe \v UNITY_STORAGE_T}
{\bkmkstart AAAAAAABNW}
{\bkmkend AAAAAAABNW}
\par
{
{\f2 #include <unity_internals.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b TestFile}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b CurrentTestName}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b CurrentDetail1}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b CurrentDetail2}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UNITY_LINE_TYPE} {\b CurrentTestLineNumber}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UNITY_COUNTER_TYPE} {\b NumberOfTests}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UNITY_COUNTER_TYPE} {\b TestFailures}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UNITY_COUNTER_TYPE} {\b TestIgnores}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UNITY_COUNTER_TYPE} {\b CurrentTestFailed}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UNITY_COUNTER_TYPE} {\b CurrentTestIgnored}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
jmp_buf {\b AbortFrame}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 515 of file unity_internals.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v AbortFrame\:UNITY_STORAGE_T}
{\xe \v UNITY_STORAGE_T\:AbortFrame}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
jmp_buf UNITY_STORAGE_T::AbortFrame}}
\par
{\bkmkstart AAAAAAABNX}
{\bkmkend AAAAAAABNX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 534 of file unity_internals.h.}\par
}
{\xe \v CurrentDetail1\:UNITY_STORAGE_T}
{\xe \v UNITY_STORAGE_T\:CurrentDetail1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* UNITY_STORAGE_T::CurrentDetail1}}
\par
{\bkmkstart AAAAAAABNY}
{\bkmkend AAAAAAABNY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 520 of file unity_internals.h.}\par
}
{\xe \v CurrentDetail2\:UNITY_STORAGE_T}
{\xe \v UNITY_STORAGE_T\:CurrentDetail2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* UNITY_STORAGE_T::CurrentDetail2}}
\par
{\bkmkstart AAAAAAABNZ}
{\bkmkend AAAAAAABNZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 521 of file unity_internals.h.}\par
}
{\xe \v CurrentTestFailed\:UNITY_STORAGE_T}
{\xe \v UNITY_STORAGE_T\:CurrentTestFailed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UNITY_COUNTER_TYPE} UNITY_STORAGE_T::CurrentTestFailed}}
\par
{\bkmkstart AAAAAAABOA}
{\bkmkend AAAAAAABOA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 527 of file unity_internals.h.}\par
}
{\xe \v CurrentTestIgnored\:UNITY_STORAGE_T}
{\xe \v UNITY_STORAGE_T\:CurrentTestIgnored}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UNITY_COUNTER_TYPE} UNITY_STORAGE_T::CurrentTestIgnored}}
\par
{\bkmkstart AAAAAAABOB}
{\bkmkend AAAAAAABOB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 528 of file unity_internals.h.}\par
}
{\xe \v CurrentTestLineNumber\:UNITY_STORAGE_T}
{\xe \v UNITY_STORAGE_T\:CurrentTestLineNumber}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UNITY_LINE_TYPE} UNITY_STORAGE_T::CurrentTestLineNumber}}
\par
{\bkmkstart AAAAAAABOC}
{\bkmkend AAAAAAABOC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 523 of file unity_internals.h.}\par
}
{\xe \v CurrentTestName\:UNITY_STORAGE_T}
{\xe \v UNITY_STORAGE_T\:CurrentTestName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* UNITY_STORAGE_T::CurrentTestName}}
\par
{\bkmkstart AAAAAAABOD}
{\bkmkend AAAAAAABOD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 518 of file unity_internals.h.}\par
}
{\xe \v NumberOfTests\:UNITY_STORAGE_T}
{\xe \v UNITY_STORAGE_T\:NumberOfTests}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UNITY_COUNTER_TYPE} UNITY_STORAGE_T::NumberOfTests}}
\par
{\bkmkstart AAAAAAABOE}
{\bkmkend AAAAAAABOE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 524 of file unity_internals.h.}\par
}
{\xe \v TestFailures\:UNITY_STORAGE_T}
{\xe \v UNITY_STORAGE_T\:TestFailures}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UNITY_COUNTER_TYPE} UNITY_STORAGE_T::TestFailures}}
\par
{\bkmkstart AAAAAAABOF}
{\bkmkend AAAAAAABOF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 525 of file unity_internals.h.}\par
}
{\xe \v TestFile\:UNITY_STORAGE_T}
{\xe \v UNITY_STORAGE_T\:TestFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* UNITY_STORAGE_T::TestFile}}
\par
{\bkmkstart AAAAAAABOG}
{\bkmkend AAAAAAABOG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 517 of file unity_internals.h.}\par
}
{\xe \v TestIgnores\:UNITY_STORAGE_T}
{\xe \v UNITY_STORAGE_T\:TestIgnores}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UNITY_COUNTER_TYPE} UNITY_STORAGE_T::TestIgnores}}
\par
{\bkmkstart AAAAAAABOH}
{\bkmkend AAAAAAABOH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 526 of file unity_internals.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b unity_internals.h}\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Documentation{\tc \v File Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
inc/actuators.h File Reference\par \pard\plain 
{\tc\tcl2 \v inc/actuators.h}
{\xe \v inc/actuators.h}
{\bkmkstart AAAAAAAAAA}
{\bkmkend AAAAAAAAAA}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdbool.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for actuators.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "actuators_8h__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "actuators_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b actuators_abstraction}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
inc/constants.h File Reference\par \pard\plain 
{\tc\tcl2 \v inc/constants.h}
{\xe \v inc/constants.h}
{\bkmkstart AAAAAAAAAB}
{\bkmkend AAAAAAAAAB}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "constants_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SENSORS_MQ}\~ "/mq_aeb_sensors"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ACTUATORS_MQ}\~ "/mq_aeb_actuators"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQ_MAX_MESSAGES}\~ 10\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQ_MAX_MSG_SIZE}\~ 12\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SHM_NAME}\~ "/shm_aeb"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SEM_NAME}\~ "/sem_aeb"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SHM_PERMISSIONS}\~ 0666\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b THRESHOLD_ALARM}\~ 2.0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b THRESHOLD_BRAKING}\~ 1.0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MAX_SPD_ENABLED}\~ 80.0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MIN_SPD_ENABLED}\~ 10.0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v ACTUATORS_MQ\:constants.h}
{\xe \v constants.h\:ACTUATORS_MQ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ACTUATORS_MQ\~ "/mq_aeb_actuators"}}
\par
{\bkmkstart AAAAAAAAAC}
{\bkmkend AAAAAAAAAC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 5 of file constants.h.}\par
}
{\xe \v MAX_SPD_ENABLED\:constants.h}
{\xe \v constants.h\:MAX_SPD_ENABLED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MAX_SPD_ENABLED\~ 80.0}}
\par
{\bkmkstart AAAAAAAAAD}
{\bkmkend AAAAAAAAAD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 18 of file constants.h.}\par
}
{\xe \v MIN_SPD_ENABLED\:constants.h}
{\xe \v constants.h\:MIN_SPD_ENABLED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MIN_SPD_ENABLED\~ 10.0}}
\par
{\bkmkstart AAAAAAAAAE}
{\bkmkend AAAAAAAAAE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 19 of file constants.h.}\par
}
{\xe \v MQ_MAX_MESSAGES\:constants.h}
{\xe \v constants.h\:MQ_MAX_MESSAGES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQ_MAX_MESSAGES\~ 10}}
\par
{\bkmkstart AAAAAAAAAF}
{\bkmkend AAAAAAAAAF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 6 of file constants.h.}\par
}
{\xe \v MQ_MAX_MSG_SIZE\:constants.h}
{\xe \v constants.h\:MQ_MAX_MSG_SIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQ_MAX_MSG_SIZE\~ 12}}
\par
{\bkmkstart AAAAAAAAAG}
{\bkmkend AAAAAAAAAG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 7 of file constants.h.}\par
}
{\xe \v SEM_NAME\:constants.h}
{\xe \v constants.h\:SEM_NAME}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SEM_NAME\~ "/sem_aeb"}}
\par
{\bkmkstart AAAAAAAAAH}
{\bkmkend AAAAAAAAAH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 10 of file constants.h.}\par
}
{\xe \v SENSORS_MQ\:constants.h}
{\xe \v constants.h\:SENSORS_MQ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SENSORS_MQ\~ "/mq_aeb_sensors"}}
\par
{\bkmkstart AAAAAAAAAI}
{\bkmkend AAAAAAAAAI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 4 of file constants.h.}\par
}
{\xe \v SHM_NAME\:constants.h}
{\xe \v constants.h\:SHM_NAME}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SHM_NAME\~ "/shm_aeb"}}
\par
{\bkmkstart AAAAAAAAAJ}
{\bkmkend AAAAAAAAAJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9 of file constants.h.}\par
}
{\xe \v SHM_PERMISSIONS\:constants.h}
{\xe \v constants.h\:SHM_PERMISSIONS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SHM_PERMISSIONS\~ 0666}}
\par
{\bkmkstart AAAAAAAAAK}
{\bkmkend AAAAAAAAAK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 11 of file constants.h.}\par
}
{\xe \v THRESHOLD_ALARM\:constants.h}
{\xe \v constants.h\:THRESHOLD_ALARM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define THRESHOLD_ALARM\~ 2.0}}
\par
{\bkmkstart AAAAAAAAAL}
{\bkmkend AAAAAAAAAL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 16 of file constants.h.}\par
}
{\xe \v THRESHOLD_BRAKING\:constants.h}
{\xe \v constants.h\:THRESHOLD_BRAKING}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define THRESHOLD_BRAKING\~ 1.0}}
\par
{\bkmkstart AAAAAAAAAM}
{\bkmkend AAAAAAAAAM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 17 of file constants.h.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
inc/dbc.h File Reference\par \pard\plain 
{\tc\tcl2 \v inc/dbc.h}
{\xe \v inc/dbc.h}
{\bkmkstart AAAAAAAAAN}
{\bkmkend AAAAAAAAAN}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdint.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for dbc.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dbc_8h__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dbc_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b can_msg}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ID_PEDALS}\~ 0x18FEF100\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ID_SPEED_S}\~ 0x18FFFD64\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ID_OBSTACLE_S}\~ 0x0CFFB027\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ID_CAR_C}\~ 0x0CFFAF27\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ID_AEB_S}\~ 0x18FFA027\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BASE_DATA_FRAME}\~ \{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF\}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MAX_SPEED_S}\~ 251\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MAX_OBSTACLE_S}\~ 150\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b RES_SPEED_S}\~ (1.0 / 256.0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b RES_OBSTACLE_S}\~ (1.0 / 20.0)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b print_can_msg} (const {\b can_msg} *msg)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v BASE_DATA_FRAME\:dbc.h}
{\xe \v dbc.h\:BASE_DATA_FRAME}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BASE_DATA_FRAME\~ \{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF\}}}
\par
{\bkmkstart AAAAAAAAAO}
{\bkmkend AAAAAAAAAO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 14 of file dbc.h.}\par
}
{\xe \v ID_AEB_S\:dbc.h}
{\xe \v dbc.h\:ID_AEB_S}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ID_AEB_S\~ 0x18FFA027}}
\par
{\bkmkstart AAAAAAAAAP}
{\bkmkend AAAAAAAAAP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 11 of file dbc.h.}\par
}
{\xe \v ID_CAR_C\:dbc.h}
{\xe \v dbc.h\:ID_CAR_C}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ID_CAR_C\~ 0x0CFFAF27}}
\par
{\bkmkstart AAAAAAAAAQ}
{\bkmkend AAAAAAAAAQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 10 of file dbc.h.}\par
}
{\xe \v ID_OBSTACLE_S\:dbc.h}
{\xe \v dbc.h\:ID_OBSTACLE_S}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ID_OBSTACLE_S\~ 0x0CFFB027}}
\par
{\bkmkstart AAAAAAAAAR}
{\bkmkend AAAAAAAAAR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9 of file dbc.h.}\par
}
{\xe \v ID_PEDALS\:dbc.h}
{\xe \v dbc.h\:ID_PEDALS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ID_PEDALS\~ 0x18FEF100}}
\par
{\bkmkstart AAAAAAAAAS}
{\bkmkend AAAAAAAAAS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 7 of file dbc.h.}\par
}
{\xe \v ID_SPEED_S\:dbc.h}
{\xe \v dbc.h\:ID_SPEED_S}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ID_SPEED_S\~ 0x18FFFD64}}
\par
{\bkmkstart AAAAAAAAAT}
{\bkmkend AAAAAAAAAT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 8 of file dbc.h.}\par
}
{\xe \v MAX_OBSTACLE_S\:dbc.h}
{\xe \v dbc.h\:MAX_OBSTACLE_S}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MAX_OBSTACLE_S\~ 150}}
\par
{\bkmkstart AAAAAAAAAU}
{\bkmkend AAAAAAAAAU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 17 of file dbc.h.}\par
}
{\xe \v MAX_SPEED_S\:dbc.h}
{\xe \v dbc.h\:MAX_SPEED_S}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MAX_SPEED_S\~ 251}}
\par
{\bkmkstart AAAAAAAAAV}
{\bkmkend AAAAAAAAAV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 16 of file dbc.h.}\par
}
{\xe \v RES_OBSTACLE_S\:dbc.h}
{\xe \v dbc.h\:RES_OBSTACLE_S}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define RES_OBSTACLE_S\~ (1.0 / 20.0)}}
\par
{\bkmkstart AAAAAAAAAW}
{\bkmkend AAAAAAAAAW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 20 of file dbc.h.}\par
}
{\xe \v RES_SPEED_S\:dbc.h}
{\xe \v dbc.h\:RES_SPEED_S}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define RES_SPEED_S\~ (1.0 / 256.0)}}
\par
{\bkmkstart AAAAAAAAAX}
{\bkmkend AAAAAAAAAX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 19 of file dbc.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v print_can_msg\:dbc.h}
{\xe \v dbc.h\:print_can_msg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void print_can_msg (const {\b can_msg} *  {\i msg})}}
\par
{\bkmkstart AAAAAAAAAY}
{\bkmkend AAAAAAAAAY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 4 of file dbc.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4                                        \{\par
5     printf({\cf22 "Identifier: %08X\\n"}, msg->identifier);\par
6     printf({\cf22 "Data Frame: "});\par
7     {\cf19 for} ({\cf18 int} i = 0; i < 8; i++) \{\par
8         printf({\cf22 "%02X "}, msg->dataFrame[i]);\par
9     \}\par
10     printf({\cf22 "\\n"});\par
11 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
inc/file_reader.h File Reference\par \pard\plain 
{\tc\tcl2 \v inc/file_reader.h}
{\xe \v inc/file_reader.h}
{\bkmkstart AAAAAAAAAZ}
{\bkmkend AAAAAAAAAZ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdio.h>}\par
{\f2 #include "sensors_input.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for file_reader.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "file__reader_8h__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "file__reader_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
FILE * {\b open_file} (const char *filename)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Opens a file for reading and skips the first line (header). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b read_sensor_data} (FILE *file, {\b sensors_input_data} *sensor_data)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads a line from the file and fills the sensor data structure. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v open_file\:file_reader.h}
{\xe \v file_reader.h\:open_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
FILE* open_file (const char *  {\i filename})}}
\par
{\bkmkstart AAAAAAAABA}
{\bkmkend AAAAAAAABA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Opens a file for reading and skips the first line (header). }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i filename} \cell }{Name of the file to be opened. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
FILE* Pointer to the opened file. \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
If the file cannot be opened, the program exits with an error. \par
}}}{
Definition at line 12 of file file_reader.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 12                                       \{\par
13     FILE *file = fopen(filename, {\cf22 "r"});\par
14     {\cf19 if} (file == NULL) \{\par
15         perror({\cf22 "Erro ao abrir o arquivo"});\par
16         exit(EXIT_FAILURE);\par
17     \}\par
18 \par
19     {\cf20 // Skip header}\par
20     {\cf18 char} header[100];\par
21     fgets(header, {\cf17 sizeof}(header), file);\par
22 \par
23     {\cf19 return} file;\par
24 \}\par
}
}
{\xe \v read_sensor_data\:file_reader.h}
{\xe \v file_reader.h\:read_sensor_data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int read_sensor_data (FILE *  {\i file}, {\b sensors_input_data} *  {\i sensor_data})}}
\par
{\bkmkstart AAAAAAAABB}
{\bkmkend AAAAAAAABB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads a line from the file and fills the sensor data structure. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i file} \cell }{Pointer to the opened file. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i sensor_data} \cell }{Pointer to the structure where the data will be stored. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
int Returns 1 if the reading is successful, 0 otherwise.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The expected file format will follow this label formact: Distance(m) Obstacle Speed(m/s) Brake Accelerator AEB_on_off Reverse \par
}}}{
Definition at line 37 of file file_reader.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 37                                                                   \{\par
38     {\cf19 return} fscanf(file, {\cf22 "%lf %d %lf %d %d %d %d"}, \par
39                   &sensor_data->obstacle_distance, \par
40                   &sensor_data->has_obstacle, \par
41                   &sensor_data->vehicle_velocity, \par
42                   &sensor_data->brake_pedal, \par
43                   &sensor_data->accelerator_pedal, \par
44                   &sensor_data->on_off_aeb_system,\par
45                   &sensor_data->reverseEnabled\par
46                 ) == 7;\par
47 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
inc/log_utils.h File Reference\par \pard\plain 
{\tc\tcl2 \v inc/log_utils.h}
{\xe \v inc/log_utils.h}
{\bkmkstart AAAAAAAABC}
{\bkmkend AAAAAAAABC}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdio.h>}\par
{\f2 #include <actuators.h>}\par
{\f2 #include <stdint.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for log_utils.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "log__utils_8h__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "log__utils_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b log_event} (const char *id_aeb, uint32_t event_id, {\b actuators_abstraction} actuators)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Logs an event to a file with a timestamp and actuator data. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v log_event\:log_utils.h}
{\xe \v log_utils.h\:log_event}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void log_event (const char *  {\i id_aeb}, uint32_t  {\i event_id}, {\b actuators_abstraction}  {\i actuators})}}
\par
{\bkmkstart AAAAAAAABD}
{\bkmkend AAAAAAAABD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Logs an event to a file with a timestamp and actuator data. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function logs an event by appending it to a log file. It records the event ID, the timestamp (in milliseconds), and actuator states in a structured format.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i id_aeb} \cell }{Identifier for the AEB system. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i event_id} \cell }{The unique event identifier (formatted as a hexadecimal string). \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i actuators} \cell }{Structure containing actuator state information. \cell }
{\row }
}
}{
Definition at line 18 of file log_utils.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18                                                                                        \{\par
19     FILE *log_file = fopen({\cf22 "log/log.txt"}, {\cf22 "a"});\par
20     {\cf19 if} (log_file == NULL) \{\par
21         perror({\cf22 "Error opening log file"});\par
22         {\cf19 return};\par
23     \}\par
24 \par
25     {\cf20 // Getting the timestamp instead just the date, because it's more useful (miliseconds)}\par
26     {\cf17 struct }timespec ts;\par
27     clock_gettime(CLOCK_REALTIME, &ts);\par
28     {\cf18 long} timestamp_ms = ts.tv_sec * 1000 + ts.tv_nsec / 1000000;\par
29 \par
30     {\cf20 // Convert id to hexadecimal string}\par
31     {\cf18 char} event_id_str[9]; {\cf20 // 8 caracteres + '\\0'}\par
32     snprintf(event_id_str, {\cf17 sizeof}(event_id_str), {\cf22 "%08X"}, event_id);\par
33 \par
34     {\cf20 // Write in file in desired format}\par
35     fprintf(log_file, {\cf22 "[%s][%s][T:%07ld] WARNING | %d | %d | %d | %d | %d\\n"},\par
36             id_aeb,\par
37             event_id_str,\par
38             timestamp_ms,\par
39             actuators.belt_tightness,\par
40             actuators.door_lock,\par
41             actuators.should_activate_abs,\par
42             actuators.alarm_led,\par
43             actuators.alarm_buzzer);\par
44 \par
45     fclose(log_file);\par
46 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
inc/mq_utils.h File Reference\par \pard\plain 
{\tc\tcl2 \v inc/mq_utils.h}
{\xe \v inc/mq_utils.h}
{\bkmkstart AAAAAAAABE}
{\bkmkend AAAAAAAABE}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <mqueue.h>}\par
{\f2 #include "dbc.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for mq_utils.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "mq__utils_8h__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "mq__utils_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct mq_attr {\b get_mq_attr} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
mqd_t {\b create_mq} (char *{\b mq_name})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
mqd_t {\b open_mq} (char *{\b mq_name})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b close_mq} (mqd_t {\b mqd}, char *{\b mq_name})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b read_mq} (mqd_t mq_receiver, {\b can_msg} *msg_read)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b write_mq} (mqd_t mq_sender, {\b can_msg} *msg)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v close_mq\:mq_utils.h}
{\xe \v mq_utils.h\:close_mq}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void close_mq (mqd_t  {\i mqd}, char *  {\i mq_name})}}
\par
{\bkmkstart AAAAAAAABF}
{\bkmkend AAAAAAAABF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 46 of file mq_utils.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 47 \{\par
48     printf({\cf22 "Closing %s message queue\\n"}, mq_name);\par
49     {\cf19 if} (mq_close(mqd) == -1)\par
50     \{\par
51         perror({\cf22 "Error closing message queue"});\par
52         exit(1);\par
53     \}\par
54     {\cf19 if} (mq_unlink(mq_name) == -1)\par
55     \{\par
56         perror({\cf22 "Error unlinking message queue"});\par
57         exit(1);\par
58     \}\par
59 \}\par
}
}
{\xe \v create_mq\:mq_utils.h}
{\xe \v mq_utils.h\:create_mq}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
mqd_t create_mq (char *  {\i mq_name})}}
\par
{\bkmkstart AAAAAAAABG}
{\bkmkend AAAAAAAABG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 19 of file mq_utils.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 20 \{\par
21     {\cf17 struct }mq_attr attr = get_mq_attr();\par
22     mqd_t mqd = mq_open(mq_name, O_RDWR | O_CREAT | O_NONBLOCK, QUEUE_PERMISSIONS, &attr);\par
23     {\cf19 if} (mqd == (mqd_t)-1)\par
24     \{\par
25         perror({\cf22 "Error creating message queue"});\par
26         exit(1);\par
27     \}\par
28 \par
29     printf({\cf22 "Queue %s created\\n"}, mq_name);\par
30 \par
31     {\cf19 return} mqd;\par
32 \}\par
}
}
{\xe \v get_mq_attr\:mq_utils.h}
{\xe \v mq_utils.h\:get_mq_attr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct mq_attr get_mq_attr ()}}
\par
{\bkmkstart AAAAAAAABH}
{\bkmkend AAAAAAAABH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1 of file mq_utils.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10 \{\par
11     {\cf17 struct }mq_attr attr;\par
12     attr.mq_flags = O_NONBLOCK;\par
13     attr.mq_curmsgs = 0;\par
14     attr.mq_maxmsg = MQ_MAX_MESSAGES;\par
15     attr.mq_msgsize = MQ_MAX_MSG_SIZE;\par
16     {\cf19 return} attr;\par
17 \}\par
}
}
{\xe \v open_mq\:mq_utils.h}
{\xe \v mq_utils.h\:open_mq}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
mqd_t open_mq (char *  {\i mq_name})}}
\par
{\bkmkstart AAAAAAAABI}
{\bkmkend AAAAAAAABI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 34 of file mq_utils.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 35 \{\par
36     {\cf17 struct }mq_attr attr = get_mq_attr();\par
37     mqd_t mqd = mq_open(mq_name, O_RDWR | O_NONBLOCK, QUEUE_PERMISSIONS, &attr);\par
38     {\cf19 if} (mqd == (mqd_t)-1)\par
39     \{\par
40         perror({\cf22 "Error opening message queue"});\par
41         exit(1);\par
42     \}\par
43     {\cf19 return} mqd;\par
44 \}\par
}
}
{\xe \v read_mq\:mq_utils.h}
{\xe \v mq_utils.h\:read_mq}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int read_mq (mqd_t  {\i mq_receiver}, {\b can_msg} *  {\i msg_read})}}
\par
{\bkmkstart AAAAAAAABJ}
{\bkmkend AAAAAAAABJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 61 of file mq_utils.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 62 \{\par
63     {\cf18 char} buffer[MQ_MAX_MSG_SIZE];\par
64     {\cf19 if} (mq_receive(mq_receiver, buffer, MQ_MAX_MSG_SIZE, NULL) == (mqd_t)-1)\par
65     \{\par
66         {\cf20 // perror("Error receiving message");}\par
67         {\cf19 return} -1;\par
68     \}\par
69     memcpy(msg_read, buffer, MQ_MAX_MSG_SIZE);\par
70     {\cf19 return} 0;\par
71 \}\par
}
}
{\xe \v write_mq\:mq_utils.h}
{\xe \v mq_utils.h\:write_mq}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int write_mq (mqd_t  {\i mq_sender}, {\b can_msg} *  {\i msg})}}
\par
{\bkmkstart AAAAAAAABK}
{\bkmkend AAAAAAAABK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 73 of file mq_utils.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 74 \{\par
75     {\cf18 char} buffer[MQ_MAX_MSG_SIZE];\par
76     memcpy(buffer, msg, MQ_MAX_MSG_SIZE);\par
77     {\cf19 if} (mq_send(mq_sender, buffer, MQ_MAX_MSG_SIZE, 0) == -1)\par
78     \{\par
79         perror({\cf22 "Error sending message. Message queue is full"});\par
80         {\cf19 return} -1;\par
81     \}\par
82     {\cf19 return} 0;\par
83 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
inc/sensors_input.h File Reference\par \pard\plain 
{\tc\tcl2 \v inc/sensors_input.h}
{\xe \v inc/sensors_input.h}
{\bkmkstart AAAAAAAABL}
{\bkmkend AAAAAAAABL}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdbool.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for sensors_input.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "sensors__input_8h__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "sensors__input_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b sensors_input_data}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
inc/ttc_control.h File Reference\par \pard\plain 
{\tc\tcl2 \v inc/ttc_control.h}
{\xe \v inc/ttc_control.h}
{\bkmkstart AAAAAAAABM}
{\bkmkend AAAAAAAABM}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <math.h>}\par
{\f2 #include <time.h>}\par
{\f2 #include <stdbool.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for ttc_control.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "ttc__control_8h__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "ttc__control_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b accel_calc} (float spd)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calculate acceleration based on speed and time difference. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b ttc_calc} (float dist, float spd)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calculate the time to collision (TTC) based on relative distance and speed. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b aeb_control} (bool *enable_aeb, bool *alarm_cluster, bool *enable_breaking, bool *lk_seatbelt, bool *lk_doors, float *spd, float *dist)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Controls the Autonomous Emergency Braking (AEB) system. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v accel_calc\:ttc_control.h}
{\xe \v ttc_control.h\:accel_calc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float accel_calc (float  {\i spd})}}
\par
{\bkmkstart AAAAAAAABN}
{\bkmkend AAAAAAAABN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calculate acceleration based on speed and time difference. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function calculates the acceleration in m/s\'B2 based on the difference in speed and time. It uses the {\f2 clock_gettime}  function to measure the time difference between consecutive calls and calculates acceleration as the change in speed divided by the elapsed time [SwR-11].\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i spd} \cell }{Current speed in km/h.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The acceleration in m/s\'B2. If the function is called for the first time or there is insufficient time difference between calls, it returns 0.0. \par
}}}{
Definition at line 17 of file ttc_control.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17                             \{\par
18     {\cf17 static} {\cf18 float} prev_spd = 0.0;\par
19     {\cf17 static} {\cf17 struct }timespec start_time = \{0, 0\};\par
20     {\cf17 struct }timespec current_time;\par
21     {\cf18 double} elapsed_time;\par
22     {\cf18 float} accel = 0.0;\par
23 \par
24     clock_gettime(CLOCK_REALTIME, &current_time);\par
25 \par
26     {\cf19 if} (prev_spd == 0.0) \{\par
27         prev_spd = spd;\par
28         start_time = current_time;\par
29         {\cf19 return} 0.0;\par
30     \}\par
31 \par
32     {\cf19 else} \{\par
33         elapsed_time = (double)(current_time.tv_sec - start_time.tv_sec) \par
34                         + (double)(current_time.tv_nsec - start_time.tv_nsec) / 1e9;\par
35         {\cf19 if} (elapsed_time < 0.01) {\cf19 return} 0.0;\par
36         \par
37         accel = ((spd - prev_spd) / 3.6) / elapsed_time;\par
38         start_time = current_time;\par
39         prev_spd = spd;\par
40         \par
41         {\cf19 return} accel;\par
42     \} \par
43 \}\par
}
}
{\xe \v aeb_control\:ttc_control.h}
{\xe \v ttc_control.h\:aeb_control}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void aeb_control (bool *  {\i enable_aeb}, bool *  {\i alarm_cluster}, bool *  {\i enable_breaking}, bool *  {\i lk_seatbelt}, bool *  {\i lk_doors}, float *  {\i spd}, float *  {\i dist})}}
\par
{\bkmkstart AAAAAAAABO}
{\bkmkend AAAAAAAABO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Controls the Autonomous Emergency Braking (AEB) system. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function calculates the Time to Collision (TTC) based on the relative distance and speed of the vehicle. If the TTC is below a certain threshold, the AEB system triggers the alarm and may engage the braking system. It also prepares other safety features like seatbelt locking and door unlocking in critical conditions.\par
The decision is made based on predefined TTC thresholds:{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
If the TTC is below the {\f2 THRESHOLD_ALARM}  (e.g., 2 seconds), an alarm is triggered.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
If the TTC is below the {\f2 THRESHOLD_BRAKING}  (e.g., 1 second), the braking system is activated.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
If the TTC is less than half of the braking threshold, the braking system is prepared for a collision.\par}
The AEB system and the alarm are only triggered if the {\f2 enable_aeb}  flag is set to true.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i enable_aeb} \cell }{A pointer to a boolean flag that enables or disables the AEB system. [SwR-5] \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i alarm_cluster} \cell }{A pointer to a boolean flag that triggers the alarm in the cluster. [SwR-2] \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i enable_breaking} \cell }{A pointer to a boolean flag that enables or disables the braking system. [SwR-3] \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i lk_seatbelt} \cell }{A pointer to a boolean flag that locks the seatbelt in case of emergency. [Sys-F-14] \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i lk_doors} \cell }{A pointer to a boolean flag that locks or unlocks the doors in an emergency. [Sys-F-14] \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i spd} \cell }{A pointer to the current speed of the vehicle (in km/h). \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i dist} \cell }{A pointer to the current distance to the obstacle (in meters).\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The function complies with the requirements (SwR-2, SwR-3, SwR-5, SwR-11, SwR-14, SwR-15, Sys-F-8, Sys-F-9, Sys-F-14). \par
}}}{
Definition at line 107 of file ttc_control.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 108                                                                              \{\par
109     {\cf18 float} ttc;\par
110     \par
111     ttc = ttc_calc(*dist, *spd);\par
112     \par
113     {\cf19 if} ((*enable_aeb) && (ttc > 0.0) && (ttc < THRESHOLD_ALARM)) \{\par
114         *alarm_cluster = {\cf17 true};\par
115         \par
116         {\cf19 if} ((ttc < THRESHOLD_BRAKING) && (!*enable_breaking) && (*spd < MAX_SPD_ENABLED)\par
117             && (*spd > MIN_SPD_ENABLED)) \{\par
118             *enable_breaking = {\cf17 true};\par
119             {\cf19 if} (ttc < (THRESHOLD_BRAKING / 2.0)) \{\par
120                 *lk_seatbelt = {\cf17 true};  \par
121                 *lk_doors = {\cf17 false};    \par
122             \}\par
123         \}       \par
124     \} {\cf19 else} \{\par
125         *alarm_cluster = {\cf17 false};\par
126         *enable_breaking = {\cf17 false};\par
127     \}\par
128 \}\par
}
}
{\xe \v ttc_calc\:ttc_control.h}
{\xe \v ttc_control.h\:ttc_calc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float ttc_calc (float  {\i dis_rel}, float  {\i spd_rel})}}
\par
{\bkmkstart AAAAAAAABP}
{\bkmkend AAAAAAAABP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calculate the time to collision (TTC) based on relative distance and speed. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function calculates the time to collision using the Uniformly Variable Motion (UVM) model. It uses a quadratic equation to calculate the time to collision (TTC) between two objects based on their relative distance and speed. If the relative acceleration is zero, the function simply calculates the time by dividing the relative distance by the relative speed [SwR-1], [SwR-10], [SwR-11].\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i dis_rel} \cell }{The relative distance between the objects in meters. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i spd_rel} \cell }{The relative speed between the objects in km/h.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The time to collision in seconds. If no real solution is found (i.e., negative discriminant), the function returns -1.0. If there is no relative acceleration, the time to collision is calculated as distance divided by speed. \par
}}}{
Definition at line 60 of file ttc_control.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 60                                              \{\par
61     {\cf18 float} a, b, c, ttc, delta;\par
62     \par
63     a = accel_calc(spd_rel);\par
64     b = spd_rel / 3.6;\par
65     c = dis_rel;\par
66 \par
67     {\cf19 if} (a == 0) {\cf19 return} ttc = c / b;\par
68 \par
69     delta = b * b + 2 * a * c;\par
70     \par
71     {\cf19 if} (delta < 0) {\cf19 return} -1.0;\par
72 \par
73     {\cf19 else} {\cf19 if} (delta == 0) {\cf19 return} -b / a;\par
74 \par
75     {\cf19 else} \{\par
76         ttc = (-b + sqrt(delta)) / a;\par
77         {\cf19 return} ttc;\par
78     \}\par
79 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
README.md File Reference\par \pard\plain 
{\tc\tcl2 \v README.md}
{\xe \v README.md}
{\bkmkstart AAAAAAAABQ}
{\bkmkend AAAAAAAABQ}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/actuators.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/actuators.c}
{\xe \v src/actuators.c}
{\bkmkstart AAAAAAAABR}
{\bkmkend AAAAAAAABR}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdio.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <unistd.h>}\par
{\f2 #include <mqueue.h>}\par
{\f2 #include <stdbool.h>}\par
{\f2 #include <pthread.h>}\par
{\f2 #include "mq_utils.h"}\par
{\f2 #include "constants.h"}\par
{\f2 #include "actuators.h"}\par
{\f2 #include "dbc.h"}\par
{\f2 #include "log_utils.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for actuators.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "actuators_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b LOOP_EMPTY_ITERATIONS_MAX}\~ 11\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b actuatorsResponseLoop} (void *arg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b actuatorsTranslateCanMsg} ({\b can_msg} captured_frame)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b updateInternalActuatorsState} ({\b can_msg} captured_frame)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
mqd_t {\b actuators_mq}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
pthread_t {\b actuators_id}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b actuators_abstraction} {\b actuators_state}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b can_msg} {\b captured_can_frame}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v LOOP_EMPTY_ITERATIONS_MAX\:actuators.c}
{\xe \v actuators.c\:LOOP_EMPTY_ITERATIONS_MAX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define LOOP_EMPTY_ITERATIONS_MAX\~ 11}}
\par
{\bkmkstart AAAAAAAABS}
{\bkmkend AAAAAAAABS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 13 of file actuators.c.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v actuatorsResponseLoop\:actuators.c}
{\xe \v actuators.c\:actuatorsResponseLoop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void * actuatorsResponseLoop (void *  {\i arg})}}
\par
{\bkmkstart AAAAAAAABT}
{\bkmkend AAAAAAAABT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 49 of file actuators.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 49                                       \{\par
50     {\cf20 // Step 01: Recieve message from Message Queue, with new data sent by AEB}\par
51     {\cf20 // Step 02: Convert data from the AEB can_msg to actuators_state memory}\par
52     {\cf20 // Step 03: Do the right activation from the actuator -> }\par
53     {\cf20 // i.e., in our project, writing the correct expected output in a txt ou csv, since this is an abstraction}\par
54     {\cf20 // Step 04: sleep, waiting the next message -> loop}\par
55     {\cf20 // we must define a Stop criteria btw}\par
56 \par
57     {\cf18 int} no_message_counter = 0;\par
58     {\cf18 int} result;\par
59 \par
60     {\cf19 while}(no_message_counter < LOOP_EMPTY_ITERATIONS_MAX)\{\par
61         result = read_mq(actuators_mq, &captured_can_frame);\par
62         {\cf19 if}(result == 0)\{\par
63             actuatorsTranslateCanMsg(captured_can_frame); \par
64             no_message_counter = 0;\par
65         \} {\cf19 else} {\cf19 if} (result == -1)\{\par
66             no_message_counter++;\par
67         \} {\cf19 else} \{\par
68             perror({\cf22 "\\n"});\par
69             {\cf19 break};\par
70         \}\par
71         \par
72         uint32_t event_id = 0x63A5D2E1;  {\cf20 // A simple event_id for testing purposes}\par
73 \par
74 \par
75         {\cf20 // write in file here}\par
76         {\cf20 //The condition below is for test porpuse, should be changed to a ttc value}\par
77         log_event({\cf22 "AEB1"}, event_id, actuators_state);\par
78         \par
79 \par
80 \par
81         printf({\cf22 "belt_tightness: %s\\n"}, actuators_state.belt_tightness ? {\cf22 "true"} : {\cf22 "false"});\par
82         printf({\cf22 "door_lock: %s\\n"}, actuators_state.door_lock ? {\cf22 "true"} : {\cf22 "false"});\par
83         printf({\cf22 "should_activate_abs: %s\\n"}, actuators_state.should_activate_abs ? {\cf22 "true"} : {\cf22 "false"});\par
84         printf({\cf22 "alarm_led: %s\\n"}, actuators_state.alarm_led ? {\cf22 "true"} : {\cf22 "false"});\par
85         printf({\cf22 "alarm_buzzer: %s\\n"}, actuators_state.alarm_buzzer ? {\cf22 "true"} : {\cf22 "false"});\par
86 \par
87         usleep(200000); {\cf20 // Deprected, change for function other later}\par
88     \}\par
89 \par
90     printf({\cf22 "Placeholder\\n"});\par
91     {\cf19 return} NULL;\par
92 \}\par
}
}
{\xe \v actuatorsTranslateCanMsg\:actuators.c}
{\xe \v actuators.c\:actuatorsTranslateCanMsg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void actuatorsTranslateCanMsg ({\b can_msg}  {\i captured_frame})}}
\par
{\bkmkstart AAAAAAAABU}
{\bkmkend AAAAAAAABU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 94 of file actuators.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 94                                                      \{\par
95     {\cf19 switch}(captured_frame.identifier)\{\par
96         {\cf19 case} ID_AEB_S:\par
97             updateInternalActuatorsState(captured_frame);\par
98             {\cf19 break};\par
99         {\cf19 default}:\par
100             printf({\cf22 "Actuators: CAN Identifier unknown\\n"});\par
101             {\cf19 break};\par
102     \}\par
103 \}\par
}
}
{\xe \v main\:actuators.c}
{\xe \v actuators.c\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main ()}}
\par
{\bkmkstart AAAAAAAABV}
{\bkmkend AAAAAAAABV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 34 of file actuators.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 34           \{   \par
35     {\cf18 int} actuators_thr;\par
36 \par
37     actuators_mq = open_mq(ACTUATORS_MQ);\par
38 \par
39     actuators_thr = pthread_create(&actuators_id, NULL, actuatorsResponseLoop, NULL);\par
40     {\cf19 if}(actuators_thr != 0)\{\par
41         perror({\cf22 "Actuators: it wasn't possible to create the associated thread\\n"});\par
42         exit(54);\par
43     \}\par
44     actuators_thr = pthread_join(actuators_id, NULL);\par
45 \par
46     {\cf19 return} 0;\par
47 \}\par
}
}
{\xe \v updateInternalActuatorsState\:actuators.c}
{\xe \v actuators.c\:updateInternalActuatorsState}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void updateInternalActuatorsState ({\b can_msg}  {\i captured_frame})}}
\par
{\bkmkstart AAAAAAAABW}
{\bkmkend AAAAAAAABW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 105 of file actuators.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 105                                                          \{\par
106     {\cf19 if}(captured_frame.dataFrame[1] == 0x01)\{\par
107         actuators_state.belt_tightness = {\cf17 true};\par
108         actuators_state.door_lock = {\cf17 false};\par
109         actuators_state.should_activate_abs = {\cf17 true};\par
110         actuators_state.alarm_led = {\cf17 true};\par
111         actuators_state.alarm_buzzer = {\cf17 true};\par
112     \} {\cf19 else} {\cf19 if} (captured_frame.dataFrame[0] == 0x01)\{\par
113         actuators_state.belt_tightness = {\cf17 false};\par
114         actuators_state.door_lock = {\cf17 true};\par
115         actuators_state.should_activate_abs = {\cf17 false};\par
116         actuators_state.alarm_led = {\cf17 true};\par
117         actuators_state.alarm_buzzer = {\cf17 true};\par
118     \} {\cf19 else} \{\par
119         actuators_state.belt_tightness = {\cf17 false};\par
120         actuators_state.door_lock = {\cf17 true};\par
121         actuators_state.should_activate_abs = {\cf17 false};\par
122         actuators_state.alarm_led = {\cf17 false};\par
123         actuators_state.alarm_buzzer = {\cf17 false};        \par
124     \}\par
125 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v actuators_id\:actuators.c}
{\xe \v actuators.c\:actuators_id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
pthread_t actuators_id}}
\par
{\bkmkstart AAAAAAAABX}
{\bkmkend AAAAAAAABX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 20 of file actuators.c.}\par
}
{\xe \v actuators_mq\:actuators.c}
{\xe \v actuators.c\:actuators_mq}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
mqd_t actuators_mq}}
\par
{\bkmkstart AAAAAAAABY}
{\bkmkend AAAAAAAABY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 19 of file actuators.c.}\par
}
{\xe \v actuators_state\:actuators.c}
{\xe \v actuators.c\:actuators_state}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b actuators_abstraction} actuators_state}}
\par
{\bkmkstart AAAAAAAABZ}
{\bkmkend AAAAAAAABZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
    .belt_tightness = {\cf17 false},\par
    .door_lock = {\cf17 true},\par
    .should_activate_abs = {\cf17 false},\par
    .alarm_led = {\cf17 false},\par
    .alarm_buzzer = {\cf17 true}\par
\}\par
}
{
Definition at line 21 of file actuators.c.}\par
}
{\xe \v captured_can_frame\:actuators.c}
{\xe \v actuators.c\:captured_can_frame}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b can_msg} captured_can_frame}}
\par
{\bkmkstart AAAAAAAACA}
{\bkmkend AAAAAAAACA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
    .identifier = 0x0CFFB027,\par
    .dataFrame  = \{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF\}\par
\}\par
}
{
Definition at line 29 of file actuators.c.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/aeb_controller.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/aeb_controller.c}
{\xe \v src/aeb_controller.c}
{\bkmkstart AAAAAAAACB}
{\bkmkend AAAAAAAACB}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdio.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <unistd.h>}\par
{\f2 #include <pthread.h>}\par
{\f2 #include <stdbool.h>}\par
{\f2 #include <time.h>}\par
{\f2 #include "constants.h"}\par
{\f2 #include "mq_utils.h"}\par
{\f2 #include "sensors_input.h"}\par
{\f2 #include "dbc.h"}\par
{\f2 #include "actuators.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for aeb_controller.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "aeb__controller_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b LOOP_EMPTY_ITERATIONS_MAX}\~ 11\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b aeb_controller_state} \{ {\b AEB_STATE_ACTIVE}
, {\b AEB_STATE_ALARM}
, {\b AEB_STATE_BRAKE}
, {\b AEB_STATE_STANDBY}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b mainWorkingLoop} (void *arg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b print_info} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b translateAndCallCanMsg} ({\b can_msg} captured_frame)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b updateInternalPedalsState} ({\b can_msg} captured_frame)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b updateInternalSpeedState} ({\b can_msg} captured_frame)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b updateInternalObstacleState} ({\b can_msg} captured_frame)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b updateInternalCarCState} ({\b can_msg} captured_frame)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b can_msg} {\b updateCanMsgOutput} ({\b aeb_controller_state} state)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b aeb_controller_state} {\b getAEBState} ({\b sensors_input_data} {\b aeb_internal_state}, int ttc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
mqd_t {\b sensors_mq}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
mqd_t {\b actuators_mq}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
pthread_t {\b aeb_controller_id}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b sensors_input_data} {\b aeb_internal_state}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b can_msg} {\b captured_can_frame}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b can_msg} {\b out_can_frame}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v LOOP_EMPTY_ITERATIONS_MAX\:aeb_controller.c}
{\xe \v aeb_controller.c\:LOOP_EMPTY_ITERATIONS_MAX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define LOOP_EMPTY_ITERATIONS_MAX\~ 11}}
\par
{\bkmkstart AAAAAAAACC}
{\bkmkend AAAAAAAACC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 13 of file aeb_controller.c.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeration Type Documentation\par
\pard\plain 
{\xe \v aeb_controller_state\:aeb_controller.c}
{\xe \v aeb_controller.c\:aeb_controller_state}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b aeb_controller_state}}}
\par
{\bkmkstart AAAAAAAACD}
{\bkmkend AAAAAAAACD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v AEB_STATE_ACTIVE\:aeb_controller.c}
{\xe \v aeb_controller.c\:AEB_STATE_ACTIVE}
{\qr AEB_STATE_ACTIVE{\bkmkstart AAAAAAAACE}
{\bkmkend AAAAAAAACE}
\cell }{\cell }{\row }
{\xe \v AEB_STATE_ALARM\:aeb_controller.c}
{\xe \v aeb_controller.c\:AEB_STATE_ALARM}
{\qr AEB_STATE_ALARM{\bkmkstart AAAAAAAACF}
{\bkmkend AAAAAAAACF}
\cell }{\cell }{\row }
{\xe \v AEB_STATE_BRAKE\:aeb_controller.c}
{\xe \v aeb_controller.c\:AEB_STATE_BRAKE}
{\qr AEB_STATE_BRAKE{\bkmkstart AAAAAAAACG}
{\bkmkend AAAAAAAACG}
\cell }{\cell }{\row }
{\xe \v AEB_STATE_STANDBY\:aeb_controller.c}
{\xe \v aeb_controller.c\:AEB_STATE_STANDBY}
{\qr AEB_STATE_STANDBY{\bkmkstart AAAAAAAACH}
{\bkmkend AAAAAAAACH}
\cell }{\cell }{\row }
}
\par
{
Definition at line 15 of file aeb_controller.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 16 \{\par
17     AEB_STATE_ACTIVE,\par
18     AEB_STATE_ALARM,\par
19     AEB_STATE_BRAKE,\par
20     AEB_STATE_STANDBY\par
21 \} aeb_controller_state;\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v getAEBState\:aeb_controller.c}
{\xe \v aeb_controller.c\:getAEBState}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b aeb_controller_state} getAEBState ({\b sensors_input_data}  {\i aeb_internal_state}, int  {\i ttc})}}
\par
{\bkmkstart AAAAAAAACI}
{\bkmkend AAAAAAAACI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 287 of file aeb_controller.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 288 \{\par
289     {\cf19 if} (aeb_internal_state.on_off_aeb_system == {\cf17 false})\par
290         {\cf19 return} AEB_STATE_STANDBY;\par
291     {\cf19 if}(aeb_internal_state.vehicle_velocity < MIN_SPD_ENABLED && aeb_internal_state.reverseEnabled == {\cf17 false})\par
292         {\cf19 return} AEB_STATE_STANDBY;\par
293     {\cf19 if} (aeb_internal_state.vehicle_velocity > MAX_SPD_ENABLED && aeb_internal_state.reverseEnabled == {\cf17 false})\par
294         {\cf19 return} AEB_STATE_STANDBY;\par
295     {\cf19 if} (aeb_internal_state.brake_pedal == {\cf17 false} && aeb_internal_state.accelerator_pedal == {\cf17 false})\par
296     \{\par
297         {\cf19 if} (ttc < THRESHOLD_BRAKING)\par
298             {\cf19 return} AEB_STATE_BRAKE;\par
299         {\cf19 if} (ttc < THRESHOLD_ALARM)\par
300             {\cf19 return} AEB_STATE_ALARM;\par
301     \}\par
302     {\cf19 return} AEB_STATE_ACTIVE;\par
303 \}\par
}
}
{\xe \v main\:aeb_controller.c}
{\xe \v aeb_controller.c\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main ()}}
\par
{\bkmkstart AAAAAAAACJ}
{\bkmkend AAAAAAAACJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 53 of file aeb_controller.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 54 \{\par
55     sensors_mq = open_mq(SENSORS_MQ);\par
56     actuators_mq = open_mq(ACTUATORS_MQ);\par
57 \par
58     {\cf18 int} controller_thread = pthread_create(&aeb_controller_id, NULL, mainWorkingLoop, NULL);\par
59     {\cf19 if} (controller_thread != 0)\par
60     \{\par
61         perror({\cf22 "AEB Controller: It wasn't possible to create the associated thread\\n"});\par
62         exit(53);\par
63     \}\par
64     controller_thread = pthread_join(aeb_controller_id, NULL);\par
65 \par
66     {\cf19 return} 0;\par
67 \}\par
}
}
{\xe \v mainWorkingLoop\:aeb_controller.c}
{\xe \v aeb_controller.c\:mainWorkingLoop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void * mainWorkingLoop (void *  {\i arg})}}
\par
{\bkmkstart AAAAAAAACK}
{\bkmkend AAAAAAAACK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 69 of file aeb_controller.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 70 \{\par
71     {\cf20 // Main Loop function for our AEB Controller ECU}\par
72     {\cf20 // Step 01: Get CAN frames from the sensors message queue}\par
73     {\cf20 // Step 02: Translate the recieved CAN frame, according to its id}\par
74     {\cf20 // Step 03: Call the correct Function, based on the new data recieved (o que eh new data recieved? acho que eh a mensagem nova)}\par
75     {\cf20 // Step 04: Reactions from the AEB System: based on the new data, what should the AEB controller do?}\par
76     {\cf20 // 4.1 - Calculate new ttc}\par
77     {\cf20 // 4.2 - Update send_actuators_state}\par
78     {\cf20 // Should we separate more or can we let everything in this single thread?}\par
79     {\cf20 // Will separating things make us need to worry more about synchronization?}\par
80     {\cf20 // Step 05: Simple sleep timer? This will change when new functions to fulfill requirements are added}\par
81 \par
82     aeb_controller_state state = AEB_STATE_STANDBY;\par
83 \par
84     {\cf18 int} empty_mq_counter = 0;\par
85     {\cf19 while} (empty_mq_counter < LOOP_EMPTY_ITERATIONS_MAX)\par
86     \{\par
87         {\cf19 if} (read_mq(sensors_mq, &captured_can_frame) != -1)\par
88         \{\par
89             empty_mq_counter = 0; {\cf20 // reset counter}\par
90 \par
91             translateAndCallCanMsg(captured_can_frame);\par
92 \par
93             {\cf18 int} ttc = 1; {\cf20 // TODO: Calculate TTC here}\par
94 \par
95             state = getAEBState(aeb_internal_state, ttc);\par
96             printf({\cf22 "Meu state eh: %d\\n"}, state);\par
97 \par
98             out_can_frame = updateCanMsgOutput(state);\par
99             \par
100             write_mq(actuators_mq, &out_can_frame);\par
101 \par
102             {\cf20 // Testing changes, exclude this on production code}\par
103             print_info();\par
104         \}\par
105         {\cf19 else}\par
106             empty_mq_counter++;\par
107 \par
108         usleep(200000); {\cf20 // Deprecated, change for other function later}\par
109     \}\par
110 \par
111     printf({\cf22 "AEB Controller: Empty MQ counter reached the limit, exiting\\n"});\par
112     {\cf19 return} NULL;\par
113 \}\par
}
}
{\xe \v print_info\:aeb_controller.c}
{\xe \v aeb_controller.c\:print_info}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void print_info ()}}
\par
{\bkmkstart AAAAAAAACL}
{\bkmkend AAAAAAAACL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 115 of file aeb_controller.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 116 \{\par
117     printf({\cf22 "vehicle_velocity: %lf\\n"}, aeb_internal_state.vehicle_velocity);\par
118     printf({\cf22 "has_obstacle: %s\\n"}, aeb_internal_state.has_obstacle ? {\cf22 "true"} : {\cf22 "false"});\par
119     printf({\cf22 "obstacle_distance: %lf\\n"}, aeb_internal_state.obstacle_distance);\par
120     printf({\cf22 "brake_pedal: %s\\n"}, aeb_internal_state.brake_pedal ? {\cf22 "true"} : {\cf22 "false"});\par
121     printf({\cf22 "accelerator_pedal: %s\\n"}, aeb_internal_state.accelerator_pedal ? {\cf22 "true"} : {\cf22 "false"});\par
122     printf({\cf22 "on_off_aeb_system: %s\\n"}, aeb_internal_state.on_off_aeb_system ? {\cf22 "true"} : {\cf22 "false"});\par
123     printf({\cf22 "Is vehicle in reverse: %s\\n"}, aeb_internal_state.reverseEnabled ? {\cf22 "true"} : {\cf22 "false"});\par
124 \}\par
}
}
{\xe \v translateAndCallCanMsg\:aeb_controller.c}
{\xe \v aeb_controller.c\:translateAndCallCanMsg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void translateAndCallCanMsg ({\b can_msg}  {\i captured_frame})}}
\par
{\bkmkstart AAAAAAAACM}
{\bkmkend AAAAAAAACM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 126 of file aeb_controller.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 127 \{ {\cf20 // Call aproppriate function to deal with the can_msg}\par
128     {\cf19 switch} (captured_frame.identifier)\par
129     \{\par
130     {\cf19 case} ID_PEDALS:\par
131         updateInternalPedalsState(captured_frame);\par
132         {\cf19 break};\par
133     {\cf19 case} ID_SPEED_S:\par
134         updateInternalSpeedState(captured_frame);\par
135         {\cf19 break};\par
136     {\cf19 case} ID_OBSTACLE_S:\par
137         updateInternalObstacleState(captured_frame);\par
138         {\cf19 break};\par
139     {\cf19 case} ID_CAR_C:\par
140         updateInternalCarCState(captured_frame);\par
141         {\cf19 break};\par
142     {\cf19 default}:\par
143         printf({\cf22 "CAN Identifier unkown\\n"});\par
144         {\cf19 break};\par
145     \}\par
146 \}\par
}
}
{\xe \v updateCanMsgOutput\:aeb_controller.c}
{\xe \v aeb_controller.c\:updateCanMsgOutput}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b can_msg} updateCanMsgOutput ({\b aeb_controller_state}  {\i state})}}
\par
{\bkmkstart AAAAAAAACN}
{\bkmkend AAAAAAAACN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 258 of file aeb_controller.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 259 \{\par
260     can_msg aux = \{.identifier = ID_AEB_S, .dataFrame = BASE_DATA_FRAME\};\par
261 \par
262     {\cf19 switch} (state)\par
263     \{\par
264         {\cf19 case} AEB_STATE_BRAKE:\par
265             aux.dataFrame[0] = 0x01; {\cf20 // activate warning system}\par
266             aux.dataFrame[1] = 0x01; {\cf20 // activate braking system}\par
267             {\cf19 break};\par
268         {\cf19 case} AEB_STATE_ALARM:\par
269             aux.dataFrame[0] = 0x01; {\cf20 // activate warning system}\par
270             aux.dataFrame[1] = 0x00; {\cf20 // don't activate braking system}\par
271             {\cf19 break};\par
272         {\cf19 case} AEB_STATE_ACTIVE:\par
273             aux.dataFrame[0] = 0x00; {\cf20 // don't activate warning system}\par
274             aux.dataFrame[1] = 0x00; {\cf20 // don't activate braking system}\par
275             {\cf19 break};\par
276         {\cf19 case} AEB_STATE_STANDBY:\par
277             aux.dataFrame[0] = 0x00; {\cf20 // don't activate warning system}\par
278             aux.dataFrame[1] = 0x00; {\cf20 // don't activate braking system}\par
279             {\cf19 break};\par
280         {\cf19 default}:\par
281             {\cf19 break};\par
282     \}\par
283 \par
284     {\cf19 return} aux;\par
285 \}\par
}
}
{\xe \v updateInternalCarCState\:aeb_controller.c}
{\xe \v aeb_controller.c\:updateInternalCarCState}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void updateInternalCarCState ({\b can_msg}  {\i captured_frame})}}
\par
{\bkmkstart AAAAAAAACO}
{\bkmkend AAAAAAAACO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 246 of file aeb_controller.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 247 \{\par
248     {\cf19 if} (captured_frame.dataFrame[0] == 0x00)\par
249     \{\par
250         aeb_internal_state.on_off_aeb_system = {\cf17 false};\par
251     \}\par
252     {\cf19 else} {\cf19 if} (captured_frame.dataFrame[0] == 0x01)\par
253     \{\par
254         aeb_internal_state.on_off_aeb_system = {\cf17 true};\par
255     \}\par
256 \}\par
}
}
{\xe \v updateInternalObstacleState\:aeb_controller.c}
{\xe \v aeb_controller.c\:updateInternalObstacleState}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void updateInternalObstacleState ({\b can_msg}  {\i captured_frame})}}
\par
{\bkmkstart AAAAAAAACP}
{\bkmkend AAAAAAAACP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 208 of file aeb_controller.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 209 \{\par
210     {\cf18 unsigned} {\cf18 int} data_distance; {\cf20 // used for can frame conversion}\par
211     {\cf18 double} new_internal_distance = 0.0;\par
212 \par
213     {\cf19 if} (captured_frame.dataFrame[2] == 0x00)\par
214     \{\par
215         aeb_internal_state.has_obstacle = {\cf17 false};\par
216     \}\par
217     {\cf19 else} {\cf19 if} (captured_frame.dataFrame[2] == 0x01)\par
218     \{\par
219         aeb_internal_state.has_obstacle = {\cf17 true};\par
220     \}\par
221 \par
222     {\cf19 if} (captured_frame.dataFrame[1] == 0xFF && captured_frame.dataFrame[0] == 0xFE)\par
223     \{ {\cf20 // DBC: Clear Data}\par
224         {\cf20 // Defined to max distance, to avoid problems with TTC calculation}\par
225         new_internal_distance = 300.0;\par
226     \}\par
227     {\cf19 else} {\cf19 if} (captured_frame.dataFrame[1] == 0xFF && captured_frame.dataFrame[0] == 0xFF)\par
228     \{ {\cf20 // DBC: Do nothing}\par
229         ;\par
230     \}\par
231     {\cf19 else}\par
232     \{\par
233         {\cf20 // Conversion from CAN data frame, according to dbc in the requirement file}\par
234         data_distance = captured_frame.dataFrame[0] + (captured_frame.dataFrame[1] << 8);\par
235         new_internal_distance = data_distance * RES_OBSTACLE_S;\par
236     \}\par
237 \par
238     {\cf19 if} (new_internal_distance > 300.0)\par
239     \{ {\cf20 // DBC: Max value constraint}\par
240         new_internal_distance = 300.0;\par
241     \}\par
242 \par
243     aeb_internal_state.obstacle_distance = new_internal_distance;\par
244 \}\par
}
}
{\xe \v updateInternalPedalsState\:aeb_controller.c}
{\xe \v aeb_controller.c\:updateInternalPedalsState}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void updateInternalPedalsState ({\b can_msg}  {\i captured_frame})}}
\par
{\bkmkstart AAAAAAAACQ}
{\bkmkend AAAAAAAACQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 148 of file aeb_controller.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 149 \{\par
150     {\cf19 if} (captured_frame.dataFrame[0] == 0x00)\par
151     \{\par
152         aeb_internal_state.accelerator_pedal = {\cf17 false};\par
153     \}\par
154     {\cf19 else} {\cf19 if} (captured_frame.dataFrame[0] == 0x01)\par
155     \{\par
156         aeb_internal_state.accelerator_pedal = {\cf17 true};\par
157     \}\par
158 \par
159     {\cf19 if} (captured_frame.dataFrame[1] == 0x00)\par
160     \{\par
161         aeb_internal_state.brake_pedal = {\cf17 false};\par
162     \}\par
163     {\cf19 else} {\cf19 if} (captured_frame.dataFrame[1] == 0x01)\par
164     \{\par
165         aeb_internal_state.brake_pedal = {\cf17 true};\par
166     \}\par
167 \}\par
}
}
{\xe \v updateInternalSpeedState\:aeb_controller.c}
{\xe \v aeb_controller.c\:updateInternalSpeedState}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void updateInternalSpeedState ({\b can_msg}  {\i captured_frame})}}
\par
{\bkmkstart AAAAAAAACR}
{\bkmkend AAAAAAAACR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 169 of file aeb_controller.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 170 \{\par
171     {\cf18 unsigned} {\cf18 int} data_speed; {\cf20 // used for can frame conversion}\par
172     {\cf18 double} new_internal_speed = 0.0;\par
173 \par
174     {\cf20 // update internal data according to the relative velocity detected by the sensor}\par
175     {\cf19 if} (captured_frame.dataFrame[0] == 0xFE && captured_frame.dataFrame[1] == 0xFF)\par
176     \{ {\cf20 // DBC: Clear Data}\par
177         new_internal_speed = 0.0;\par
178     \}\par
179     {\cf19 else} {\cf19 if} (captured_frame.dataFrame[0] == 0xFF && captured_frame.dataFrame[1] == 0xFF)\par
180     \{ {\cf20 // DBC: Do nothing}\par
181         ;\par
182     \}\par
183     {\cf19 else}\par
184     \{\par
185         {\cf20 // Conversion from CAN data frame, according to dbc in the requirement file}\par
186         data_speed = captured_frame.dataFrame[0] + (captured_frame.dataFrame[1] << 8);\par
187         new_internal_speed = data_speed * RES_SPEED_S;\par
188     \}\par
189 \par
190     {\cf19 if} (new_internal_speed > 251.0)\par
191     \{ {\cf20 // DBC: Max value constraint}\par
192         new_internal_speed = 251.0;\par
193     \}\par
194 \par
195     aeb_internal_state.vehicle_velocity = new_internal_speed;\par
196 \par
197     {\cf20 // update internal data according to the movement direction reported by the sensor}\par
198     {\cf19 if} (captured_frame.dataFrame[2] == 0x00)\par
199     \{\par
200         aeb_internal_state.reverseEnabled = {\cf17 false};\par
201     \}\par
202     {\cf19 else} {\cf19 if} (captured_frame.dataFrame[2] == 0x01)\par
203     \{\par
204         aeb_internal_state.reverseEnabled = {\cf17 true};\par
205     \}\par
206 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v actuators_mq\:aeb_controller.c}
{\xe \v aeb_controller.c\:actuators_mq}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
mqd_t actuators_mq}}
\par
{\bkmkstart AAAAAAAACS}
{\bkmkend AAAAAAAACS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 33 of file aeb_controller.c.}\par
}
{\xe \v aeb_controller_id\:aeb_controller.c}
{\xe \v aeb_controller.c\:aeb_controller_id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
pthread_t aeb_controller_id}}
\par
{\bkmkstart AAAAAAAACT}
{\bkmkend AAAAAAAACT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 34 of file aeb_controller.c.}\par
}
{\xe \v aeb_internal_state\:aeb_controller.c}
{\xe \v aeb_controller.c\:aeb_internal_state}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b sensors_input_data} aeb_internal_state}}
\par
{\bkmkstart AAAAAAAACU}
{\bkmkend AAAAAAAACU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
    .vehicle_velocity = 0.0,\par
    .has_obstacle = {\cf17 false},\par
    .obstacle_distance = 0.0,\par
    .brake_pedal = {\cf17 false},\par
    .accelerator_pedal = {\cf17 false},\par
    .on_off_aeb_system = {\cf17 true},\par
    .reverseEnabled = {\cf17 false}\}\par
}
{
Definition at line 36 of file aeb_controller.c.}\par
}
{\xe \v captured_can_frame\:aeb_controller.c}
{\xe \v aeb_controller.c\:captured_can_frame}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b can_msg} captured_can_frame}}
\par
{\bkmkstart AAAAAAAACV}
{\bkmkend AAAAAAAACV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
    .identifier = ID_CAR_C,\par
    .dataFrame = \{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF\}\}\par
}
{
Definition at line 45 of file aeb_controller.c.}\par
}
{\xe \v out_can_frame\:aeb_controller.c}
{\xe \v aeb_controller.c\:out_can_frame}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b can_msg} out_can_frame}}
\par
{\bkmkstart AAAAAAAACW}
{\bkmkend AAAAAAAACW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
    .identifier = ID_AEB_S,\par
    .dataFrame = \{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF\}\}\par
}
{
Definition at line 49 of file aeb_controller.c.}\par
}
{\xe \v sensors_mq\:aeb_controller.c}
{\xe \v aeb_controller.c\:sensors_mq}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
mqd_t sensors_mq}}
\par
{\bkmkstart AAAAAAAACX}
{\bkmkend AAAAAAAACX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 33 of file aeb_controller.c.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/dbc.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/dbc.c}
{\xe \v src/dbc.c}
{\bkmkstart AAAAAAAACY}
{\bkmkend AAAAAAAACY}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdio.h>}\par
{\f2 #include "dbc.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for dbc.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dbc_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b print_can_msg} (const {\b can_msg} *msg)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v print_can_msg\:dbc.c}
{\xe \v dbc.c\:print_can_msg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void print_can_msg (const {\b can_msg} *  {\i msg})}}
\par
{\bkmkstart AAAAAAAACZ}
{\bkmkend AAAAAAAACZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 4 of file dbc.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4                                        \{\par
5     printf({\cf22 "Identifier: %08X\\n"}, msg->identifier);\par
6     printf({\cf22 "Data Frame: "});\par
7     {\cf19 for} ({\cf18 int} i = 0; i < 8; i++) \{\par
8         printf({\cf22 "%02X "}, msg->dataFrame[i]);\par
9     \}\par
10     printf({\cf22 "\\n"});\par
11 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/file_reader.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/file_reader.c}
{\xe \v src/file_reader.c}
{\bkmkstart AAAAAAAADA}
{\bkmkend AAAAAAAADA}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../inc/file_reader.h"}\par
{\f2 #include <stdlib.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for file_reader.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "file__reader_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
FILE * {\b open_file} (const char *filename)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Opens a file for reading and skips the first line (header). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b read_sensor_data} (FILE *file, {\b sensors_input_data} *sensor_data)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads a line from the file and fills the sensor data structure. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v open_file\:file_reader.c}
{\xe \v file_reader.c\:open_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
FILE* open_file (const char *  {\i filename})}}
\par
{\bkmkstart AAAAAAAADB}
{\bkmkend AAAAAAAADB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Opens a file for reading and skips the first line (header). }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i filename} \cell }{Name of the file to be opened. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
FILE* Pointer to the opened file. \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
If the file cannot be opened, the program exits with an error. \par
}}}{
Definition at line 12 of file file_reader.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 12                                       \{\par
13     FILE *file = fopen(filename, {\cf22 "r"});\par
14     {\cf19 if} (file == NULL) \{\par
15         perror({\cf22 "Erro ao abrir o arquivo"});\par
16         exit(EXIT_FAILURE);\par
17     \}\par
18 \par
19     {\cf20 // Skip header}\par
20     {\cf18 char} header[100];\par
21     fgets(header, {\cf17 sizeof}(header), file);\par
22 \par
23     {\cf19 return} file;\par
24 \}\par
}
}
{\xe \v read_sensor_data\:file_reader.c}
{\xe \v file_reader.c\:read_sensor_data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int read_sensor_data (FILE *  {\i file}, {\b sensors_input_data} *  {\i sensor_data})}}
\par
{\bkmkstart AAAAAAAADC}
{\bkmkend AAAAAAAADC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads a line from the file and fills the sensor data structure. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i file} \cell }{Pointer to the opened file. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i sensor_data} \cell }{Pointer to the structure where the data will be stored. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
int Returns 1 if the reading is successful, 0 otherwise.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The expected file format will follow this label formact: Distance(m) Obstacle Speed(m/s) Brake Accelerator AEB_on_off Reverse \par
}}}{
Definition at line 37 of file file_reader.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 37                                                                   \{\par
38     {\cf19 return} fscanf(file, {\cf22 "%lf %d %lf %d %d %d %d"}, \par
39                   &sensor_data->obstacle_distance, \par
40                   &sensor_data->has_obstacle, \par
41                   &sensor_data->vehicle_velocity, \par
42                   &sensor_data->brake_pedal, \par
43                   &sensor_data->accelerator_pedal, \par
44                   &sensor_data->on_off_aeb_system,\par
45                   &sensor_data->reverseEnabled\par
46                 ) == 7;\par
47 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/log_utils.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/log_utils.c}
{\xe \v src/log_utils.c}
{\bkmkstart AAAAAAAADD}
{\bkmkend AAAAAAAADD}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdio.h>}\par
{\f2 #include <time.h>}\par
{\f2 #include <stdint.h>}\par
{\f2 #include "log_utils.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for log_utils.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "log__utils_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b log_event} (const char *id_aeb, uint32_t event_id, {\b actuators_abstraction} actuators)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Logs an event to a file with a timestamp and actuator data. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v log_event\:log_utils.c}
{\xe \v log_utils.c\:log_event}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void log_event (const char *  {\i id_aeb}, uint32_t  {\i event_id}, {\b actuators_abstraction}  {\i actuators})}}
\par
{\bkmkstart AAAAAAAADE}
{\bkmkend AAAAAAAADE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Logs an event to a file with a timestamp and actuator data. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function logs an event by appending it to a log file. It records the event ID, the timestamp (in milliseconds), and actuator states in a structured format.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i id_aeb} \cell }{Identifier for the AEB system. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i event_id} \cell }{The unique event identifier (formatted as a hexadecimal string). \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i actuators} \cell }{Structure containing actuator state information. \cell }
{\row }
}
}{
Definition at line 18 of file log_utils.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18                                                                                        \{\par
19     FILE *log_file = fopen({\cf22 "log/log.txt"}, {\cf22 "a"});\par
20     {\cf19 if} (log_file == NULL) \{\par
21         perror({\cf22 "Error opening log file"});\par
22         {\cf19 return};\par
23     \}\par
24 \par
25     {\cf20 // Getting the timestamp instead just the date, because it's more useful (miliseconds)}\par
26     {\cf17 struct }timespec ts;\par
27     clock_gettime(CLOCK_REALTIME, &ts);\par
28     {\cf18 long} timestamp_ms = ts.tv_sec * 1000 + ts.tv_nsec / 1000000;\par
29 \par
30     {\cf20 // Convert id to hexadecimal string}\par
31     {\cf18 char} event_id_str[9]; {\cf20 // 8 caracteres + '\\0'}\par
32     snprintf(event_id_str, {\cf17 sizeof}(event_id_str), {\cf22 "%08X"}, event_id);\par
33 \par
34     {\cf20 // Write in file in desired format}\par
35     fprintf(log_file, {\cf22 "[%s][%s][T:%07ld] WARNING | %d | %d | %d | %d | %d\\n"},\par
36             id_aeb,\par
37             event_id_str,\par
38             timestamp_ms,\par
39             actuators.belt_tightness,\par
40             actuators.door_lock,\par
41             actuators.should_activate_abs,\par
42             actuators.alarm_led,\par
43             actuators.alarm_buzzer);\par
44 \par
45     fclose(log_file);\par
46 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/main.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/main.c}
{\xe \v src/main.c}
{\bkmkstart AAAAAAAADF}
{\bkmkend AAAAAAAADF}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdio.h>}\par
{\f2 #include <mqueue.h>}\par
{\f2 #include <pthread.h>}\par
{\f2 #include <unistd.h>}\par
{\f2 #include <signal.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include "mq_utils.h"}\par
{\f2 #include "constants.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for main.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "main_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b wait_terminate_execution} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b terminate_execution} (int sig)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
pid_t {\b create_processes} (char *process_name)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
mqd_t {\b sensors_mq}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
mqd_t {\b actuators_mq}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
pid_t {\b sensors_pid}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
pid_t {\b controller_pid}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
pid_t {\b actuators_pid}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v create_processes\:main.c}
{\xe \v main.c\:create_processes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
pid_t create_processes (char *  {\i process_name})}}
\par
{\bkmkstart AAAAAAAADG}
{\bkmkend AAAAAAAADG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 49 of file main.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 50 \{\par
51     pid_t child_pid = fork();\par
52 \par
53     {\cf19 if}(child_pid < 0)\par
54     \{\par
55         perror({\cf22 "Error creating auxiliary process \\n"});\par
56         exit(1);\par
57     \}\par
58     {\cf19 else} {\cf19 if}(child_pid == 0)\par
59     \{\par
60         {\cf19 if} (execl(process_name, process_name, NULL) == -1) \par
61         \{\par
62             perror({\cf22 "Error executing the process"});\par
63             exit(1);\par
64         \}\par
65     \}\par
66 \par
67     {\cf19 return} child_pid;\par
68 \par
69 \}\par
}
}
{\xe \v main\:main.c}
{\xe \v main.c\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main ()}}
\par
{\bkmkstart AAAAAAAADH}
{\bkmkend AAAAAAAADH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 71 of file main.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 72 \{\par
73     printf({\cf22 "Main process PID: %d\\n"}, getpid());\par
74 \par
75     {\cf20 //Initialize resources}\par
76     sensors_mq = create_mq(SENSORS_MQ);\par
77     sensors_mq = create_mq(ACTUATORS_MQ);\par
78 \par
79     {\cf20 //Create auxiliary processes}\par
80     {\cf18 char} *sensors_process = {\cf22 "./bin/sensors_bin"};\par
81     {\cf18 char} *controller_process = {\cf22 "./bin/aeb_controller_bin"};\par
82     {\cf18 char} *actuators_process = {\cf22 "./bin/actuators_bin"};\par
83 \par
84     sensors_pid = create_processes(sensors_process);\par
85     controller_pid = create_processes(controller_process);\par
86     actuators_pid = create_processes(actuators_process);\par
87 \par
88     signal(SIGINT, terminate_execution);\par
89 \par
90     wait_terminate_execution();\par
91 \par
92     {\cf19 return} EXIT_SUCCESS;\par
93 \}\par
}
}
{\xe \v terminate_execution\:main.c}
{\xe \v main.c\:terminate_execution}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void terminate_execution (int  {\i sig})}}
\par
{\bkmkstart AAAAAAAADI}
{\bkmkend AAAAAAAADI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 28 of file main.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 29 \{\par
30     printf({\cf22 "Closing message queue\\n"});\par
31     close_mq(sensors_mq, SENSORS_MQ);\par
32     close_mq(sensors_mq, ACTUATORS_MQ);\par
33 \par
34 \par
35     printf({\cf22 "Closing child processes\\n"});\par
36     kill(sensors_pid, SIGTERM);\par
37     kill(controller_pid, SIGTERM);\par
38     kill(actuators_pid, SIGTERM);\par
39 \par
40     waitpid(sensors_pid, NULL, 0);\par
41     waitpid(controller_pid, NULL, 0);\par
42     waitpid(actuators_pid, NULL, 0);\par
43 \par
44     printf({\cf22 "Execution terminated\\n"});\par
45 \par
46     exit(0);\par
47 \}\par
}
}
{\xe \v wait_terminate_execution\:main.c}
{\xe \v main.c\:wait_terminate_execution}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void wait_terminate_execution ()}}
\par
{\bkmkstart AAAAAAAADJ}
{\bkmkend AAAAAAAADJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 13 of file main.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14 \{\par
15 \par
16     waitpid(sensors_pid, NULL, 0);\par
17     waitpid(controller_pid, NULL, 0);\par
18     waitpid(actuators_pid, NULL, 0);\par
19 \par
20     printf({\cf22 "Closing message queue\\n"});\par
21     close_mq(sensors_mq, SENSORS_MQ);\par
22     close_mq(actuators_mq, ACTUATORS_MQ);\par
23 \par
24     exit(0);\par
25 \par
26 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v actuators_mq\:main.c}
{\xe \v main.c\:actuators_mq}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
mqd_t actuators_mq}}
\par
{\bkmkstart AAAAAAAADK}
{\bkmkend AAAAAAAADK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 10 of file main.c.}\par
}
{\xe \v actuators_pid\:main.c}
{\xe \v main.c\:actuators_pid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
pid_t actuators_pid}}
\par
{\bkmkstart AAAAAAAADL}
{\bkmkend AAAAAAAADL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 11 of file main.c.}\par
}
{\xe \v controller_pid\:main.c}
{\xe \v main.c\:controller_pid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
pid_t controller_pid}}
\par
{\bkmkstart AAAAAAAADM}
{\bkmkend AAAAAAAADM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 11 of file main.c.}\par
}
{\xe \v sensors_mq\:main.c}
{\xe \v main.c\:sensors_mq}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
mqd_t sensors_mq}}
\par
{\bkmkstart AAAAAAAADN}
{\bkmkend AAAAAAAADN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 10 of file main.c.}\par
}
{\xe \v sensors_pid\:main.c}
{\xe \v main.c\:sensors_pid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
pid_t sensors_pid}}
\par
{\bkmkstart AAAAAAAADO}
{\bkmkend AAAAAAAADO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 11 of file main.c.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/mq_utils.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/mq_utils.c}
{\xe \v src/mq_utils.c}
{\bkmkstart AAAAAAAADP}
{\bkmkend AAAAAAAADP}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "mq_utils.h"}\par
{\f2 #include "constants.h"}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <stdio.h>}\par
{\f2 #include <string.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for mq_utils.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "mq__utils_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b QUEUE_PERMISSIONS}\~ 0660\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct mq_attr {\b get_mq_attr} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
mqd_t {\b create_mq} (char *{\b mq_name})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
mqd_t {\b open_mq} (char *{\b mq_name})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b close_mq} (mqd_t {\b mqd}, char *{\b mq_name})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b read_mq} (mqd_t mq_receiver, {\b can_msg} *msg_read)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b write_mq} (mqd_t mq_sender, {\b can_msg} *msg)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v QUEUE_PERMISSIONS\:mq_utils.c}
{\xe \v mq_utils.c\:QUEUE_PERMISSIONS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define QUEUE_PERMISSIONS\~ 0660}}
\par
{\bkmkstart AAAAAAAADQ}
{\bkmkend AAAAAAAADQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 7 of file mq_utils.c.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v close_mq\:mq_utils.c}
{\xe \v mq_utils.c\:close_mq}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void close_mq (mqd_t  {\i mqd}, char *  {\i mq_name})}}
\par
{\bkmkstart AAAAAAAADR}
{\bkmkend AAAAAAAADR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 46 of file mq_utils.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 47 \{\par
48     printf({\cf22 "Closing %s message queue\\n"}, mq_name);\par
49     {\cf19 if} (mq_close(mqd) == -1)\par
50     \{\par
51         perror({\cf22 "Error closing message queue"});\par
52         exit(1);\par
53     \}\par
54     {\cf19 if} (mq_unlink(mq_name) == -1)\par
55     \{\par
56         perror({\cf22 "Error unlinking message queue"});\par
57         exit(1);\par
58     \}\par
59 \}\par
}
}
{\xe \v create_mq\:mq_utils.c}
{\xe \v mq_utils.c\:create_mq}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
mqd_t create_mq (char *  {\i mq_name})}}
\par
{\bkmkstart AAAAAAAADS}
{\bkmkend AAAAAAAADS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 19 of file mq_utils.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 20 \{\par
21     {\cf17 struct }mq_attr attr = get_mq_attr();\par
22     mqd_t mqd = mq_open(mq_name, O_RDWR | O_CREAT | O_NONBLOCK, QUEUE_PERMISSIONS, &attr);\par
23     {\cf19 if} (mqd == (mqd_t)-1)\par
24     \{\par
25         perror({\cf22 "Error creating message queue"});\par
26         exit(1);\par
27     \}\par
28 \par
29     printf({\cf22 "Queue %s created\\n"}, mq_name);\par
30 \par
31     {\cf19 return} mqd;\par
32 \}\par
}
}
{\xe \v get_mq_attr\:mq_utils.c}
{\xe \v mq_utils.c\:get_mq_attr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct mq_attr get_mq_attr ()}}
\par
{\bkmkstart AAAAAAAADT}
{\bkmkend AAAAAAAADT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1 of file mq_utils.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10 \{\par
11     {\cf17 struct }mq_attr attr;\par
12     attr.mq_flags = O_NONBLOCK;\par
13     attr.mq_curmsgs = 0;\par
14     attr.mq_maxmsg = MQ_MAX_MESSAGES;\par
15     attr.mq_msgsize = MQ_MAX_MSG_SIZE;\par
16     {\cf19 return} attr;\par
17 \}\par
}
}
{\xe \v open_mq\:mq_utils.c}
{\xe \v mq_utils.c\:open_mq}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
mqd_t open_mq (char *  {\i mq_name})}}
\par
{\bkmkstart AAAAAAAADU}
{\bkmkend AAAAAAAADU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 34 of file mq_utils.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 35 \{\par
36     {\cf17 struct }mq_attr attr = get_mq_attr();\par
37     mqd_t mqd = mq_open(mq_name, O_RDWR | O_NONBLOCK, QUEUE_PERMISSIONS, &attr);\par
38     {\cf19 if} (mqd == (mqd_t)-1)\par
39     \{\par
40         perror({\cf22 "Error opening message queue"});\par
41         exit(1);\par
42     \}\par
43     {\cf19 return} mqd;\par
44 \}\par
}
}
{\xe \v read_mq\:mq_utils.c}
{\xe \v mq_utils.c\:read_mq}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int read_mq (mqd_t  {\i mq_receiver}, {\b can_msg} *  {\i msg_read})}}
\par
{\bkmkstart AAAAAAAADV}
{\bkmkend AAAAAAAADV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 61 of file mq_utils.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 62 \{\par
63     {\cf18 char} buffer[MQ_MAX_MSG_SIZE];\par
64     {\cf19 if} (mq_receive(mq_receiver, buffer, MQ_MAX_MSG_SIZE, NULL) == (mqd_t)-1)\par
65     \{\par
66         {\cf20 // perror("Error receiving message");}\par
67         {\cf19 return} -1;\par
68     \}\par
69     memcpy(msg_read, buffer, MQ_MAX_MSG_SIZE);\par
70     {\cf19 return} 0;\par
71 \}\par
}
}
{\xe \v write_mq\:mq_utils.c}
{\xe \v mq_utils.c\:write_mq}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int write_mq (mqd_t  {\i mq_sender}, {\b can_msg} *  {\i msg})}}
\par
{\bkmkstart AAAAAAAADW}
{\bkmkend AAAAAAAADW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 73 of file mq_utils.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 74 \{\par
75     {\cf18 char} buffer[MQ_MAX_MSG_SIZE];\par
76     memcpy(buffer, msg, MQ_MAX_MSG_SIZE);\par
77     {\cf19 if} (mq_send(mq_sender, buffer, MQ_MAX_MSG_SIZE, 0) == -1)\par
78     \{\par
79         perror({\cf22 "Error sending message. Message queue is full"});\par
80         {\cf19 return} -1;\par
81     \}\par
82     {\cf19 return} 0;\par
83 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/sensors.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/sensors.c}
{\xe \v src/sensors.c}
{\bkmkstart AAAAAAAADX}
{\bkmkend AAAAAAAADX}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdio.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <unistd.h>}\par
{\f2 #include "constants.h"}\par
{\f2 #include "mq_utils.h"}\par
{\f2 #include "sensors_input.h"}\par
{\f2 #include <pthread.h>}\par
{\f2 #include <stdbool.h>}\par
{\f2 #include "dbc.h"}\par
{\f2 #include "file_reader.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for sensors.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "sensors_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b getSensorsData} (void *arg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b can_msg} {\b conv2CANCarClusterData} (bool on_off_aeb_system)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b can_msg} {\b conv2CANVelocityData} (bool vehicle_direction, double vehicle_velocity)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b can_msg} {\b conv2CANObstacleData} (bool has_obstacle, double obstacle_distance)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b can_msg} {\b conv2CANPedalsData} (bool brake_pedal, bool accelerator_pedal)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
mqd_t {\b sensors_mq}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
pthread_t {\b sensors_id}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b sensors_input_data} {\b sensorsData}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b can_msg} {\b can_car_cluster}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b can_msg} {\b can_velocity_sensor}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b can_msg} {\b can_obstacle_sensor}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b can_msg} {\b can_pedals_sensor}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v conv2CANCarClusterData\:sensors.c}
{\xe \v sensors.c\:conv2CANCarClusterData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b can_msg} conv2CANCarClusterData (bool  {\i on_off_aeb_system})}}
\par
{\bkmkstart AAAAAAAADY}
{\bkmkend AAAAAAAADY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 91 of file sensors.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 91                                                       \{\par
92     can_msg aux = \{.identifier = ID_CAR_C, .dataFrame = BASE_DATA_FRAME\};\par
93 \par
94     {\cf20 // Enable or disable AEB data encapsulation}\par
95     {\cf19 if}(on_off_aeb_system)\{\par
96         aux.dataFrame[0] = 0x01;\par
97     \}\par
98     {\cf19 else}\{\par
99         aux.dataFrame[0] = 0x00;\par
100     \}\par
101 \par
102     {\cf19 return} aux;\par
103 \}\par
}
}
{\xe \v conv2CANObstacleData\:sensors.c}
{\xe \v sensors.c\:conv2CANObstacleData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b can_msg} conv2CANObstacleData (bool  {\i has_obstacle}, double  {\i obstacle_distance})}}
\par
{\bkmkstart AAAAAAAADZ}
{\bkmkend AAAAAAAADZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 128 of file sensors.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 128                                                                          \{\par
129     can_msg aux = \{.identifier = ID_OBSTACLE_S, .dataFrame = BASE_DATA_FRAME\};\par
130 \par
131     {\cf20 // Obstacle detection data encapsulation}\par
132     {\cf19 if}(has_obstacle)\{\par
133         aux.dataFrame[2] = 0x01;\par
134     \} {\cf19 else} \{\par
135         aux.dataFrame[2] = 0x00;\par
136     \}\par
137 \par
138     {\cf20 // Obstacle distance data \'E2\'80\'8B\'E2\'80\'8Bencapsulation}\par
139     {\cf18 unsigned} {\cf18 int} data_distance = obstacle_distance / RES_OBSTACLE_S;\par
140     {\cf18 unsigned} {\cf18 char} ms_distance, ls_distance;\par
141     ls_distance = data_distance;\par
142     ms_distance = data_distance >> 8;\par
143 \par
144     {\cf20 // Defines most and least significant bytes, according to the DBC specification}\par
145     aux.dataFrame[0] = ls_distance;\par
146     aux.dataFrame[1] = ms_distance;\par
147 \par
148     {\cf19 return} aux;\par
149 \}\par
}
}
{\xe \v conv2CANPedalsData\:sensors.c}
{\xe \v sensors.c\:conv2CANPedalsData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b can_msg} conv2CANPedalsData (bool  {\i brake_pedal}, bool  {\i accelerator_pedal})}}
\par
{\bkmkstart AAAAAAAAEA}
{\bkmkend AAAAAAAAEA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 151 of file sensors.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 151                                                                     \{\par
152     can_msg aux = \{.identifier = ID_PEDALS, .dataFrame = BASE_DATA_FRAME\};\par
153 \par
154     {\cf20 // Brake pedal activation data encapsulation}\par
155     {\cf19 if}(brake_pedal)\{\par
156         aux.dataFrame[1] = 0x01;\par
157     \} {\cf19 else} \{\par
158         aux.dataFrame[1] = 0x00;\par
159     \}\par
160 \par
161     {\cf20 // Accelerator pedal activation data encapsulation}\par
162     {\cf19 if}(accelerator_pedal)\{\par
163         aux.dataFrame[0] = 0x01;\par
164     \} {\cf19 else} \{\par
165         aux.dataFrame[0] = 0x00;\par
166     \}\par
167 \par
168     {\cf19 return} aux;\par
169 \}\par
}
}
{\xe \v conv2CANVelocityData\:sensors.c}
{\xe \v sensors.c\:conv2CANVelocityData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b can_msg} conv2CANVelocityData (bool  {\i vehicle_direction}, double  {\i vehicle_velocity})}}
\par
{\bkmkstart AAAAAAAAEB}
{\bkmkend AAAAAAAAEB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 105 of file sensors.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 105                                                                              \{\par
106     can_msg aux = \{.identifier = ID_SPEED_S, .dataFrame = BASE_DATA_FRAME\};\par
107 \par
108     {\cf20 // Vehicle direction (forward or reverse) data encapsulation}\par
109     {\cf19 if}(vehicle_direction)\{\par
110         aux.dataFrame[2] = 0x01;\par
111     \} {\cf19 else} \{\par
112         aux.dataFrame[2] = 0x00;\par
113     \}\par
114 \par
115     {\cf20 // Speed data \'E2\'80\'8B\'E2\'80\'8Bencapsulation}\par
116     {\cf18 unsigned} {\cf18 int} data_speed = vehicle_velocity / RES_SPEED_S;\par
117     {\cf18 unsigned} {\cf18 char} ms_speed, ls_speed;\par
118     ls_speed = data_speed;\par
119     ms_speed = data_speed >> 8;\par
120 \par
121     {\cf20 // Defines most and least significant bytes, according to the DBC specification}\par
122     aux.dataFrame[0] = ls_speed;\par
123     aux.dataFrame[1] = ms_speed;\par
124 \par
125     {\cf19 return} aux;\par
126 \}\par
}
}
{\xe \v getSensorsData\:sensors.c}
{\xe \v sensors.c\:getSensorsData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void * getSensorsData (void *  {\i arg})}}
\par
{\bkmkstart AAAAAAAAEC}
{\bkmkend AAAAAAAAEC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 46 of file sensors.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 46                                \{\par
47     {\cf20 // Part 1: take data from txt/csv file}\par
48     {\cf20 // Part 2: Convert data to can_msg format}\par
49     {\cf20 // Part 3: Send all four frames to sensors_mq    }\par
50     {\cf20 // Part 4: simple sleep timer;}\par
51 \par
52     FILE *file = (FILE*)arg; {\cf20 // Recebe o arquivo como argumento}\par
53 \par
54     {\cf19 while} (1) \{\par
55         {\cf20 // Read a new line from the file}\par
56         {\cf19 if} (read_sensor_data(file, &sensorsData)) \{\par
57             can_car_cluster     = conv2CANCarClusterData(sensorsData.on_off_aeb_system);\par
58             can_velocity_sensor = conv2CANVelocityData(sensorsData.reverseEnabled, sensorsData.vehicle_velocity);\par
59             can_obstacle_sensor = conv2CANObstacleData(sensorsData.has_obstacle, sensorsData.obstacle_distance);\par
60             can_pedals_sensor   = conv2CANPedalsData(sensorsData.brake_pedal, sensorsData.accelerator_pedal);\par
61 \par
62             write_mq(sensors_mq, &can_car_cluster);\par
63             write_mq(sensors_mq, &can_velocity_sensor);\par
64             write_mq(sensors_mq, &can_obstacle_sensor);\par
65             write_mq(sensors_mq, &can_pedals_sensor);\par
66 \par
67             {\cf20 // PlaceHolder: just some simple prints to see if the data is being converted in the right way}\par
68             {\cf20 //print_can_msg(&can_car_cluster);}\par
69             {\cf20 //print_can_msg(&can_velocity_sensor);}\par
70             {\cf20 //print_can_msg(&can_obstacle_sensor);}\par
71             {\cf20 //print_can_msg(&can_pedals_sensor);}\par
72         \par
73             printf({\cf22 "New line.\\n"}); {\cf20 //This line is used for see the break of line}\par
74         \} {\cf19 else} \{\par
75             {\cf20 // If a new line can't be read, the end of the file was reached}\par
76             printf({\cf22 "EOF reached.\\n"});\par
77             {\cf19 break};\par
78         \}\par
79 \par
80         sleep(1); {\cf20 // Wait for 1 second before reading the next line}\par
81     \}\par
82         \par
83     {\cf20 //printf("Placeholder\\n");}\par
84     fclose(file); {\cf20 // Closes the file at the end}\par
85     {\cf19 return} NULL;\par
86 \}\par
}
}
{\xe \v main\:sensors.c}
{\xe \v sensors.c\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main ()}}
\par
{\bkmkstart AAAAAAAAED}
{\bkmkend AAAAAAAAED}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 25 of file sensors.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 25           \{\par
26     {\cf18 int} sensors_thr;\par
27 \par
28     sensors_mq = create_mq(SENSORS_MQ);\par
29     {\cf20 // sensors_mq = open_mq(SENSORS_MQ);}\par
30 \par
31     {\cf17 const} {\cf18 char} *filename = {\cf22 "cts/cenario.txt"};\par
32     FILE *file = open_file(filename); {\cf20 // uses the modularized function to open the file}\par
33 \par
34     sensors_thr = pthread_create(&sensors_id, NULL, getSensorsData, file); {\cf20 //Changed the argument from null to file(the last argument)}\par
35     {\cf19 if}(sensors_thr != 0)\{\par
36         perror({\cf22 "Sensors: it wasn't possible to create the associated thread\\n"});\par
37         exit(52);\par
38     \}\par
39     sensors_thr = pthread_join(sensors_id, NULL);\par
40     \par
41     {\cf20 // close_mq(sensors_mq, SENSORS_MQ);}\par
42 \par
43     {\cf19 return} 0;\par
44 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v can_car_cluster\:sensors.c}
{\xe \v sensors.c\:can_car_cluster}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b can_msg} can_car_cluster}}
\par
{\bkmkstart AAAAAAAAEE}
{\bkmkend AAAAAAAAEE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 23 of file sensors.c.}\par
}
{\xe \v can_obstacle_sensor\:sensors.c}
{\xe \v sensors.c\:can_obstacle_sensor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b can_msg} can_obstacle_sensor}}
\par
{\bkmkstart AAAAAAAAEF}
{\bkmkend AAAAAAAAEF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 23 of file sensors.c.}\par
}
{\xe \v can_pedals_sensor\:sensors.c}
{\xe \v sensors.c\:can_pedals_sensor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b can_msg} can_pedals_sensor}}
\par
{\bkmkstart AAAAAAAAEG}
{\bkmkend AAAAAAAAEG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 23 of file sensors.c.}\par
}
{\xe \v can_velocity_sensor\:sensors.c}
{\xe \v sensors.c\:can_velocity_sensor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b can_msg} can_velocity_sensor}}
\par
{\bkmkstart AAAAAAAAEH}
{\bkmkend AAAAAAAAEH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 23 of file sensors.c.}\par
}
{\xe \v sensors_id\:sensors.c}
{\xe \v sensors.c\:sensors_id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
pthread_t sensors_id}}
\par
{\bkmkstart AAAAAAAAEI}
{\bkmkend AAAAAAAAEI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 20 of file sensors.c.}\par
}
{\xe \v sensors_mq\:sensors.c}
{\xe \v sensors.c\:sensors_mq}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
mqd_t sensors_mq}}
\par
{\bkmkstart AAAAAAAAEJ}
{\bkmkend AAAAAAAAEJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 19 of file sensors.c.}\par
}
{\xe \v sensorsData\:sensors.c}
{\xe \v sensors.c\:sensorsData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b sensors_input_data} sensorsData}}
\par
{\bkmkstart AAAAAAAAEK}
{\bkmkend AAAAAAAAEK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 21 of file sensors.c.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/ttc_control.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/ttc_control.c}
{\xe \v src/ttc_control.c}
{\bkmkstart AAAAAAAAEL}
{\bkmkend AAAAAAAAEL}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../inc/ttc_control.h"}\par
{\f2 #include "../inc/constants.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for ttc_control.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "ttc__control_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b accel_calc} (float spd)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calculate acceleration based on speed and time difference. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b ttc_calc} (float dis_rel, float spd_rel)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calculate the time to collision (TTC) based on relative distance and speed. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b aeb_control} (bool *enable_aeb, bool *alarm_cluster, bool *enable_breaking, bool *lk_seatbelt, bool *lk_doors, float *spd, float *dist)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Controls the Autonomous Emergency Braking (AEB) system. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v accel_calc\:ttc_control.c}
{\xe \v ttc_control.c\:accel_calc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float accel_calc (float  {\i spd})}}
\par
{\bkmkstart AAAAAAAAEM}
{\bkmkend AAAAAAAAEM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calculate acceleration based on speed and time difference. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function calculates the acceleration in m/s\'B2 based on the difference in speed and time. It uses the {\f2 clock_gettime}  function to measure the time difference between consecutive calls and calculates acceleration as the change in speed divided by the elapsed time [SwR-11].\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i spd} \cell }{Current speed in km/h.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The acceleration in m/s\'B2. If the function is called for the first time or there is insufficient time difference between calls, it returns 0.0. \par
}}}{
Definition at line 17 of file ttc_control.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17                             \{\par
18     {\cf17 static} {\cf18 float} prev_spd = 0.0;\par
19     {\cf17 static} {\cf17 struct }timespec start_time = \{0, 0\};\par
20     {\cf17 struct }timespec current_time;\par
21     {\cf18 double} elapsed_time;\par
22     {\cf18 float} accel = 0.0;\par
23 \par
24     clock_gettime(CLOCK_REALTIME, &current_time);\par
25 \par
26     {\cf19 if} (prev_spd == 0.0) \{\par
27         prev_spd = spd;\par
28         start_time = current_time;\par
29         {\cf19 return} 0.0;\par
30     \}\par
31 \par
32     {\cf19 else} \{\par
33         elapsed_time = (double)(current_time.tv_sec - start_time.tv_sec) \par
34                         + (double)(current_time.tv_nsec - start_time.tv_nsec) / 1e9;\par
35         {\cf19 if} (elapsed_time < 0.01) {\cf19 return} 0.0;\par
36         \par
37         accel = ((spd - prev_spd) / 3.6) / elapsed_time;\par
38         start_time = current_time;\par
39         prev_spd = spd;\par
40         \par
41         {\cf19 return} accel;\par
42     \} \par
43 \}\par
}
}
{\xe \v aeb_control\:ttc_control.c}
{\xe \v ttc_control.c\:aeb_control}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void aeb_control (bool *  {\i enable_aeb}, bool *  {\i alarm_cluster}, bool *  {\i enable_breaking}, bool *  {\i lk_seatbelt}, bool *  {\i lk_doors}, float *  {\i spd}, float *  {\i dist})}}
\par
{\bkmkstart AAAAAAAAEN}
{\bkmkend AAAAAAAAEN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Controls the Autonomous Emergency Braking (AEB) system. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function calculates the Time to Collision (TTC) based on the relative distance and speed of the vehicle. If the TTC is below a certain threshold, the AEB system triggers the alarm and may engage the braking system. It also prepares other safety features like seatbelt locking and door unlocking in critical conditions.\par
The decision is made based on predefined TTC thresholds:{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
If the TTC is below the {\f2 THRESHOLD_ALARM}  (e.g., 2 seconds), an alarm is triggered.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
If the TTC is below the {\f2 THRESHOLD_BRAKING}  (e.g., 1 second), the braking system is activated.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
If the TTC is less than half of the braking threshold, the braking system is prepared for a collision.\par}
The AEB system and the alarm are only triggered if the {\f2 enable_aeb}  flag is set to true.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i enable_aeb} \cell }{A pointer to a boolean flag that enables or disables the AEB system. [SwR-5] \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i alarm_cluster} \cell }{A pointer to a boolean flag that triggers the alarm in the cluster. [SwR-2] \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i enable_breaking} \cell }{A pointer to a boolean flag that enables or disables the braking system. [SwR-3] \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i lk_seatbelt} \cell }{A pointer to a boolean flag that locks the seatbelt in case of emergency. [Sys-F-14] \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i lk_doors} \cell }{A pointer to a boolean flag that locks or unlocks the doors in an emergency. [Sys-F-14] \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i spd} \cell }{A pointer to the current speed of the vehicle (in km/h). \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i dist} \cell }{A pointer to the current distance to the obstacle (in meters).\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The function complies with the requirements (SwR-2, SwR-3, SwR-5, SwR-11, SwR-14, SwR-15, Sys-F-8, Sys-F-9, Sys-F-14). \par
}}}{
Definition at line 107 of file ttc_control.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 108                                                                              \{\par
109     {\cf18 float} ttc;\par
110     \par
111     ttc = ttc_calc(*dist, *spd);\par
112     \par
113     {\cf19 if} ((*enable_aeb) && (ttc > 0.0) && (ttc < THRESHOLD_ALARM)) \{\par
114         *alarm_cluster = {\cf17 true};\par
115         \par
116         {\cf19 if} ((ttc < THRESHOLD_BRAKING) && (!*enable_breaking) && (*spd < MAX_SPD_ENABLED)\par
117             && (*spd > MIN_SPD_ENABLED)) \{\par
118             *enable_breaking = {\cf17 true};\par
119             {\cf19 if} (ttc < (THRESHOLD_BRAKING / 2.0)) \{\par
120                 *lk_seatbelt = {\cf17 true};  \par
121                 *lk_doors = {\cf17 false};    \par
122             \}\par
123         \}       \par
124     \} {\cf19 else} \{\par
125         *alarm_cluster = {\cf17 false};\par
126         *enable_breaking = {\cf17 false};\par
127     \}\par
128 \}\par
}
}
{\xe \v ttc_calc\:ttc_control.c}
{\xe \v ttc_control.c\:ttc_calc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float ttc_calc (float  {\i dis_rel}, float  {\i spd_rel})}}
\par
{\bkmkstart AAAAAAAAEO}
{\bkmkend AAAAAAAAEO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calculate the time to collision (TTC) based on relative distance and speed. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function calculates the time to collision using the Uniformly Variable Motion (UVM) model. It uses a quadratic equation to calculate the time to collision (TTC) between two objects based on their relative distance and speed. If the relative acceleration is zero, the function simply calculates the time by dividing the relative distance by the relative speed [SwR-1], [SwR-10], [SwR-11].\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i dis_rel} \cell }{The relative distance between the objects in meters. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i spd_rel} \cell }{The relative speed between the objects in km/h.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The time to collision in seconds. If no real solution is found (i.e., negative discriminant), the function returns -1.0. If there is no relative acceleration, the time to collision is calculated as distance divided by speed. \par
}}}{
Definition at line 60 of file ttc_control.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 60                                              \{\par
61     {\cf18 float} a, b, c, ttc, delta;\par
62     \par
63     a = accel_calc(spd_rel);\par
64     b = spd_rel / 3.6;\par
65     c = dis_rel;\par
66 \par
67     {\cf19 if} (a == 0) {\cf19 return} ttc = c / b;\par
68 \par
69     delta = b * b + 2 * a * c;\par
70     \par
71     {\cf19 if} (delta < 0) {\cf19 return} -1.0;\par
72 \par
73     {\cf19 else} {\cf19 if} (delta == 0) {\cf19 return} -b / a;\par
74 \par
75     {\cf19 else} \{\par
76         ttc = (-b + sqrt(delta)) / a;\par
77         {\cf19 return} ttc;\par
78     \}\par
79 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
test/test_mq_utils.c File Reference\par \pard\plain 
{\tc\tcl2 \v test/test_mq_utils.c}
{\xe \v test/test_mq_utils.c}
{\bkmkstart AAAAAAAAEP}
{\bkmkend AAAAAAAAEP}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <sys/stat.h>}\par
{\f2 #include "unity.h"}\par
{\f2 #include "mq_utils.h"}\par
{\f2 #include "constants.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for test_mq_utils.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "test__mq__utils_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setUp} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b tearDown} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b test_get_mq_attr} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b test_create_and_close_mq} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v main\:test_mq_utils.c}
{\xe \v test_mq_utils.c\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main ()}}
\par
{\bkmkstart AAAAAAAAEQ}
{\bkmkend AAAAAAAAEQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 44 of file test_mq_utils.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 45 \{\par
46     UNITY_BEGIN();\par
47     RUN_TEST(test_get_mq_attr);\par
48     RUN_TEST(test_create_and_close_mq);\par
49     {\cf19 return} UNITY_END();\par
50 \}\par
}
}
{\xe \v setUp\:test_mq_utils.c}
{\xe \v test_mq_utils.c\:setUp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setUp (void )}}
\par
{\bkmkstart AAAAAAAAER}
{\bkmkend AAAAAAAAER}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 6 of file test_mq_utils.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7 \{\par
8     {\cf20 // set stuff up here}\par
9 \}\par
}
}
{\xe \v tearDown\:test_mq_utils.c}
{\xe \v test_mq_utils.c\:tearDown}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void tearDown (void )}}
\par
{\bkmkstart AAAAAAAAES}
{\bkmkend AAAAAAAAES}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 11 of file test_mq_utils.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 12 \{\par
13     {\cf20 // clean stuff up here}\par
14 \}\par
}
}
{\xe \v test_create_and_close_mq\:test_mq_utils.c}
{\xe \v test_mq_utils.c\:test_create_and_close_mq}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void test_create_and_close_mq ()}}
\par
{\bkmkstart AAAAAAAAET}
{\bkmkend AAAAAAAAET}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 25 of file test_mq_utils.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 26 \{\par
27     {\cf18 char} *mq_name = {\cf22 "/test_mq"};\par
28     {\cf17 struct }stat buffer;\par
29 \par
30     {\cf18 int} exists = stat({\cf22 "/dev/mqueue/test_mq"}, &buffer);\par
31     TEST_ASSERT_EQUAL(-1, exists);\par
32 \par
33     mqd_t mqd = create_mq(mq_name);\par
34 \par
35     exists = stat({\cf22 "/dev/mqueue/test_mq"}, &buffer);\par
36     TEST_ASSERT_EQUAL(0, exists);\par
37     TEST_ASSERT_NOT_EQUAL((mqd_t)-1, mqd);\par
38 \par
39     close_mq(mqd, mq_name);\par
40     exists = stat({\cf22 "/dev/mqueue/test_mq"}, &buffer);\par
41     TEST_ASSERT_EQUAL(-1, exists);\par
42 \}\par
}
}
{\xe \v test_get_mq_attr\:test_mq_utils.c}
{\xe \v test_mq_utils.c\:test_get_mq_attr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void test_get_mq_attr ()}}
\par
{\bkmkstart AAAAAAAAEU}
{\bkmkend AAAAAAAAEU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 16 of file test_mq_utils.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17 \{\par
18     {\cf17 struct }mq_attr attr = get_mq_attr();\par
19     TEST_ASSERT_EQUAL(O_NONBLOCK, attr.mq_flags);\par
20     TEST_ASSERT_EQUAL(0, attr.mq_curmsgs);\par
21     TEST_ASSERT_EQUAL(MQ_MAX_MESSAGES, attr.mq_maxmsg);\par
22     TEST_ASSERT_EQUAL(MQ_MAX_MSG_SIZE, attr.mq_msgsize);\par
23 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
test/test_mq_utils_read.c File Reference\par \pard\plain 
{\tc\tcl2 \v test/test_mq_utils_read.c}
{\xe \v test/test_mq_utils_read.c}
{\bkmkstart AAAAAAAAEV}
{\bkmkend AAAAAAAAEV}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdio.h>}\par
{\f2 #include <sys/stat.h>}\par
{\f2 #include "unity.h"}\par
{\f2 #include "mq_utils.h"}\par
{\f2 #include "constants.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for test_mq_utils_read.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "test__mq__utils__read_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_VERBOSE_OUTPUT}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setUp} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b tearDown} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b test_open_mq} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b test_read_mq_empty_queue} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b test_write_mq_full_queue} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b test_read_and_write_mq_empty_can_msg} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b test_read_and_write_mq_valid_can_msg} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b mq_name} = {\b SENSORS_MQ}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
mqd_t {\b mqd}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v UNITY_VERBOSE_OUTPUT\:test_mq_utils_read.c}
{\xe \v test_mq_utils_read.c\:UNITY_VERBOSE_OUTPUT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_VERBOSE_OUTPUT}}
\par
{\bkmkstart AAAAAAAAEW}
{\bkmkend AAAAAAAAEW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 3 of file test_mq_utils_read.c.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v main\:test_mq_utils_read.c}
{\xe \v test_mq_utils_read.c\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main ()}}
\par
{\bkmkstart AAAAAAAAEX}
{\bkmkend AAAAAAAAEX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 73 of file test_mq_utils_read.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 74 \{\par
75     UNITY_BEGIN();\par
76     RUN_TEST(test_open_mq);\par
77     RUN_TEST(test_read_mq_empty_queue);\par
78     RUN_TEST(test_write_mq_full_queue);\par
79     RUN_TEST(test_read_and_write_mq_empty_can_msg);\par
80     RUN_TEST(test_read_and_write_mq_valid_can_msg);\par
81     {\cf19 return} UNITY_END();\par
82 \}\par
}
}
{\xe \v setUp\:test_mq_utils_read.c}
{\xe \v test_mq_utils_read.c\:setUp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setUp (void )}}
\par
{\bkmkstart AAAAAAAAEY}
{\bkmkend AAAAAAAAEY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 11 of file test_mq_utils_read.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 12 \{\par
13     mqd = create_mq(mq_name);\par
14 \}\par
}
}
{\xe \v tearDown\:test_mq_utils_read.c}
{\xe \v test_mq_utils_read.c\:tearDown}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void tearDown (void )}}
\par
{\bkmkstart AAAAAAAAEZ}
{\bkmkend AAAAAAAAEZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 16 of file test_mq_utils_read.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17 \{\par
18     close_mq(mqd, mq_name);\par
19 \}\par
}
}
{\xe \v test_open_mq\:test_mq_utils_read.c}
{\xe \v test_mq_utils_read.c\:test_open_mq}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void test_open_mq ()}}
\par
{\bkmkstart AAAAAAAAFA}
{\bkmkend AAAAAAAAFA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 21 of file test_mq_utils_read.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 22 \{\par
23     mqd_t mq_test = open_mq(mq_name);\par
24     TEST_ASSERT_NOT_EQUAL(-1, mq_test);\par
25 \}\par
}
}
{\xe \v test_read_and_write_mq_empty_can_msg\:test_mq_utils_read.c}
{\xe \v test_mq_utils_read.c\:test_read_and_write_mq_empty_can_msg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void test_read_and_write_mq_empty_can_msg ()}}
\par
{\bkmkstart AAAAAAAAFB}
{\bkmkend AAAAAAAAFB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 43 of file test_mq_utils_read.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 44 \{\par
45     mqd_t mq_write = open_mq(mq_name);\par
46     can_msg msg_to_write = \{0\};\par
47     write_mq(mq_write, &msg_to_write);\par
48 \par
49     can_msg msg_read;\par
50     read_mq(mqd, &msg_read);\par
51 \par
52     TEST_ASSERT_EQUAL(msg_to_write.identifier, msg_read.identifier);\par
53 \}\par
}
}
{\xe \v test_read_and_write_mq_valid_can_msg\:test_mq_utils_read.c}
{\xe \v test_mq_utils_read.c\:test_read_and_write_mq_valid_can_msg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void test_read_and_write_mq_valid_can_msg ()}}
\par
{\bkmkstart AAAAAAAAFC}
{\bkmkend AAAAAAAAFC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 55 of file test_mq_utils_read.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 56 \{\par
57     mqd_t mq_write = open_mq(mq_name);\par
58     can_msg msg_to_write = \{\par
59         .identifier = 12345,\par
60         .dataFrame = \{0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88\}\};\par
61     write_mq(mq_write, &msg_to_write);\par
62 \par
63     can_msg msg_read;\par
64     read_mq(mqd, &msg_read);\par
65 \par
66     TEST_ASSERT_EQUAL(msg_to_write.identifier, msg_read.identifier);\par
67     {\cf19 for} ({\cf18 int} i = 0; i < 8; i++)\par
68     \{\par
69         TEST_ASSERT_EQUAL(msg_to_write.dataFrame[i], msg_read.dataFrame[i]);\par
70     \}\par
71 \}\par
}
}
{\xe \v test_read_mq_empty_queue\:test_mq_utils_read.c}
{\xe \v test_mq_utils_read.c\:test_read_mq_empty_queue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void test_read_mq_empty_queue ()}}
\par
{\bkmkstart AAAAAAAAFD}
{\bkmkend AAAAAAAAFD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 27 of file test_mq_utils_read.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 28 \{\par
29     can_msg msg_read;\par
30     TEST_ASSERT_EQUAL(-1, read_mq(mqd, &msg_read));\par
31 \}\par
}
}
{\xe \v test_write_mq_full_queue\:test_mq_utils_read.c}
{\xe \v test_mq_utils_read.c\:test_write_mq_full_queue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void test_write_mq_full_queue ()}}
\par
{\bkmkstart AAAAAAAAFE}
{\bkmkend AAAAAAAAFE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 33 of file test_mq_utils_read.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 34 \{\par
35     can_msg msg_to_write = \{0\};\par
36     {\cf19 for} ({\cf18 int} i = 0; i < MQ_MAX_MESSAGES; i++)\par
37     \{\par
38         write_mq(mqd, &msg_to_write);\par
39     \}\par
40     TEST_ASSERT_EQUAL(-1, write_mq(mqd, &msg_to_write));\par
41 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v mq_name\:test_mq_utils_read.c}
{\xe \v test_mq_utils_read.c\:mq_name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* mq_name = {\b SENSORS_MQ}}}
\par
{\bkmkstart AAAAAAAAFF}
{\bkmkend AAAAAAAAFF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 8 of file test_mq_utils_read.c.}\par
}
{\xe \v mqd\:test_mq_utils_read.c}
{\xe \v test_mq_utils_read.c\:mqd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
mqd_t mqd}}
\par
{\bkmkstart AAAAAAAAFG}
{\bkmkend AAAAAAAAFG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9 of file test_mq_utils_read.c.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
test/test_ttc.c File Reference\par \pard\plain 
{\tc\tcl2 \v test/test_ttc.c}
{\xe \v test/test_ttc.c}
{\bkmkstart AAAAAAAAFH}
{\bkmkend AAAAAAAAFH}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../inc/ttc_control.h"}\par
{\f2 #include <stdio.h>}\par
{\f2 #include <unistd.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for test_ttc.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "test__ttc_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b test_accel_calc} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Test the accel_calc function. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b test_ttc_calc} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Test the ttc_calc function. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b test_aeb_control} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Test the behavior of the Autonomous Emergency Braking (AEB) control function. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v main\:test_ttc.c}
{\xe \v test_ttc.c\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main ()}}
\par
{\bkmkstart AAAAAAAAFI}
{\bkmkend AAAAAAAAFI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 145 of file test_ttc.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 145            \{\par
146     test_accel_calc();\par
147     test_ttc_calc();\par
148     test_aeb_control();\par
149 \par
150     {\cf19 return} 0;\par
151 \}\par
}
}
{\xe \v test_accel_calc\:test_ttc.c}
{\xe \v test_ttc.c\:test_accel_calc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void test_accel_calc ()}}
\par
{\bkmkstart AAAAAAAAFJ}
{\bkmkend AAAAAAAAFJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Test the accel_calc function. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function tests the {\f2 accel_calc}  function by simulating different speeds and calculating the acceleration between them. It prints the calculated acceleration in m/s\'B2 for various speed values at different time intervals.\par
It performs the following steps:{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Tests the acceleration calculation between two speeds (10 km/h and 20 km/h).\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Calls the {\f2 accel_calc}  function with different speeds and prints the results.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Waits 2 seconds between calls to simulate time intervals. \par}
}{
Definition at line 18 of file test_ttc.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18                        \{\par
19     printf({\cf22 "Testando fun\'E7\'E3o accel_calc\\n"});\par
20     {\cf18 float} speed1 = 10.0;  {\cf20 // 10 km/h}\par
21     {\cf18 float} speed2 = 20.0;  {\cf20 // 20 km/h}\par
22 \par
23     accel_calc(speed1);\par
24     sleep(2);\par
25     printf({\cf22 "Acelera\'E7\'E3o entre %0.1f km/h e %0.1f km/h: %0.4f m/s^2\\n"}, \par
26             speed1, speed2, accel_calc(speed2));\par
27     sleep(2);\par
28     printf({\cf22 "Acelera\'E7\'E3o entre %0.1f km/h e %0.1f km/h: %0.4f m/s^2\\n"}, \par
29             speed2, speed1, accel_calc(speed1));\par
30     printf({\cf22 "\\n"});\par
31 \}\par
}
}
{\xe \v test_aeb_control\:test_ttc.c}
{\xe \v test_ttc.c\:test_aeb_control}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void test_aeb_control ()}}
\par
{\bkmkstart AAAAAAAAFK}
{\bkmkend AAAAAAAAFK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Test the behavior of the Autonomous Emergency Braking (AEB) control function. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function tests the {\f2 aeb_control}  function with different values for vehicle speed (spd) and relative distance (dist) to simulate various scenarios of time-to-collision (TTC) and check whether the alarm and braking systems are triggered as expected. The function performs the following tests:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Test 1} : TTC > 2.0 seconds (expected result: no alarm, no braking)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Test 2} : 1.0 < TTC < 2.0 seconds (expected result: alarm triggered, no braking)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Test 3} : TTC < 1.0 second (expected result: alarm triggered, braking enabled)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Test 4} : AEB disabled, TTC < 1.0 second (expected result: no alarm, no braking)\par}
Each test prints the expected result and the actual outcome for the alarm and braking flags. \par
}{
Definition at line 87 of file test_ttc.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 87                         \{\par
88     {\cf20 // Input variables for the test}\par
89     {\cf18 bool} enable_aeb;\par
90     {\cf18 bool} alarm_cluster;\par
91     {\cf18 bool} enable_breaking;\par
92     {\cf18 bool} lk_seatbelt;\par
93     {\cf18 bool} lk_doors;\par
94     {\cf18 float} spd;\par
95     {\cf18 float} dist;\par
96     {\cf18 float} delta_spd;\par
97 \par
98     {\cf20 // Test 1: TTC > 2.0 (no alarm, no braking)}\par
99     enable_aeb = {\cf17 true};\par
100     spd = 30.0;  {\cf20 // 30 km/h}\par
101     dist = 50.0; {\cf20 // 50 meters}\par
102     aeb_control(&enable_aeb, &alarm_cluster, &enable_breaking, &lk_seatbelt, &lk_doors, &spd, &dist);\par
103     delta_spd = 0.001;\par
104     spd -= delta_spd;\par
105     printf({\cf22 "Velocidade: %.6f km/h\\n"}, spd);\par
106     aeb_control(&enable_aeb, &alarm_cluster, &enable_breaking, &lk_seatbelt, &lk_doors, &spd, &dist);\par
107     \par
108     {\cf20 // Check if the alarm and braking are not triggered}\par
109     printf({\cf22 "Test 1 - TTC > 2.0\\n"});\par
110     printf({\cf22 "Expected: No alarm, no braking\\n"});\par
111     printf({\cf22 "Alarm: %s, Braking: %s\\n"}, alarm_cluster ? {\cf22 "Triggered"} : {\cf22 "Not triggered"}, enable_breaking ? {\cf22 "Enabled"} : {\cf22 "Not enabled"});\par
112 \par
113     {\cf20 // Test 2: 1.0 < TTC < 2.0 (alarm triggered, no braking)}\par
114     dist = 12.5; {\cf20 // 12.5 meters}\par
115     spd += delta_spd; {\cf20 // 30.0 km/h}\par
116     aeb_control(&enable_aeb, &alarm_cluster, &enable_breaking, &lk_seatbelt, &lk_doors, &spd, &dist);\par
117 \par
118     {\cf20 // Check if the alarm was triggered, but braking was not}\par
119     printf({\cf22 "\\nTest 2 - 1.0 < TTC < 2.0\\n"});\par
120     printf({\cf22 "Expected: Alarm triggered, no braking\\n"});\par
121     printf({\cf22 "Alarm: %s, Braking: %s\\n"}, alarm_cluster ? {\cf22 "Triggered"} : {\cf22 "Not triggered"}, enable_breaking ? {\cf22 "Enabled"} : {\cf22 "Not enabled"});\par
122 \par
123     {\cf20 // Test 3: TTC < 1.0 (alarm and braking triggered)}\par
124     dist = 5.0; {\cf20 // 5 meters}\par
125     spd += (5*delta_spd); {\cf20 // 30.002 km/h}\par
126     aeb_control(&enable_aeb, &alarm_cluster, &enable_breaking, &lk_seatbelt, &lk_doors, &spd, &dist);\par
127 \par
128     {\cf20 // Check if the alarm and braking were both triggered}\par
129     printf({\cf22 "\\nTest 3 - TTC < 1.0\\n"});\par
130     printf({\cf22 "Expected: Alarm triggered, braking enabled\\n"});\par
131     printf({\cf22 "Alarm: %s, Braking: %s\\n"}, alarm_cluster ? {\cf22 "Triggered"} : {\cf22 "Not triggered"}, enable_breaking ? {\cf22 "Enabled"} : {\cf22 "Not enabled"});\par
132 \par
133     {\cf20 // Test 4: TTC < 1.0 with AEB disabled (no alarm, no braking)}\par
134     enable_aeb = {\cf17 false};\par
135     dist = 10.0; {\cf20 // 10 meters}\par
136     spd = 30.0;  {\cf20 // 30 km/h}\par
137     aeb_control(&enable_aeb, &alarm_cluster, &enable_breaking, &lk_seatbelt, &lk_doors, &spd, &dist);\par
138 \par
139     {\cf20 // Check if the alarm and braking were not triggered because AEB is disabled}\par
140     printf({\cf22 "\\nTest 4 - AEB Disabled\\n"});\par
141     printf({\cf22 "Expected: No alarm, no braking\\n"});\par
142     printf({\cf22 "Alarm: %s, Braking: %s\\n"}, alarm_cluster ? {\cf22 "Triggered"} : {\cf22 "Not triggered"}, enable_breaking ? {\cf22 "Enabled"} : {\cf22 "Not enabled"});\par
143 \}\par
}
}
{\xe \v test_ttc_calc\:test_ttc.c}
{\xe \v test_ttc.c\:test_ttc_calc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void test_ttc_calc ()}}
\par
{\bkmkstart AAAAAAAAFL}
{\bkmkend AAAAAAAAFL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Test the ttc_calc function. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function tests the {\f2 ttc_calc}  function by simulating different distances and speeds, and then calculates the time to collision (TTC). The function prints the calculated TTC values for different input parameters.\par
It performs the following steps:{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Tests the TTC with a 100-meter distance and a 20 km/h speed.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Tests TTC with different speeds (adding 30 km/h).\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Tests TTC with a 50-meter distance and a 10 km/h speed, and checks for negative results.\par}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
If the calculated TTC is negative, it indicates that there is no real solution for the given inputs (i.e., no real roots in the quadratic equation). \par
}}}{
Definition at line 48 of file test_ttc.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 48                      \{\par
49     printf({\cf22 "Testando fun\'E7\'E3o ttc_calc\\n"});\par
50 \par
51     {\cf20 // Testes com dist\'E2ncia e velocidade}\par
52     {\cf18 float} dist = 100.0;  {\cf20 // 100 metros}\par
53     {\cf18 float} speed = 20.0;  {\cf20 // 20 km/h}\par
54     {\cf18 float} ttc = ttc_calc(dist, speed);\par
55     sleep(2);\par
56     ttc = ttc_calc(dist, speed + 30.0);\par
57     printf({\cf22 "Tempo para colis\'E3o com dist\'E2ncia de %.1f metros e velocidade de %.1f km/h: %0.2f segundos\\n"}, dist, speed, ttc);\par
58 \par
59     {\cf20 // Teste com outra velocidade}\par
60     dist = 50.0;  {\cf20 // 50 metros}\par
61     speed = 10.0; {\cf20 // 10 km/h}\par
62     ttc = ttc_calc(dist, speed);\par
63     {\cf19 if} (ttc >= 0) \{\par
64         printf({\cf22 "Tempo para colis\'E3o com dist\'E2ncia de %.1f metros e velocidade de %.1f km/h: %0.2f segundos\\n"}, dist, speed, ttc);\par
65     \} {\cf19 else} \{\par
66         printf({\cf22 "N\'E3o h\'E1 solu\'E7\'E3o real para TTC com essas entradas\\n"});\par
67     \}\par
68 \par
69     printf({\cf22 "\\n\\n"});\par
70 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
test/unity.c File Reference\par \pard\plain 
{\tc\tcl2 \v test/unity.c}
{\xe \v test/unity.c}
{\bkmkstart AAAAAAAAFM}
{\bkmkend AAAAAAAAFM}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "unity.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for unity.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "unity_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_PROGMEM}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_FAIL_AND_BAIL}\~ do \{ Unity.CurrentTestFailed  = 1; {\b UNITY_OUTPUT_FLUSH}(); {\b TEST_ABORT}(); \} while (0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_IGNORE_AND_BAIL}\~ do \{ Unity.CurrentTestIgnored = 1; {\b UNITY_OUTPUT_FLUSH}(); {\b TEST_ABORT}(); \} while (0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b RETURN_IF_FAIL_OR_IGNORE}\~ do \{ if (Unity.CurrentTestFailed || Unity.CurrentTestIgnored) \{ {\b TEST_ABORT}(); \} \} while (0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UnityPrintPointlessAndBail}()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_FLOAT_OR_DOUBLE_WITHIN}(delta,  expected,  actual,  diff)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_NAN_CHECK}\~ {\b UNITY_IS_NAN}(expected) && {\b UNITY_IS_NAN}(actual)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_PRINT_EXPECTED_AND_ACTUAL_FLOAT}(expected,  actual)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UnityPrint} (const char *string)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UnityPrintLen} (const char *string, const {\b UNITY_UINT32} length)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UnityPrintNumberByStyle} (const {\b UNITY_INT} number, const {\b UNITY_DISPLAY_STYLE_T} style)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UnityPrintNumber} (const {\b UNITY_INT} number_to_print)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UnityPrintNumberUnsigned} (const {\b UNITY_UINT} number)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UnityPrintNumberHex} (const {\b UNITY_UINT} number, const char nibbles_to_print)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UnityPrintMask} (const {\b UNITY_UINT} mask, const {\b UNITY_UINT} number)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UnityPrintFloat} (const {\b UNITY_DOUBLE} input_number)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UnityConcludeTest} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UnityAssertBits} (const {\b UNITY_INT} mask, const {\b UNITY_INT} expected, const {\b UNITY_INT} actual, const char *msg, const {\b UNITY_LINE_TYPE} lineNumber)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UnityAssertEqualNumber} (const {\b UNITY_INT} expected, const {\b UNITY_INT} actual, const char *msg, const {\b UNITY_LINE_TYPE} lineNumber, const {\b UNITY_DISPLAY_STYLE_T} style)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UnityAssertGreaterOrLessOrEqualNumber} (const {\b UNITY_INT} threshold, const {\b UNITY_INT} actual, const {\b UNITY_COMPARISON_T} compare, const char *msg, const {\b UNITY_LINE_TYPE} lineNumber, const {\b UNITY_DISPLAY_STYLE_T} style)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UnityAssertEqualIntArray} ({\b UNITY_INTERNAL_PTR} expected, {\b UNITY_INTERNAL_PTR} actual, const {\b UNITY_UINT32} num_elements, const char *msg, const {\b UNITY_LINE_TYPE} lineNumber, const {\b UNITY_DISPLAY_STYLE_T} style, const {\b UNITY_FLAGS_T} flags)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UnityAssertWithinFloatArray} (const {\b UNITY_FLOAT} delta, {\b UNITY_PTR_ATTRIBUTE} const {\b UNITY_FLOAT} *expected, {\b UNITY_PTR_ATTRIBUTE} const {\b UNITY_FLOAT} *actual, const {\b UNITY_UINT32} num_elements, const char *msg, const {\b UNITY_LINE_TYPE} lineNumber, const {\b UNITY_FLAGS_T} flags)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UnityAssertFloatsWithin} (const {\b UNITY_FLOAT} delta, const {\b UNITY_FLOAT} expected, const {\b UNITY_FLOAT} actual, const char *msg, const {\b UNITY_LINE_TYPE} lineNumber)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UnityAssertFloatsNotWithin} (const {\b UNITY_FLOAT} delta, const {\b UNITY_FLOAT} expected, const {\b UNITY_FLOAT} actual, const char *msg, const {\b UNITY_LINE_TYPE} lineNumber)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UnityAssertGreaterOrLessFloat} (const {\b UNITY_FLOAT} threshold, const {\b UNITY_FLOAT} actual, const {\b UNITY_COMPARISON_T} compare, const char *msg, const {\b UNITY_LINE_TYPE} lineNumber)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UnityAssertFloatSpecial} (const {\b UNITY_FLOAT} actual, const char *msg, const {\b UNITY_LINE_TYPE} lineNumber, const {\b UNITY_FLOAT_TRAIT_T} style)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UnityAssertNumbersWithin} (const {\b UNITY_UINT} delta, const {\b UNITY_INT} expected, const {\b UNITY_INT} actual, const char *msg, const {\b UNITY_LINE_TYPE} lineNumber, const {\b UNITY_DISPLAY_STYLE_T} style)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UnityAssertNumbersArrayWithin} (const {\b UNITY_UINT} delta, {\b UNITY_INTERNAL_PTR} expected, {\b UNITY_INTERNAL_PTR} actual, const {\b UNITY_UINT32} num_elements, const char *msg, const {\b UNITY_LINE_TYPE} lineNumber, const {\b UNITY_DISPLAY_STYLE_T} style, const {\b UNITY_FLAGS_T} flags)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UnityAssertEqualString} (const char *expected, const char *actual, const char *msg, const {\b UNITY_LINE_TYPE} lineNumber)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UnityAssertEqualStringLen} (const char *expected, const char *actual, const {\b UNITY_UINT32} length, const char *msg, const {\b UNITY_LINE_TYPE} lineNumber)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UnityAssertEqualStringArray} ({\b UNITY_INTERNAL_PTR} expected, const char **actual, const {\b UNITY_UINT32} num_elements, const char *msg, const {\b UNITY_LINE_TYPE} lineNumber, const {\b UNITY_FLAGS_T} flags)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UnityAssertEqualMemory} ({\b UNITY_INTERNAL_PTR} expected, {\b UNITY_INTERNAL_PTR} actual, const {\b UNITY_UINT32} length, const {\b UNITY_UINT32} num_elements, const char *msg, const {\b UNITY_LINE_TYPE} lineNumber, const {\b UNITY_FLAGS_T} flags)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UNITY_INTERNAL_PTR} {\b UnityNumToPtr} (const {\b UNITY_INT} num, const {\b UNITY_UINT8} size)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UNITY_INTERNAL_PTR} {\b UnityFloatToPtr} (const float num)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UnityFail} (const char *msg, const {\b UNITY_LINE_TYPE} line)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UnityIgnore} (const char *msg, const {\b UNITY_LINE_TYPE} line)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UnityMessage} (const char *msg, const {\b UNITY_LINE_TYPE} line)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UnityDefaultTestRun} ({\b UnityTestFunction} Func, const char *FuncName, const int FuncLineNum)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UnitySetTestFile} (const char *filename)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UnityBegin} (const char *filename)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b UnityEnd} (void)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b UNITY_STORAGE_T} {\b Unity}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b UNITY_PROGMEM} {\b UnityStrOk} [] = "OK"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b UNITY_PROGMEM} {\b UnityStrPass} [] = "PASS"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b UNITY_PROGMEM} {\b UnityStrFail} [] = "FAIL"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b UNITY_PROGMEM} {\b UnityStrIgnore} [] = "IGNORE"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b UNITY_PROGMEM} {\b UnityStrErrShorthand} [] = "Unity Shorthand Support Disabled"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b UNITY_PROGMEM} {\b UnityStrErrFloat} [] = "Unity Floating Point Disabled"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b UNITY_PROGMEM} {\b UnityStrErrDouble} [] = "Unity Double Precision Disabled"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b UNITY_PROGMEM} {\b UnityStrErr64} [] = "Unity 64-bit Support Disabled"\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v RETURN_IF_FAIL_OR_IGNORE\:unity.c}
{\xe \v unity.c\:RETURN_IF_FAIL_OR_IGNORE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define RETURN_IF_FAIL_OR_IGNORE\~ do \{ if (Unity.CurrentTestFailed || Unity.CurrentTestIgnored) \{ {\b TEST_ABORT}(); \} \} while (0)}}
\par
{\bkmkstart AAAAAAAAFN}
{\bkmkend AAAAAAAAFN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 22 of file unity.c.}\par
}
{\xe \v UNITY_FAIL_AND_BAIL\:unity.c}
{\xe \v unity.c\:UNITY_FAIL_AND_BAIL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_FAIL_AND_BAIL\~ do \{ Unity.CurrentTestFailed  = 1; {\b UNITY_OUTPUT_FLUSH}(); {\b TEST_ABORT}(); \} while (0)}}
\par
{\bkmkstart AAAAAAAAFO}
{\bkmkend AAAAAAAAFO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 20 of file unity.c.}\par
}
{\xe \v UNITY_FLOAT_OR_DOUBLE_WITHIN\:unity.c}
{\xe \v unity.c\:UNITY_FLOAT_OR_DOUBLE_WITHIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_FLOAT_OR_DOUBLE_WITHIN( delta,  expected,  actual,  diff)}}
\par
{\bkmkstart AAAAAAAAFP}
{\bkmkend AAAAAAAAFP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     {\cf19 if} (UNITY_IS_INF(expected) && UNITY_IS_INF(actual) && (((expected) < 0) == ((actual) < 0))) {\cf19 return} 1;   \\\par
    if (UNITY_NAN_CHECK) {\cf19 return} 1;                                                            \\\par
    (diff) = (actual) - (expected);                                                           \\\par
    if ((diff) < 0) (diff) = -(diff);                                                         \\\par
    if ((delta) < 0) (delta) = -(delta);                                                      \\\par
    return !(UNITY_IS_NAN(diff) || UNITY_IS_INF(diff) || ((diff) > (delta)))\par
}
{
Definition at line 898 of file unity.c.}\par
}
{\xe \v UNITY_IGNORE_AND_BAIL\:unity.c}
{\xe \v unity.c\:UNITY_IGNORE_AND_BAIL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_IGNORE_AND_BAIL\~ do \{ Unity.CurrentTestIgnored = 1; {\b UNITY_OUTPUT_FLUSH}(); {\b TEST_ABORT}(); \} while (0)}}
\par
{\bkmkstart AAAAAAAAFQ}
{\bkmkend AAAAAAAAFQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 21 of file unity.c.}\par
}
{\xe \v UNITY_NAN_CHECK\:unity.c}
{\xe \v unity.c\:UNITY_NAN_CHECK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_NAN_CHECK\~ {\b UNITY_IS_NAN}(expected) && {\b UNITY_IS_NAN}(actual)}}
\par
{\bkmkstart AAAAAAAAFR}
{\bkmkend AAAAAAAAFR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 907 of file unity.c.}\par
}
{\xe \v UNITY_PRINT_EXPECTED_AND_ACTUAL_FLOAT\:unity.c}
{\xe \v unity.c\:UNITY_PRINT_EXPECTED_AND_ACTUAL_FLOAT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_PRINT_EXPECTED_AND_ACTUAL_FLOAT( expected,  actual)}}
\par
{\bkmkstart AAAAAAAAFS}
{\bkmkend AAAAAAAAFS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   {\cf19 do} \{                                                            \\\par
    UnityPrint(UnityStrExpected);                                 \\\par
    UnityPrintFloat(expected);                                    \\\par
    UnityPrint(UnityStrWas);                                      \\\par
    UnityPrintFloat(actual);                                      \\\par
  \} {\cf19 while} (0)\par
}
{
Definition at line 913 of file unity.c.}\par
}
{\xe \v UNITY_PROGMEM\:unity.c}
{\xe \v unity.c\:UNITY_PROGMEM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_PROGMEM}}
\par
{\bkmkstart AAAAAAAAFT}
{\bkmkend AAAAAAAAFT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 11 of file unity.c.}\par
}
{\xe \v UnityPrintPointlessAndBail\:unity.c}
{\xe \v unity.c\:UnityPrintPointlessAndBail}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UnityPrintPointlessAndBail()}}
\par
{\bkmkstart AAAAAAAAFU}
{\bkmkend AAAAAAAAFU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\cf19 do} \{                                       \\\par
    UnityTestResultsFailBegin(lineNumber); \\\par
    UnityPrint(UnityStrPointless);         \\\par
    UnityAddMsgIfSpecified(msg);           \\\par
    UNITY_FAIL_AND_BAIL;                   \\\par
\} {\cf19 while} (0)\par
}
{
Definition at line 772 of file unity.c.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v UnityAssertBits\:unity.c}
{\xe \v unity.c\:UnityAssertBits}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void UnityAssertBits (const {\b UNITY_INT}  {\i mask}, const {\b UNITY_INT}  {\i expected}, const {\b UNITY_INT}  {\i actual}, const char *  {\i msg}, const {\b UNITY_LINE_TYPE}  {\i lineNumber})}}
\par
{\bkmkstart AAAAAAAAFV}
{\bkmkend AAAAAAAAFV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 691 of file unity.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 696 \{\par
697     RETURN_IF_FAIL_OR_IGNORE;\par
698 \par
699     {\cf19 if} ((mask & expected) != (mask & actual))\par
700     \{\par
701         UnityTestResultsFailBegin(lineNumber);\par
702         UnityPrint(UnityStrExpected);\par
703         UnityPrintMask((UNITY_UINT)mask, (UNITY_UINT)expected);\par
704         UnityPrint(UnityStrWas);\par
705         UnityPrintMask((UNITY_UINT)mask, (UNITY_UINT)actual);\par
706         UnityAddMsgIfSpecified(msg);\par
707         UNITY_FAIL_AND_BAIL;\par
708     \}\par
709 \}\par
}
}
{\xe \v UnityAssertEqualIntArray\:unity.c}
{\xe \v unity.c\:UnityAssertEqualIntArray}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void UnityAssertEqualIntArray ({\b UNITY_INTERNAL_PTR}  {\i expected}, {\b UNITY_INTERNAL_PTR}  {\i actual}, const {\b UNITY_UINT32}  {\i num_elements}, const char *  {\i msg}, const {\b UNITY_LINE_TYPE}  {\i lineNumber}, const {\b UNITY_DISPLAY_STYLE_T}  {\i style}, const {\b UNITY_FLAGS_T}  {\i flags})}}
\par
{\bkmkstart AAAAAAAAFW}
{\bkmkend AAAAAAAAFW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 781 of file unity.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 788 \{\par
789     UNITY_UINT32 elements  = num_elements;\par
790     {\cf18 unsigned} {\cf18 int} length    = style & 0xF;\par
791     {\cf18 unsigned} {\cf18 int} increment = 0;\par
792 \par
793     RETURN_IF_FAIL_OR_IGNORE;\par
794 \par
795     {\cf19 if} (num_elements == 0)\par
796     \{\par
797 {\cf21 #ifdef UNITY_COMPARE_PTRS_ON_ZERO_ARRAY}\par
798         UNITY_TEST_ASSERT_EQUAL_PTR(expected, actual, lineNumber, msg);\par
799 {\cf21 #else}\par
800         UnityPrintPointlessAndBail();\par
801 {\cf21 #endif}\par
802     \}\par
803 \par
804     {\cf19 if} (expected == actual)\par
805     \{\par
806         {\cf19 return}; {\cf20 /* Both are NULL or same pointer */}\par
807     \}\par
808 \par
809     {\cf19 if} (UnityIsOneArrayNull(expected, actual, lineNumber, msg))\par
810     \{\par
811         UNITY_FAIL_AND_BAIL;\par
812     \}\par
813 \par
814     {\cf19 while} ((elements > 0) && (elements--))\par
815     \{\par
816         UNITY_INT expect_val;\par
817         UNITY_INT actual_val;\par
818 \par
819         {\cf19 switch} (length)\par
820         \{\par
821             {\cf19 case} 1:\par
822                 expect_val = *(UNITY_PTR_ATTRIBUTE {\cf17 const} UNITY_INT8*)expected;\par
823                 actual_val = *(UNITY_PTR_ATTRIBUTE {\cf17 const} UNITY_INT8*)actual;\par
824                 {\cf19 if} (style & (UNITY_DISPLAY_RANGE_UINT | UNITY_DISPLAY_RANGE_HEX))\par
825                 \{\par
826                     expect_val &= 0x000000FF;\par
827                     actual_val &= 0x000000FF;\par
828                 \}\par
829                 increment  = {\cf17 sizeof}(UNITY_INT8);\par
830                 {\cf19 break};\par
831 \par
832             {\cf19 case} 2:\par
833                 expect_val = *(UNITY_PTR_ATTRIBUTE {\cf17 const} UNITY_INT16*)expected;\par
834                 actual_val = *(UNITY_PTR_ATTRIBUTE {\cf17 const} UNITY_INT16*)actual;\par
835                 {\cf19 if} (style & (UNITY_DISPLAY_RANGE_UINT | UNITY_DISPLAY_RANGE_HEX))\par
836                 \{\par
837                     expect_val &= 0x0000FFFF;\par
838                     actual_val &= 0x0000FFFF;\par
839                 \}\par
840                 increment  = {\cf17 sizeof}(UNITY_INT16);\par
841                 {\cf19 break};\par
842 \par
843 {\cf21 #ifdef UNITY_SUPPORT_64}\par
844             {\cf19 case} 8:\par
845                 expect_val = *(UNITY_PTR_ATTRIBUTE {\cf17 const} UNITY_INT64*)expected;\par
846                 actual_val = *(UNITY_PTR_ATTRIBUTE {\cf17 const} UNITY_INT64*)actual;\par
847                 increment  = {\cf17 sizeof}(UNITY_INT64);\par
848                 {\cf19 break};\par
849 {\cf21 #endif}\par
850 \par
851             {\cf19 default}: {\cf20 /* default is length 4 bytes */}\par
852             {\cf19 case} 4:\par
853                 expect_val = *(UNITY_PTR_ATTRIBUTE {\cf17 const} UNITY_INT32*)expected;\par
854                 actual_val = *(UNITY_PTR_ATTRIBUTE {\cf17 const} UNITY_INT32*)actual;\par
855 {\cf21 #ifdef UNITY_SUPPORT_64}\par
856                 {\cf19 if} (style & (UNITY_DISPLAY_RANGE_UINT | UNITY_DISPLAY_RANGE_HEX))\par
857                 \{\par
858                     expect_val &= 0x00000000FFFFFFFF;\par
859                     actual_val &= 0x00000000FFFFFFFF;\par
860                 \}\par
861 {\cf21 #endif}\par
862                 increment  = {\cf17 sizeof}(UNITY_INT32);\par
863                 length = 4;\par
864                 {\cf19 break};\par
865         \}\par
866 \par
867         {\cf19 if} (expect_val != actual_val)\par
868         \{\par
869             {\cf19 if} ((style & UNITY_DISPLAY_RANGE_UINT) && (length < (UNITY_INT_WIDTH / 8)))\par
870             \{   {\cf20 /* For UINT, remove sign extension (padding 1's) from signed type casts above */}\par
871                 UNITY_INT mask = 1;\par
872                 mask = (mask << 8 * length) - 1;\par
873                 expect_val &= mask;\par
874                 actual_val &= mask;\par
875             \}\par
876             UnityTestResultsFailBegin(lineNumber);\par
877             UnityPrint(UnityStrElement);\par
878             UnityPrintNumberUnsigned(num_elements - elements - 1);\par
879             UnityPrint(UnityStrExpected);\par
880             UnityPrintNumberByStyle(expect_val, style);\par
881             UnityPrint(UnityStrWas);\par
882             UnityPrintNumberByStyle(actual_val, style);\par
883             UnityAddMsgIfSpecified(msg);\par
884             UNITY_FAIL_AND_BAIL;\par
885         \}\par
886         {\cf20 /* Walk through array by incrementing the pointers */}\par
887         {\cf19 if} (flags == UNITY_ARRAY_TO_ARRAY)\par
888         \{\par
889             expected = (UNITY_INTERNAL_PTR)(({\cf17 const} {\cf18 char}*)expected + increment);\par
890         \}\par
891         actual = (UNITY_INTERNAL_PTR)(({\cf17 const} {\cf18 char}*)actual + increment);\par
892     \}\par
893 \}\par
}
}
{\xe \v UnityAssertEqualMemory\:unity.c}
{\xe \v unity.c\:UnityAssertEqualMemory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void UnityAssertEqualMemory ({\b UNITY_INTERNAL_PTR}  {\i expected}, {\b UNITY_INTERNAL_PTR}  {\i actual}, const {\b UNITY_UINT32}  {\i length}, const {\b UNITY_UINT32}  {\i num_elements}, const char *  {\i msg}, const {\b UNITY_LINE_TYPE}  {\i lineNumber}, const {\b UNITY_FLAGS_T}  {\i flags})}}
\par
{\bkmkstart AAAAAAAAFX}
{\bkmkend AAAAAAAAFX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1753 of file unity.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1760 \{\par
1761     UNITY_PTR_ATTRIBUTE {\cf17 const} {\cf18 unsigned} {\cf18 char}* ptr_exp = (UNITY_PTR_ATTRIBUTE {\cf17 const} {\cf18 unsigned} {\cf18 char}*)expected;\par
1762     UNITY_PTR_ATTRIBUTE {\cf17 const} {\cf18 unsigned} {\cf18 char}* ptr_act = (UNITY_PTR_ATTRIBUTE {\cf17 const} {\cf18 unsigned} {\cf18 char}*)actual;\par
1763     UNITY_UINT32 elements = num_elements;\par
1764     UNITY_UINT32 bytes;\par
1765 \par
1766     RETURN_IF_FAIL_OR_IGNORE;\par
1767 \par
1768     {\cf19 if} (elements == 0)\par
1769     \{\par
1770 {\cf21 #ifdef UNITY_COMPARE_PTRS_ON_ZERO_ARRAY}\par
1771         UNITY_TEST_ASSERT_EQUAL_PTR(expected, actual, lineNumber, msg);\par
1772 {\cf21 #else}\par
1773         UnityPrintPointlessAndBail();\par
1774 {\cf21 #endif}\par
1775     \}\par
1776     {\cf19 if} (length == 0)\par
1777     \{\par
1778         UnityPrintPointlessAndBail();\par
1779     \}\par
1780 \par
1781     {\cf19 if} (expected == actual)\par
1782     \{\par
1783         {\cf19 return}; {\cf20 /* Both are NULL or same pointer */}\par
1784     \}\par
1785 \par
1786     {\cf19 if} (UnityIsOneArrayNull(expected, actual, lineNumber, msg))\par
1787     \{\par
1788         UNITY_FAIL_AND_BAIL;\par
1789     \}\par
1790 \par
1791     {\cf19 while} (elements--)\par
1792     \{\par
1793         bytes = length;\par
1794         {\cf19 while} (bytes--)\par
1795         \{\par
1796             {\cf19 if} (*ptr_exp != *ptr_act)\par
1797             \{\par
1798                 UnityTestResultsFailBegin(lineNumber);\par
1799                 UnityPrint(UnityStrMemory);\par
1800                 {\cf19 if} (num_elements > 1)\par
1801                 \{\par
1802                     UnityPrint(UnityStrElement);\par
1803                     UnityPrintNumberUnsigned(num_elements - elements - 1);\par
1804                 \}\par
1805                 UnityPrint(UnityStrByte);\par
1806                 UnityPrintNumberUnsigned(length - bytes - 1);\par
1807                 UnityPrint(UnityStrExpected);\par
1808                 UnityPrintNumberByStyle(*ptr_exp, UNITY_DISPLAY_STYLE_HEX8);\par
1809                 UnityPrint(UnityStrWas);\par
1810                 UnityPrintNumberByStyle(*ptr_act, UNITY_DISPLAY_STYLE_HEX8);\par
1811                 UnityAddMsgIfSpecified(msg);\par
1812                 UNITY_FAIL_AND_BAIL;\par
1813             \}\par
1814             ptr_exp++;\par
1815             ptr_act++;\par
1816         \}\par
1817         {\cf19 if} (flags == UNITY_ARRAY_TO_VAL)\par
1818         \{\par
1819             ptr_exp = (UNITY_PTR_ATTRIBUTE {\cf17 const} {\cf18 unsigned} {\cf18 char}*)expected;\par
1820         \}\par
1821     \}\par
1822 \}\par
}
}
{\xe \v UnityAssertEqualNumber\:unity.c}
{\xe \v unity.c\:UnityAssertEqualNumber}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void UnityAssertEqualNumber (const {\b UNITY_INT}  {\i expected}, const {\b UNITY_INT}  {\i actual}, const char *  {\i msg}, const {\b UNITY_LINE_TYPE}  {\i lineNumber}, const {\b UNITY_DISPLAY_STYLE_T}  {\i style})}}
\par
{\bkmkstart AAAAAAAAFY}
{\bkmkend AAAAAAAAFY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 712 of file unity.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 717 \{\par
718     RETURN_IF_FAIL_OR_IGNORE;\par
719 \par
720     {\cf19 if} (expected != actual)\par
721     \{\par
722         UnityTestResultsFailBegin(lineNumber);\par
723         UnityPrint(UnityStrExpected);\par
724         UnityPrintNumberByStyle(expected, style);\par
725         UnityPrint(UnityStrWas);\par
726         UnityPrintNumberByStyle(actual, style);\par
727         UnityAddMsgIfSpecified(msg);\par
728         UNITY_FAIL_AND_BAIL;\par
729     \}\par
730 \}\par
}
}
{\xe \v UnityAssertEqualString\:unity.c}
{\xe \v unity.c\:UnityAssertEqualString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void UnityAssertEqualString (const char *  {\i expected}, const char *  {\i actual}, const char *  {\i msg}, const {\b UNITY_LINE_TYPE}  {\i lineNumber})}}
\par
{\bkmkstart AAAAAAAAFZ}
{\bkmkend AAAAAAAAFZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1591 of file unity.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1595 \{\par
1596     UNITY_UINT32 i;\par
1597 \par
1598     RETURN_IF_FAIL_OR_IGNORE;\par
1599 \par
1600     {\cf20 /* if both pointers not null compare the strings */}\par
1601     {\cf19 if} (expected && actual)\par
1602     \{\par
1603         {\cf19 for} (i = 0; expected[i] || actual[i]; i++)\par
1604         \{\par
1605             {\cf19 if} (expected[i] != actual[i])\par
1606             \{\par
1607                 Unity.CurrentTestFailed = 1;\par
1608                 {\cf19 break};\par
1609             \}\par
1610         \}\par
1611     \}\par
1612     {\cf19 else}\par
1613     \{ {\cf20 /* fail if either null but not if both */}\par
1614         {\cf19 if} (expected || actual)\par
1615         \{\par
1616             Unity.CurrentTestFailed = 1;\par
1617         \}\par
1618     \}\par
1619 \par
1620     {\cf19 if} (Unity.CurrentTestFailed)\par
1621     \{\par
1622         UnityTestResultsFailBegin(lineNumber);\par
1623         UnityPrintExpectedAndActualStrings(expected, actual);\par
1624         UnityAddMsgIfSpecified(msg);\par
1625         UNITY_FAIL_AND_BAIL;\par
1626     \}\par
1627 \}\par
}
}
{\xe \v UnityAssertEqualStringArray\:unity.c}
{\xe \v unity.c\:UnityAssertEqualStringArray}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void UnityAssertEqualStringArray ({\b UNITY_INTERNAL_PTR}  {\i expected}, const char **  {\i actual}, const {\b UNITY_UINT32}  {\i num_elements}, const char *  {\i msg}, const {\b UNITY_LINE_TYPE}  {\i lineNumber}, const {\b UNITY_FLAGS_T}  {\i flags})}}
\par
{\bkmkstart AAAAAAAAGA}
{\bkmkend AAAAAAAAGA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1670 of file unity.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1676 \{\par
1677     UNITY_UINT32 i = 0;\par
1678     UNITY_UINT32 j = 0;\par
1679     {\cf17 const} {\cf18 char}* expd = NULL;\par
1680     {\cf17 const} {\cf18 char}* act = NULL;\par
1681 \par
1682     RETURN_IF_FAIL_OR_IGNORE;\par
1683 \par
1684     {\cf20 /* if no elements, it's an error */}\par
1685     {\cf19 if} (num_elements == 0)\par
1686     \{\par
1687 {\cf21 #ifdef UNITY_COMPARE_PTRS_ON_ZERO_ARRAY}\par
1688         UNITY_TEST_ASSERT_EQUAL_PTR(expected, actual, lineNumber, msg);\par
1689 {\cf21 #else}\par
1690         UnityPrintPointlessAndBail();\par
1691 {\cf21 #endif}\par
1692     \}\par
1693 \par
1694     {\cf19 if} (({\cf17 const} {\cf18 void}*)expected == ({\cf17 const} {\cf18 void}*)actual)\par
1695     \{\par
1696         {\cf19 return}; {\cf20 /* Both are NULL or same pointer */}\par
1697     \}\par
1698 \par
1699     {\cf19 if} (UnityIsOneArrayNull((UNITY_INTERNAL_PTR)expected, (UNITY_INTERNAL_PTR)actual, lineNumber, msg))\par
1700     \{\par
1701         UNITY_FAIL_AND_BAIL;\par
1702     \}\par
1703 \par
1704     {\cf19 if} (flags != UNITY_ARRAY_TO_ARRAY)\par
1705     \{\par
1706         expd = ({\cf17 const} {\cf18 char}*)expected;\par
1707     \}\par
1708 \par
1709     {\cf19 do}\par
1710     \{\par
1711         act = actual[j];\par
1712         {\cf19 if} (flags == UNITY_ARRAY_TO_ARRAY)\par
1713         \{\par
1714             expd = (({\cf17 const} {\cf18 char}* {\cf17 const}*)expected)[j];\par
1715         \}\par
1716 \par
1717         {\cf20 /* if both pointers not null compare the strings */}\par
1718         {\cf19 if} (expd && act)\par
1719         \{\par
1720             {\cf19 for} (i = 0; expd[i] || act[i]; i++)\par
1721             \{\par
1722                 {\cf19 if} (expd[i] != act[i])\par
1723                 \{\par
1724                     Unity.CurrentTestFailed = 1;\par
1725                     {\cf19 break};\par
1726                 \}\par
1727             \}\par
1728         \}\par
1729         {\cf19 else}\par
1730         \{ {\cf20 /* handle case of one pointers being null (if both null, test should pass) */}\par
1731             {\cf19 if} (expd != act)\par
1732             \{\par
1733                 Unity.CurrentTestFailed = 1;\par
1734             \}\par
1735         \}\par
1736 \par
1737         {\cf19 if} (Unity.CurrentTestFailed)\par
1738         \{\par
1739             UnityTestResultsFailBegin(lineNumber);\par
1740             {\cf19 if} (num_elements > 1)\par
1741             \{\par
1742                 UnityPrint(UnityStrElement);\par
1743                 UnityPrintNumberUnsigned(j);\par
1744             \}\par
1745             UnityPrintExpectedAndActualStrings(expd, act);\par
1746             UnityAddMsgIfSpecified(msg);\par
1747             UNITY_FAIL_AND_BAIL;\par
1748         \}\par
1749     \} {\cf19 while} (++j < num_elements);\par
1750 \}\par
}
}
{\xe \v UnityAssertEqualStringLen\:unity.c}
{\xe \v unity.c\:UnityAssertEqualStringLen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void UnityAssertEqualStringLen (const char *  {\i expected}, const char *  {\i actual}, const {\b UNITY_UINT32}  {\i length}, const char *  {\i msg}, const {\b UNITY_LINE_TYPE}  {\i lineNumber})}}
\par
{\bkmkstart AAAAAAAAGB}
{\bkmkend AAAAAAAAGB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1630 of file unity.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1635 \{\par
1636     UNITY_UINT32 i;\par
1637 \par
1638     RETURN_IF_FAIL_OR_IGNORE;\par
1639 \par
1640     {\cf20 /* if both pointers not null compare the strings */}\par
1641     {\cf19 if} (expected && actual)\par
1642     \{\par
1643         {\cf19 for} (i = 0; (i < length) && (expected[i] || actual[i]); i++)\par
1644         \{\par
1645             {\cf19 if} (expected[i] != actual[i])\par
1646             \{\par
1647                 Unity.CurrentTestFailed = 1;\par
1648                 {\cf19 break};\par
1649             \}\par
1650         \}\par
1651     \}\par
1652     {\cf19 else}\par
1653     \{ {\cf20 /* fail if either null but not if both */}\par
1654         {\cf19 if} (expected || actual)\par
1655         \{\par
1656             Unity.CurrentTestFailed = 1;\par
1657         \}\par
1658     \}\par
1659 \par
1660     {\cf19 if} (Unity.CurrentTestFailed)\par
1661     \{\par
1662         UnityTestResultsFailBegin(lineNumber);\par
1663         UnityPrintExpectedAndActualStringsLen(expected, actual, length);\par
1664         UnityAddMsgIfSpecified(msg);\par
1665         UNITY_FAIL_AND_BAIL;\par
1666     \}\par
1667 \}\par
}
}
{\xe \v UnityAssertFloatsNotWithin\:unity.c}
{\xe \v unity.c\:UnityAssertFloatsNotWithin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void UnityAssertFloatsNotWithin (const {\b UNITY_FLOAT}  {\i delta}, const {\b UNITY_FLOAT}  {\i expected}, const {\b UNITY_FLOAT}  {\i actual}, const char *  {\i msg}, const {\b UNITY_LINE_TYPE}  {\i lineNumber})}}
\par
{\bkmkstart AAAAAAAAGC}
{\bkmkend AAAAAAAAGC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1032 of file unity.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1037 \{\par
1038     RETURN_IF_FAIL_OR_IGNORE;\par
1039 \par
1040     {\cf19 if} (UnityFloatsWithin(delta, expected, actual))\par
1041     \{\par
1042         UnityTestResultsFailBegin(lineNumber);\par
1043         UnityPrint(UnityStrExpected);\par
1044         UnityPrintFloat((UNITY_DOUBLE)expected);\par
1045         UnityPrint(UnityStrNotEqual);\par
1046         UnityPrintFloat((UNITY_DOUBLE)actual);\par
1047         UnityAddMsgIfSpecified(msg);\par
1048         UNITY_FAIL_AND_BAIL;\par
1049     \}\par
1050 \}\par
}
}
{\xe \v UnityAssertFloatSpecial\:unity.c}
{\xe \v unity.c\:UnityAssertFloatSpecial}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void UnityAssertFloatSpecial (const {\b UNITY_FLOAT}  {\i actual}, const char *  {\i msg}, const {\b UNITY_LINE_TYPE}  {\i lineNumber}, const {\b UNITY_FLOAT_TRAIT_T}  {\i style})}}
\par
{\bkmkstart AAAAAAAAGD}
{\bkmkend AAAAAAAAGD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1086 of file unity.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1090 \{\par
1091     {\cf17 const} {\cf18 char}* trait_names[] = \{UnityStrInf, UnityStrNegInf, UnityStrNaN, UnityStrDet\};\par
1092     UNITY_INT should_be_trait = ((UNITY_INT)style & 1);\par
1093     UNITY_INT is_trait        = !should_be_trait;\par
1094     UNITY_INT trait_index     = (UNITY_INT)(style >> 1);\par
1095 \par
1096     RETURN_IF_FAIL_OR_IGNORE;\par
1097 \par
1098     {\cf19 switch} (style)\par
1099     \{\par
1100         {\cf19 case} UNITY_FLOAT_IS_INF:\par
1101         {\cf19 case} UNITY_FLOAT_IS_NOT_INF:\par
1102             is_trait = UNITY_IS_INF(actual) && (actual > 0);\par
1103             {\cf19 break};\par
1104         {\cf19 case} UNITY_FLOAT_IS_NEG_INF:\par
1105         {\cf19 case} UNITY_FLOAT_IS_NOT_NEG_INF:\par
1106             is_trait = UNITY_IS_INF(actual) && (actual < 0);\par
1107             {\cf19 break};\par
1108 \par
1109         {\cf19 case} UNITY_FLOAT_IS_NAN:\par
1110         {\cf19 case} UNITY_FLOAT_IS_NOT_NAN:\par
1111             is_trait = UNITY_IS_NAN(actual) ? 1 : 0;\par
1112             {\cf19 break};\par
1113 \par
1114         {\cf19 case} UNITY_FLOAT_IS_DET: {\cf20 /* A determinate number is non infinite and not NaN. */}\par
1115         {\cf19 case} UNITY_FLOAT_IS_NOT_DET:\par
1116             is_trait = !UNITY_IS_INF(actual) && !UNITY_IS_NAN(actual);\par
1117             {\cf19 break};\par
1118 \par
1119         {\cf19 case} UNITY_FLOAT_INVALID_TRAIT:  {\cf20 /* Supress warning */}\par
1120         {\cf19 default}: {\cf20 /* including UNITY_FLOAT_INVALID_TRAIT */}\par
1121             trait_index = 0;\par
1122             trait_names[0] = UnityStrInvalidFloatTrait;\par
1123             {\cf19 break};\par
1124     \}\par
1125 \par
1126     {\cf19 if} (is_trait != should_be_trait)\par
1127     \{\par
1128         UnityTestResultsFailBegin(lineNumber);\par
1129         UnityPrint(UnityStrExpected);\par
1130         {\cf19 if} (!should_be_trait)\par
1131         \{\par
1132             UnityPrint(UnityStrNot);\par
1133         \}\par
1134         UnityPrint(trait_names[trait_index]);\par
1135         UnityPrint(UnityStrWas);\par
1136 {\cf21 #ifndef UNITY_EXCLUDE_FLOAT_PRINT}\par
1137         UnityPrintFloat((UNITY_DOUBLE)actual);\par
1138 {\cf21 #else}\par
1139         {\cf19 if} (should_be_trait)\par
1140         \{\par
1141             UnityPrint(UnityStrNot);\par
1142         \}\par
1143         UnityPrint(trait_names[trait_index]);\par
1144 {\cf21 #endif}\par
1145         UnityAddMsgIfSpecified(msg);\par
1146         UNITY_FAIL_AND_BAIL;\par
1147     \}\par
1148 \}\par
}
}
{\xe \v UnityAssertFloatsWithin\:unity.c}
{\xe \v unity.c\:UnityAssertFloatsWithin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void UnityAssertFloatsWithin (const {\b UNITY_FLOAT}  {\i delta}, const {\b UNITY_FLOAT}  {\i expected}, const {\b UNITY_FLOAT}  {\i actual}, const char *  {\i msg}, const {\b UNITY_LINE_TYPE}  {\i lineNumber})}}
\par
{\bkmkstart AAAAAAAAGE}
{\bkmkend AAAAAAAAGE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1013 of file unity.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1018 \{\par
1019     RETURN_IF_FAIL_OR_IGNORE;\par
1020 \par
1021 \par
1022     {\cf19 if} (!UnityFloatsWithin(delta, expected, actual))\par
1023     \{\par
1024         UnityTestResultsFailBegin(lineNumber);\par
1025         UNITY_PRINT_EXPECTED_AND_ACTUAL_FLOAT((UNITY_DOUBLE)expected, (UNITY_DOUBLE)actual);\par
1026         UnityAddMsgIfSpecified(msg);\par
1027         UNITY_FAIL_AND_BAIL;\par
1028     \}\par
1029 \}\par
}
}
{\xe \v UnityAssertGreaterOrLessFloat\:unity.c}
{\xe \v unity.c\:UnityAssertGreaterOrLessFloat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void UnityAssertGreaterOrLessFloat (const {\b UNITY_FLOAT}  {\i threshold}, const {\b UNITY_FLOAT}  {\i actual}, const {\b UNITY_COMPARISON_T}  {\i compare}, const char *  {\i msg}, const {\b UNITY_LINE_TYPE}  {\i lineNumber})}}
\par
{\bkmkstart AAAAAAAAGF}
{\bkmkend AAAAAAAAGF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1053 of file unity.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1058 \{\par
1059     {\cf18 int} failed;\par
1060 \par
1061     RETURN_IF_FAIL_OR_IGNORE;\par
1062 \par
1063     failed = 0;\par
1064 \par
1065     {\cf20 /* Checking for "not success" rather than failure to get the right result for NaN */}\par
1066     {\cf19 if} (!(actual < threshold) && (compare & UNITY_SMALLER_THAN)) \{ failed = 1; \}\par
1067     {\cf19 if} (!(actual > threshold) && (compare & UNITY_GREATER_THAN)) \{ failed = 1; \}\par
1068 \par
1069     {\cf19 if} ((compare & UNITY_EQUAL_TO) && UnityFloatsWithin(threshold * UNITY_FLOAT_PRECISION, threshold, actual)) \{ failed = 0; \}\par
1070 \par
1071     {\cf19 if} (failed)\par
1072     \{\par
1073         UnityTestResultsFailBegin(lineNumber);\par
1074         UnityPrint(UnityStrExpected);\par
1075         UnityPrintFloat(actual);\par
1076         {\cf19 if} (compare & UNITY_GREATER_THAN) \{ UnityPrint(UnityStrGt); \}\par
1077         {\cf19 if} (compare & UNITY_SMALLER_THAN) \{ UnityPrint(UnityStrLt); \}\par
1078         {\cf19 if} (compare & UNITY_EQUAL_TO)     \{ UnityPrint(UnityStrOrEqual);  \}\par
1079         UnityPrintFloat(threshold);\par
1080         UnityAddMsgIfSpecified(msg);\par
1081         UNITY_FAIL_AND_BAIL;\par
1082     \}\par
1083 \}\par
}
}
{\xe \v UnityAssertGreaterOrLessOrEqualNumber\:unity.c}
{\xe \v unity.c\:UnityAssertGreaterOrLessOrEqualNumber}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void UnityAssertGreaterOrLessOrEqualNumber (const {\b UNITY_INT}  {\i threshold}, const {\b UNITY_INT}  {\i actual}, const {\b UNITY_COMPARISON_T}  {\i compare}, const char *  {\i msg}, const {\b UNITY_LINE_TYPE}  {\i lineNumber}, const {\b UNITY_DISPLAY_STYLE_T}  {\i style})}}
\par
{\bkmkstart AAAAAAAAGG}
{\bkmkend AAAAAAAAGG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 733 of file unity.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 739 \{\par
740     {\cf18 int} failed = 0;\par
741     RETURN_IF_FAIL_OR_IGNORE;\par
742 \par
743     {\cf19 if} ((threshold == actual) && (compare & UNITY_EQUAL_TO)) \{ {\cf19 return}; \}\par
744     {\cf19 if} ((threshold == actual))                               \{ failed = 1; \}\par
745 \par
746     {\cf19 if} ((style & UNITY_DISPLAY_RANGE_INT) == UNITY_DISPLAY_RANGE_INT)\par
747     \{\par
748         {\cf19 if} ((actual > threshold) && (compare & UNITY_SMALLER_THAN)) \{ failed = 1; \}\par
749         {\cf19 if} ((actual < threshold) && (compare & UNITY_GREATER_THAN)) \{ failed = 1; \}\par
750     \}\par
751     {\cf19 else} {\cf20 /* UINT or HEX */}\par
752     \{\par
753         {\cf19 if} (((UNITY_UINT)actual > (UNITY_UINT)threshold) && (compare & UNITY_SMALLER_THAN)) \{ failed = 1; \}\par
754         {\cf19 if} (((UNITY_UINT)actual < (UNITY_UINT)threshold) && (compare & UNITY_GREATER_THAN)) \{ failed = 1; \}\par
755     \}\par
756 \par
757     {\cf19 if} (failed)\par
758     \{\par
759         UnityTestResultsFailBegin(lineNumber);\par
760         UnityPrint(UnityStrExpected);\par
761         UnityPrintNumberByStyle(actual, style);\par
762         {\cf19 if} (compare & UNITY_GREATER_THAN) \{ UnityPrint(UnityStrGt);       \}\par
763         {\cf19 if} (compare & UNITY_SMALLER_THAN) \{ UnityPrint(UnityStrLt);       \}\par
764         {\cf19 if} (compare & UNITY_EQUAL_TO)     \{ UnityPrint(UnityStrOrEqual);  \}\par
765         {\cf19 if} (compare == UNITY_NOT_EQUAL)   \{ UnityPrint(UnityStrNotEqual); \}\par
766         UnityPrintNumberByStyle(threshold, style);\par
767         UnityAddMsgIfSpecified(msg);\par
768         UNITY_FAIL_AND_BAIL;\par
769     \}\par
770 \}\par
}
}
{\xe \v UnityAssertNumbersArrayWithin\:unity.c}
{\xe \v unity.c\:UnityAssertNumbersArrayWithin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void UnityAssertNumbersArrayWithin (const {\b UNITY_UINT}  {\i delta}, {\b UNITY_INTERNAL_PTR}  {\i expected}, {\b UNITY_INTERNAL_PTR}  {\i actual}, const {\b UNITY_UINT32}  {\i num_elements}, const char *  {\i msg}, const {\b UNITY_LINE_TYPE}  {\i lineNumber}, const {\b UNITY_DISPLAY_STYLE_T}  {\i style}, const {\b UNITY_FLAGS_T}  {\i flags})}}
\par
{\bkmkstart AAAAAAAAGH}
{\bkmkend AAAAAAAAGH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1427 of file unity.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1435 \{\par
1436     UNITY_UINT32 elements = num_elements;\par
1437     {\cf18 unsigned} {\cf18 int} length   = style & 0xF;\par
1438     {\cf18 unsigned} {\cf18 int} increment = 0;\par
1439 \par
1440     RETURN_IF_FAIL_OR_IGNORE;\par
1441 \par
1442     {\cf19 if} (num_elements == 0)\par
1443     \{\par
1444 {\cf21 #ifdef UNITY_COMPARE_PTRS_ON_ZERO_ARRAY}\par
1445         UNITY_TEST_ASSERT_EQUAL_PTR(expected, actual, lineNumber, msg);\par
1446 {\cf21 #else}\par
1447         UnityPrintPointlessAndBail();\par
1448 {\cf21 #endif}\par
1449     \}\par
1450 \par
1451     {\cf19 if} (expected == actual)\par
1452     \{\par
1453         {\cf19 return}; {\cf20 /* Both are NULL or same pointer */}\par
1454     \}\par
1455 \par
1456     {\cf19 if} (UnityIsOneArrayNull(expected, actual, lineNumber, msg))\par
1457     \{\par
1458         UNITY_FAIL_AND_BAIL;\par
1459     \}\par
1460 \par
1461     {\cf19 while} ((elements > 0) && (elements--))\par
1462     \{\par
1463         UNITY_INT expect_val;\par
1464         UNITY_INT actual_val;\par
1465 \par
1466         {\cf19 switch} (length)\par
1467         \{\par
1468             {\cf19 case} 1:\par
1469                 {\cf20 /* fixing problems with signed overflow on unsigned numbers */}\par
1470                 {\cf19 if} ((style & UNITY_DISPLAY_RANGE_INT) == UNITY_DISPLAY_RANGE_INT)\par
1471                 \{\par
1472                     expect_val = *(UNITY_PTR_ATTRIBUTE {\cf17 const} UNITY_INT8*)expected;\par
1473                     actual_val = *(UNITY_PTR_ATTRIBUTE {\cf17 const} UNITY_INT8*)actual;\par
1474                     increment  = {\cf17 sizeof}(UNITY_INT8);\par
1475                 \}\par
1476                 {\cf19 else}\par
1477                 \{\par
1478                     expect_val = (UNITY_INT)*(UNITY_PTR_ATTRIBUTE {\cf17 const} UNITY_UINT8*)expected;\par
1479                     actual_val = (UNITY_INT)*(UNITY_PTR_ATTRIBUTE {\cf17 const} UNITY_UINT8*)actual;\par
1480                     increment  = {\cf17 sizeof}(UNITY_UINT8);\par
1481                 \}\par
1482                 {\cf19 break};\par
1483 \par
1484             {\cf19 case} 2:\par
1485                 {\cf20 /* fixing problems with signed overflow on unsigned numbers */}\par
1486                 {\cf19 if} ((style & UNITY_DISPLAY_RANGE_INT) == UNITY_DISPLAY_RANGE_INT)\par
1487                 \{\par
1488                     expect_val = *(UNITY_PTR_ATTRIBUTE {\cf17 const} UNITY_INT16*)expected;\par
1489                     actual_val = *(UNITY_PTR_ATTRIBUTE {\cf17 const} UNITY_INT16*)actual;\par
1490                     increment  = {\cf17 sizeof}(UNITY_INT16);\par
1491                 \}\par
1492                 {\cf19 else}\par
1493                 \{\par
1494                     expect_val = (UNITY_INT)*(UNITY_PTR_ATTRIBUTE {\cf17 const} UNITY_UINT16*)expected;\par
1495                     actual_val = (UNITY_INT)*(UNITY_PTR_ATTRIBUTE {\cf17 const} UNITY_UINT16*)actual;\par
1496                     increment  = {\cf17 sizeof}(UNITY_UINT16);\par
1497                 \}\par
1498                 {\cf19 break};\par
1499 \par
1500 {\cf21 #ifdef UNITY_SUPPORT_64}\par
1501             {\cf19 case} 8:\par
1502                 {\cf20 /* fixing problems with signed overflow on unsigned numbers */}\par
1503                 {\cf19 if} ((style & UNITY_DISPLAY_RANGE_INT) == UNITY_DISPLAY_RANGE_INT)\par
1504                 \{\par
1505                     expect_val = *(UNITY_PTR_ATTRIBUTE {\cf17 const} UNITY_INT64*)expected;\par
1506                     actual_val = *(UNITY_PTR_ATTRIBUTE {\cf17 const} UNITY_INT64*)actual;\par
1507                     increment  = {\cf17 sizeof}(UNITY_INT64);\par
1508                 \}\par
1509                 {\cf19 else}\par
1510                 \{\par
1511                     expect_val = (UNITY_INT)*(UNITY_PTR_ATTRIBUTE {\cf17 const} UNITY_UINT64*)expected;\par
1512                     actual_val = (UNITY_INT)*(UNITY_PTR_ATTRIBUTE {\cf17 const} UNITY_UINT64*)actual;\par
1513                     increment  = {\cf17 sizeof}(UNITY_UINT64);\par
1514                 \}\par
1515                 {\cf19 break};\par
1516 {\cf21 #endif}\par
1517 \par
1518             {\cf19 default}: {\cf20 /* default is length 4 bytes */}\par
1519             {\cf19 case} 4:\par
1520                 {\cf20 /* fixing problems with signed overflow on unsigned numbers */}\par
1521                 {\cf19 if} ((style & UNITY_DISPLAY_RANGE_INT) == UNITY_DISPLAY_RANGE_INT)\par
1522                 \{\par
1523                     expect_val = *(UNITY_PTR_ATTRIBUTE {\cf17 const} UNITY_INT32*)expected;\par
1524                     actual_val = *(UNITY_PTR_ATTRIBUTE {\cf17 const} UNITY_INT32*)actual;\par
1525                     increment  = {\cf17 sizeof}(UNITY_INT32);\par
1526                 \}\par
1527                 {\cf19 else}\par
1528                 \{\par
1529                     expect_val = (UNITY_INT)*(UNITY_PTR_ATTRIBUTE {\cf17 const} UNITY_UINT32*)expected;\par
1530                     actual_val = (UNITY_INT)*(UNITY_PTR_ATTRIBUTE {\cf17 const} UNITY_UINT32*)actual;\par
1531                     increment  = {\cf17 sizeof}(UNITY_UINT32);\par
1532                 \}\par
1533                 length = 4;\par
1534                 {\cf19 break};\par
1535         \}\par
1536 \par
1537         {\cf19 if} ((style & UNITY_DISPLAY_RANGE_INT) == UNITY_DISPLAY_RANGE_INT)\par
1538         \{\par
1539             {\cf19 if} (actual_val > expect_val)\par
1540             \{\par
1541                 Unity.CurrentTestFailed = (((UNITY_UINT)actual_val - (UNITY_UINT)expect_val) > delta);\par
1542             \}\par
1543             {\cf19 else}\par
1544             \{\par
1545                 Unity.CurrentTestFailed = (((UNITY_UINT)expect_val - (UNITY_UINT)actual_val) > delta);\par
1546             \}\par
1547         \}\par
1548         {\cf19 else}\par
1549         \{\par
1550             {\cf19 if} ((UNITY_UINT)actual_val > (UNITY_UINT)expect_val)\par
1551             \{\par
1552                 Unity.CurrentTestFailed = (((UNITY_UINT)actual_val - (UNITY_UINT)expect_val) > delta);\par
1553             \}\par
1554             {\cf19 else}\par
1555             \{\par
1556                 Unity.CurrentTestFailed = (((UNITY_UINT)expect_val - (UNITY_UINT)actual_val) > delta);\par
1557             \}\par
1558         \}\par
1559 \par
1560         {\cf19 if} (Unity.CurrentTestFailed)\par
1561         \{\par
1562             {\cf19 if} ((style & UNITY_DISPLAY_RANGE_UINT) && (length < (UNITY_INT_WIDTH / 8)))\par
1563             \{   {\cf20 /* For UINT, remove sign extension (padding 1's) from signed type casts above */}\par
1564                 UNITY_INT mask = 1;\par
1565                 mask = (mask << 8 * length) - 1;\par
1566                 expect_val &= mask;\par
1567                 actual_val &= mask;\par
1568             \}\par
1569             UnityTestResultsFailBegin(lineNumber);\par
1570             UnityPrint(UnityStrDelta);\par
1571             UnityPrintNumberByStyle((UNITY_INT)delta, style);\par
1572             UnityPrint(UnityStrElement);\par
1573             UnityPrintNumberUnsigned(num_elements - elements - 1);\par
1574             UnityPrint(UnityStrExpected);\par
1575             UnityPrintNumberByStyle(expect_val, style);\par
1576             UnityPrint(UnityStrWas);\par
1577             UnityPrintNumberByStyle(actual_val, style);\par
1578             UnityAddMsgIfSpecified(msg);\par
1579             UNITY_FAIL_AND_BAIL;\par
1580         \}\par
1581         {\cf20 /* Walk through array by incrementing the pointers */}\par
1582         {\cf19 if} (flags == UNITY_ARRAY_TO_ARRAY)\par
1583         \{\par
1584             expected = (UNITY_INTERNAL_PTR)(({\cf17 const} {\cf18 char}*)expected + increment);\par
1585         \}\par
1586         actual = (UNITY_INTERNAL_PTR)(({\cf17 const} {\cf18 char}*)actual + increment);\par
1587     \}\par
1588 \}\par
}
}
{\xe \v UnityAssertNumbersWithin\:unity.c}
{\xe \v unity.c\:UnityAssertNumbersWithin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void UnityAssertNumbersWithin (const {\b UNITY_UINT}  {\i delta}, const {\b UNITY_INT}  {\i expected}, const {\b UNITY_INT}  {\i actual}, const char *  {\i msg}, const {\b UNITY_LINE_TYPE}  {\i lineNumber}, const {\b UNITY_DISPLAY_STYLE_T}  {\i style})}}
\par
{\bkmkstart AAAAAAAAGI}
{\bkmkend AAAAAAAAGI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1380 of file unity.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1386 \{\par
1387     RETURN_IF_FAIL_OR_IGNORE;\par
1388 \par
1389     {\cf19 if} ((style & UNITY_DISPLAY_RANGE_INT) == UNITY_DISPLAY_RANGE_INT)\par
1390     \{\par
1391         {\cf19 if} (actual > expected)\par
1392         \{\par
1393             Unity.CurrentTestFailed = (((UNITY_UINT)actual - (UNITY_UINT)expected) > delta);\par
1394         \}\par
1395         {\cf19 else}\par
1396         \{\par
1397             Unity.CurrentTestFailed = (((UNITY_UINT)expected - (UNITY_UINT)actual) > delta);\par
1398         \}\par
1399     \}\par
1400     {\cf19 else}\par
1401     \{\par
1402         {\cf19 if} ((UNITY_UINT)actual > (UNITY_UINT)expected)\par
1403         \{\par
1404             Unity.CurrentTestFailed = (((UNITY_UINT)actual - (UNITY_UINT)expected) > delta);\par
1405         \}\par
1406         {\cf19 else}\par
1407         \{\par
1408             Unity.CurrentTestFailed = (((UNITY_UINT)expected - (UNITY_UINT)actual) > delta);\par
1409         \}\par
1410     \}\par
1411 \par
1412     {\cf19 if} (Unity.CurrentTestFailed)\par
1413     \{\par
1414         UnityTestResultsFailBegin(lineNumber);\par
1415         UnityPrint(UnityStrDelta);\par
1416         UnityPrintNumberByStyle((UNITY_INT)delta, style);\par
1417         UnityPrint(UnityStrExpected);\par
1418         UnityPrintNumberByStyle(expected, style);\par
1419         UnityPrint(UnityStrWas);\par
1420         UnityPrintNumberByStyle(actual, style);\par
1421         UnityAddMsgIfSpecified(msg);\par
1422         UNITY_FAIL_AND_BAIL;\par
1423     \}\par
1424 \}\par
}
}
{\xe \v UnityAssertWithinFloatArray\:unity.c}
{\xe \v unity.c\:UnityAssertWithinFloatArray}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void UnityAssertWithinFloatArray (const {\b UNITY_FLOAT}  {\i delta}, {\b UNITY_PTR_ATTRIBUTE} const {\b UNITY_FLOAT} *  {\i expected}, {\b UNITY_PTR_ATTRIBUTE} const {\b UNITY_FLOAT} *  {\i actual}, const {\b UNITY_UINT32}  {\i num_elements}, const char *  {\i msg}, const {\b UNITY_LINE_TYPE}  {\i lineNumber}, const {\b UNITY_FLAGS_T}  {\i flags})}}
\par
{\bkmkstart AAAAAAAAGJ}
{\bkmkend AAAAAAAAGJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 933 of file unity.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 940 \{\par
941     UNITY_UINT32 elements = num_elements;\par
942     UNITY_PTR_ATTRIBUTE {\cf17 const} UNITY_FLOAT* ptr_expected = expected;\par
943     UNITY_PTR_ATTRIBUTE {\cf17 const} UNITY_FLOAT* ptr_actual = actual;\par
944     UNITY_FLOAT in_delta = delta;\par
945     UNITY_FLOAT current_element_delta = delta;\par
946 \par
947     RETURN_IF_FAIL_OR_IGNORE;\par
948 \par
949     {\cf19 if} (elements == 0)\par
950     \{\par
951 {\cf21 #ifdef UNITY_COMPARE_PTRS_ON_ZERO_ARRAY}\par
952         UNITY_TEST_ASSERT_EQUAL_PTR(expected, actual, lineNumber, msg);\par
953 {\cf21 #else}\par
954         UnityPrintPointlessAndBail();\par
955 {\cf21 #endif}\par
956     \}\par
957 \par
958     {\cf19 if} (UNITY_IS_INF(in_delta))\par
959     \{\par
960         {\cf19 return}; {\cf20 /* Arrays will be force equal with infinite delta */}\par
961     \}\par
962 \par
963     {\cf19 if} (UNITY_IS_NAN(in_delta))\par
964     \{\par
965         {\cf20 /* Delta must be correct number */}\par
966         UnityPrintPointlessAndBail();\par
967     \}\par
968 \par
969     {\cf19 if} (expected == actual)\par
970     \{\par
971         {\cf19 return}; {\cf20 /* Both are NULL or same pointer */}\par
972     \}\par
973 \par
974     {\cf19 if} (UnityIsOneArrayNull((UNITY_INTERNAL_PTR)expected, (UNITY_INTERNAL_PTR)actual, lineNumber, msg))\par
975     \{\par
976         UNITY_FAIL_AND_BAIL;\par
977     \}\par
978 \par
979     {\cf20 /* fix delta sign if need */}\par
980     {\cf19 if} (in_delta < 0)\par
981     \{\par
982         in_delta = -in_delta;\par
983     \}\par
984 \par
985     {\cf19 while} (elements--)\par
986     \{\par
987         current_element_delta = *ptr_expected * UNITY_FLOAT_PRECISION;\par
988 \par
989         {\cf19 if} (current_element_delta < 0)\par
990         \{\par
991             {\cf20 /* fix delta sign for correct calculations */}\par
992             current_element_delta = -current_element_delta;\par
993         \}\par
994 \par
995         {\cf19 if} (!UnityFloatsWithin(in_delta + current_element_delta, *ptr_expected, *ptr_actual))\par
996         \{\par
997             UnityTestResultsFailBegin(lineNumber);\par
998             UnityPrint(UnityStrElement);\par
999             UnityPrintNumberUnsigned(num_elements - elements - 1);\par
1000             UNITY_PRINT_EXPECTED_AND_ACTUAL_FLOAT((UNITY_DOUBLE)*ptr_expected, (UNITY_DOUBLE)*ptr_actual);\par
1001             UnityAddMsgIfSpecified(msg);\par
1002             UNITY_FAIL_AND_BAIL;\par
1003         \}\par
1004         {\cf19 if} (flags == UNITY_ARRAY_TO_ARRAY)\par
1005         \{\par
1006             ptr_expected++;\par
1007         \}\par
1008         ptr_actual++;\par
1009     \}\par
1010 \}\par
}
}
{\xe \v UnityBegin\:unity.c}
{\xe \v unity.c\:UnityBegin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void UnityBegin (const char *  {\i filename})}}
\par
{\bkmkstart AAAAAAAAGK}
{\bkmkend AAAAAAAAGK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 2221 of file unity.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2222 \{\par
2223     Unity.TestFile = filename;\par
2224     Unity.CurrentTestName = NULL;\par
2225     Unity.CurrentTestLineNumber = 0;\par
2226     Unity.NumberOfTests = 0;\par
2227     Unity.TestFailures = 0;\par
2228     Unity.TestIgnores = 0;\par
2229     Unity.CurrentTestFailed = 0;\par
2230     Unity.CurrentTestIgnored = 0;\par
2231 \par
2232     UNITY_CLR_DETAILS();\par
2233     UNITY_OUTPUT_START();\par
2234 \}\par
}
}
{\xe \v UnityConcludeTest\:unity.c}
{\xe \v unity.c\:UnityConcludeTest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void UnityConcludeTest (void )}}
\par
{\bkmkstart AAAAAAAAGL}
{\bkmkend AAAAAAAAGL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 546 of file unity.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 547 \{\par
548     {\cf19 if} (Unity.CurrentTestIgnored)\par
549     \{\par
550         Unity.TestIgnores++;\par
551     \}\par
552     {\cf19 else} {\cf19 if} (!Unity.CurrentTestFailed)\par
553     \{\par
554         UnityTestResultsBegin(Unity.TestFile, Unity.CurrentTestLineNumber);\par
555         UnityPrint(UnityStrPass);\par
556     \}\par
557     {\cf19 else}\par
558     \{\par
559         Unity.TestFailures++;\par
560     \}\par
561 \par
562     Unity.CurrentTestFailed = 0;\par
563     Unity.CurrentTestIgnored = 0;\par
564     UNITY_PRINT_EXEC_TIME();\par
565     UNITY_PRINT_EOL();\par
566     UNITY_FLUSH_CALL();\par
567 \}\par
}
}
{\xe \v UnityDefaultTestRun\:unity.c}
{\xe \v unity.c\:UnityDefaultTestRun}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void UnityDefaultTestRun ({\b UnityTestFunction}  {\i Func}, const char *  {\i FuncName}, const int  {\i FuncLineNum})}}
\par
{\bkmkstart AAAAAAAAGM}
{\bkmkend AAAAAAAAGM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 2193 of file unity.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2194 \{\par
2195     Unity.CurrentTestName = FuncName;\par
2196     Unity.CurrentTestLineNumber = (UNITY_LINE_TYPE)FuncLineNum;\par
2197     Unity.NumberOfTests++;\par
2198     UNITY_CLR_DETAILS();\par
2199     UNITY_EXEC_TIME_START();\par
2200     {\cf19 if} (TEST_PROTECT())\par
2201     \{\par
2202         setUp();\par
2203         Func();\par
2204     \}\par
2205     {\cf19 if} (TEST_PROTECT())\par
2206     \{\par
2207         tearDown();\par
2208     \}\par
2209     UNITY_EXEC_TIME_STOP();\par
2210     UnityConcludeTest();\par
2211 \}\par
}
}
{\xe \v UnityEnd\:unity.c}
{\xe \v unity.c\:UnityEnd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int UnityEnd (void )}}
\par
{\bkmkstart AAAAAAAAGN}
{\bkmkend AAAAAAAAGN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 2237 of file unity.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2238 \{\par
2239     UNITY_PRINT_EOL();\par
2240     UnityPrint(UnityStrBreaker);\par
2241     UNITY_PRINT_EOL();\par
2242     UnityPrintNumber((UNITY_INT)(Unity.NumberOfTests));\par
2243     UnityPrint(UnityStrResultsTests);\par
2244     UnityPrintNumber((UNITY_INT)(Unity.TestFailures));\par
2245     UnityPrint(UnityStrResultsFailures);\par
2246     UnityPrintNumber((UNITY_INT)(Unity.TestIgnores));\par
2247     UnityPrint(UnityStrResultsIgnored);\par
2248     UNITY_PRINT_EOL();\par
2249     {\cf19 if} (Unity.TestFailures == 0U)\par
2250     \{\par
2251         UnityPrint(UnityStrOk);\par
2252     \}\par
2253     {\cf19 else}\par
2254     \{\par
2255         UnityPrint(UnityStrFail);\par
2256 {\cf21 #ifdef UNITY_DIFFERENTIATE_FINAL_FAIL}\par
2257         UNITY_OUTPUT_CHAR({\cf23 'E'}); UNITY_OUTPUT_CHAR({\cf23 'D'});\par
2258 {\cf21 #endif}\par
2259     \}\par
2260     UNITY_PRINT_EOL();\par
2261     UNITY_FLUSH_CALL();\par
2262     UNITY_OUTPUT_COMPLETE();\par
2263     {\cf19 return} ({\cf18 int})(Unity.TestFailures);\par
2264 \}\par
}
}
{\xe \v UnityFail\:unity.c}
{\xe \v unity.c\:UnityFail}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void UnityFail (const char *  {\i msg}, const {\b UNITY_LINE_TYPE}  {\i line})}}
\par
{\bkmkstart AAAAAAAAGO}
{\bkmkend AAAAAAAAGO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 2124 of file unity.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2125 \{\par
2126     RETURN_IF_FAIL_OR_IGNORE;\par
2127 \par
2128     UnityTestResultsBegin(Unity.TestFile, line);\par
2129     UnityPrint(UnityStrFail);\par
2130     {\cf19 if} (msg != NULL)\par
2131     \{\par
2132         UNITY_OUTPUT_CHAR({\cf23 ':'});\par
2133 \par
2134 {\cf21 #ifdef UNITY_PRINT_TEST_CONTEXT}\par
2135         UNITY_PRINT_TEST_CONTEXT();\par
2136 {\cf21 #endif}\par
2137 {\cf21 #ifndef UNITY_EXCLUDE_DETAILS}\par
2138         {\cf19 if} (Unity.CurrentDetail1)\par
2139         \{\par
2140             UnityPrint(UnityStrDetail1Name);\par
2141             UnityPrint(Unity.CurrentDetail1);\par
2142             {\cf19 if} (Unity.CurrentDetail2)\par
2143             \{\par
2144                 UnityPrint(UnityStrDetail2Name);\par
2145                 UnityPrint(Unity.CurrentDetail2);\par
2146             \}\par
2147             UnityPrint(UnityStrSpacer);\par
2148         \}\par
2149 {\cf21 #endif}\par
2150         {\cf19 if} (msg[0] != {\cf23 ' '})\par
2151         \{\par
2152             UNITY_OUTPUT_CHAR({\cf23 ' '});\par
2153         \}\par
2154         UnityPrint(msg);\par
2155     \}\par
2156 \par
2157     UNITY_FAIL_AND_BAIL;\par
2158 \}\par
}
}
{\xe \v UnityFloatToPtr\:unity.c}
{\xe \v unity.c\:UnityFloatToPtr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UNITY_INTERNAL_PTR} UnityFloatToPtr (const float  {\i num})}}
\par
{\bkmkstart AAAAAAAAGP}
{\bkmkend AAAAAAAAGP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1868 of file unity.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1869 \{\par
1870     UnityQuickCompare.f = num;\par
1871     {\cf19 return} (UNITY_INTERNAL_PTR)(&UnityQuickCompare.f);\par
1872 \}\par
}
}
{\xe \v UnityIgnore\:unity.c}
{\xe \v unity.c\:UnityIgnore}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void UnityIgnore (const char *  {\i msg}, const {\b UNITY_LINE_TYPE}  {\i line})}}
\par
{\bkmkstart AAAAAAAAGQ}
{\bkmkend AAAAAAAAGQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 2161 of file unity.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2162 \{\par
2163     RETURN_IF_FAIL_OR_IGNORE;\par
2164 \par
2165     UnityTestResultsBegin(Unity.TestFile, line);\par
2166     UnityPrint(UnityStrIgnore);\par
2167     {\cf19 if} (msg != NULL)\par
2168     \{\par
2169         UNITY_OUTPUT_CHAR({\cf23 ':'});\par
2170         UNITY_OUTPUT_CHAR({\cf23 ' '});\par
2171         UnityPrint(msg);\par
2172     \}\par
2173     UNITY_IGNORE_AND_BAIL;\par
2174 \}\par
}
}
{\xe \v UnityMessage\:unity.c}
{\xe \v unity.c\:UnityMessage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void UnityMessage (const char *  {\i msg}, const {\b UNITY_LINE_TYPE}  {\i line})}}
\par
{\bkmkstart AAAAAAAAGR}
{\bkmkend AAAAAAAAGR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 2177 of file unity.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2178 \{\par
2179     UnityTestResultsBegin(Unity.TestFile, line);\par
2180     UnityPrint({\cf22 "INFO"});\par
2181     {\cf19 if} (msg != NULL)\par
2182     \{\par
2183       UNITY_OUTPUT_CHAR({\cf23 ':'});\par
2184       UNITY_OUTPUT_CHAR({\cf23 ' '});\par
2185       UnityPrint(msg);\par
2186     \}\par
2187     UNITY_PRINT_EOL();\par
2188 \}\par
}
}
{\xe \v UnityNumToPtr\:unity.c}
{\xe \v unity.c\:UnityNumToPtr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UNITY_INTERNAL_PTR} UnityNumToPtr (const {\b UNITY_INT}  {\i num}, const {\b UNITY_UINT8}  {\i size})}}
\par
{\bkmkstart AAAAAAAAGS}
{\bkmkend AAAAAAAAGS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1842 of file unity.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1843 \{\par
1844     {\cf19 switch}(size)\par
1845     \{\par
1846         {\cf19 case} 1:\par
1847             UnityQuickCompare.i8 = (UNITY_INT8)num;\par
1848             {\cf19 return} (UNITY_INTERNAL_PTR)(&UnityQuickCompare.i8);\par
1849 \par
1850         {\cf19 case} 2:\par
1851             UnityQuickCompare.i16 = (UNITY_INT16)num;\par
1852             {\cf19 return} (UNITY_INTERNAL_PTR)(&UnityQuickCompare.i16);\par
1853 \par
1854 {\cf21 #ifdef UNITY_SUPPORT_64}\par
1855         {\cf19 case} 8:\par
1856             UnityQuickCompare.i64 = (UNITY_INT64)num;\par
1857             {\cf19 return} (UNITY_INTERNAL_PTR)(&UnityQuickCompare.i64);\par
1858 {\cf21 #endif}\par
1859 \par
1860         {\cf19 default}: {\cf20 /* 4 bytes */}\par
1861             UnityQuickCompare.i32 = (UNITY_INT32)num;\par
1862             {\cf19 return} (UNITY_INTERNAL_PTR)(&UnityQuickCompare.i32);\par
1863     \}\par
1864 \}\par
}
}
{\xe \v UnityPrint\:unity.c}
{\xe \v unity.c\:UnityPrint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void UnityPrint (const char *  {\i string})}}
\par
{\bkmkstart AAAAAAAAGT}
{\bkmkend AAAAAAAAGT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 128 of file unity.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 129 \{\par
130     {\cf17 const} {\cf18 char}* pch = string;\par
131 \par
132     {\cf19 if} (pch != NULL)\par
133     \{\par
134         {\cf19 while} (*pch)\par
135         \{\par
136 {\cf21 #ifdef UNITY_OUTPUT_COLOR}\par
137             {\cf20 /* print ANSI escape code */}\par
138             {\cf19 if} ((*pch == 27) && (*(pch + 1) == {\cf23 '['}))\par
139             \{\par
140                 pch += UnityPrintAnsiEscapeString(pch);\par
141                 {\cf19 continue};\par
142             \}\par
143 {\cf21 #endif}\par
144             UnityPrintChar(pch);\par
145             pch++;\par
146         \}\par
147     \}\par
148 \}\par
}
}
{\xe \v UnityPrintFloat\:unity.c}
{\xe \v unity.c\:UnityPrintFloat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void UnityPrintFloat (const {\b UNITY_DOUBLE}  {\i input_number})}}
\par
{\bkmkstart AAAAAAAAGU}
{\bkmkend AAAAAAAAGU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 334 of file unity.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 335 \{\par
336 {\cf21 #ifdef UNITY_INCLUDE_DOUBLE}\par
337     {\cf17 static} {\cf17 const} {\cf18 int} sig_digits = 9;\par
338     {\cf17 static} {\cf17 const} UNITY_INT32 min_scaled = 100000000;\par
339     {\cf17 static} {\cf17 const} UNITY_INT32 max_scaled = 1000000000;\par
340 {\cf21 #else}\par
341     {\cf17 static} {\cf17 const} {\cf18 int} sig_digits = 7;\par
342     {\cf17 static} {\cf17 const} UNITY_INT32 min_scaled = 1000000;\par
343     {\cf17 static} {\cf17 const} UNITY_INT32 max_scaled = 10000000;\par
344 {\cf21 #endif}\par
345 \par
346     UNITY_DOUBLE number = input_number;\par
347 \par
348     {\cf20 /* print minus sign (does not handle negative zero) */}\par
349     {\cf19 if} (number < 0.0f)\par
350     \{\par
351         UNITY_OUTPUT_CHAR({\cf23 '-'});\par
352         number = -number;\par
353     \}\par
354 \par
355     {\cf20 /* handle zero, NaN, and +/- infinity */}\par
356     {\cf19 if} (number == 0.0f)\par
357     \{\par
358         UnityPrint({\cf22 "0"});\par
359     \}\par
360     {\cf19 else} {\cf19 if} (UNITY_IS_NAN(number))\par
361     \{\par
362         UnityPrint({\cf22 "nan"});\par
363     \}\par
364     {\cf19 else} {\cf19 if} (UNITY_IS_INF(number))\par
365     \{\par
366         UnityPrint({\cf22 "inf"});\par
367     \}\par
368     {\cf19 else}\par
369     \{\par
370         UNITY_INT32 n_int = 0;\par
371         UNITY_INT32 n;\par
372         {\cf18 int}         exponent = 0;\par
373         {\cf18 int}         decimals;\par
374         {\cf18 int}         digits;\par
375         {\cf18 char}        buf[16] = \{0\};\par
376 \par
377         {\cf20 /*}\par
378 {\cf20          * Scale up or down by powers of 10.  To minimize rounding error,}\par
379 {\cf20          * start with a factor/divisor of 10^10, which is the largest}\par
380 {\cf20          * power of 10 that can be represented exactly.  Finally, compute}\par
381 {\cf20          * (exactly) the remaining power of 10 and perform one more}\par
382 {\cf20          * multiplication or division.}\par
383 {\cf20          */}\par
384         {\cf19 if} (number < 1.0f)\par
385         \{\par
386             UNITY_DOUBLE factor = 1.0f;\par
387 \par
388             {\cf19 while} (number < (UNITY_DOUBLE)max_scaled / 1e10f)  \{ number *= 1e10f; exponent -= 10; \}\par
389             {\cf19 while} (number * factor < (UNITY_DOUBLE)min_scaled) \{ factor *= 10.0f; exponent--; \}\par
390 \par
391             number *= factor;\par
392         \}\par
393         {\cf19 else} {\cf19 if} (number > (UNITY_DOUBLE)max_scaled)\par
394         \{\par
395             UNITY_DOUBLE divisor = 1.0f;\par
396 \par
397             {\cf19 while} (number > (UNITY_DOUBLE)min_scaled * 1e10f)   \{ number  /= 1e10f; exponent += 10; \}\par
398             {\cf19 while} (number / divisor > (UNITY_DOUBLE)max_scaled) \{ divisor *= 10.0f; exponent++; \}\par
399 \par
400             number /= divisor;\par
401         \}\par
402         {\cf19 else}\par
403         \{\par
404             {\cf20 /*}\par
405 {\cf20              * In this range, we can split off the integer part before}\par
406 {\cf20              * doing any multiplications.  This reduces rounding error by}\par
407 {\cf20              * freeing up significant bits in the fractional part.}\par
408 {\cf20              */}\par
409             UNITY_DOUBLE factor = 1.0f;\par
410             n_int = (UNITY_INT32)number;\par
411             number -= (UNITY_DOUBLE)n_int;\par
412 \par
413             {\cf19 while} (n_int < min_scaled) \{ n_int *= 10; factor *= 10.0f; exponent--; \}\par
414 \par
415             number *= factor;\par
416         \}\par
417 \par
418         {\cf20 /* round to nearest integer */}\par
419         n = ((UNITY_INT32)(number + number) + 1) / 2;\par
420 \par
421 {\cf21 #ifndef UNITY_ROUND_TIES_AWAY_FROM_ZERO}\par
422         {\cf20 /* round to even if exactly between two integers */}\par
423         {\cf19 if} ((n & 1) && (((UNITY_DOUBLE)n - number) == 0.5f))\par
424             n--;\par
425 {\cf21 #endif}\par
426 \par
427         n += n_int;\par
428 \par
429         {\cf19 if} (n >= max_scaled)\par
430         \{\par
431             n = min_scaled;\par
432             exponent++;\par
433         \}\par
434 \par
435         {\cf20 /* determine where to place decimal point */}\par
436         decimals = ((exponent <= 0) && (exponent >= -(sig_digits + 3))) ? (-exponent) : (sig_digits - 1);\par
437         exponent += decimals;\par
438 \par
439         {\cf20 /* truncate trailing zeroes after decimal point */}\par
440         {\cf19 while} ((decimals > 0) && ((n % 10) == 0))\par
441         \{\par
442             n /= 10;\par
443             decimals--;\par
444         \}\par
445 \par
446         {\cf20 /* build up buffer in reverse order */}\par
447         digits = 0;\par
448         {\cf19 while} ((n != 0) || (digits <= decimals))\par
449         \{\par
450             buf[digits++] = (char)({\cf23 '0'} + n % 10);\par
451             n /= 10;\par
452         \}\par
453 \par
454         {\cf20 /* print out buffer (backwards) */}\par
455         {\cf19 while} (digits > 0)\par
456         \{\par
457             {\cf19 if} (digits == decimals)\par
458             \{\par
459                 UNITY_OUTPUT_CHAR({\cf23 '.'});\par
460             \}\par
461             UNITY_OUTPUT_CHAR(buf[--digits]);\par
462         \}\par
463 \par
464         {\cf20 /* print exponent if needed */}\par
465         {\cf19 if} (exponent != 0)\par
466         \{\par
467             UNITY_OUTPUT_CHAR({\cf23 'e'});\par
468 \par
469             {\cf19 if} (exponent < 0)\par
470             \{\par
471                 UNITY_OUTPUT_CHAR({\cf23 '-'});\par
472                 exponent = -exponent;\par
473             \}\par
474             {\cf19 else}\par
475             \{\par
476                 UNITY_OUTPUT_CHAR({\cf23 '+'});\par
477             \}\par
478 \par
479             digits = 0;\par
480             {\cf19 while} ((exponent != 0) || (digits < 2))\par
481             \{\par
482                 buf[digits++] = (char)({\cf23 '0'} + exponent % 10);\par
483                 exponent /= 10;\par
484             \}\par
485             {\cf19 while} (digits > 0)\par
486             \{\par
487                 UNITY_OUTPUT_CHAR(buf[--digits]);\par
488             \}\par
489         \}\par
490     \}\par
491 \}\par
}
}
{\xe \v UnityPrintLen\:unity.c}
{\xe \v unity.c\:UnityPrintLen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void UnityPrintLen (const char *  {\i string}, const {\b UNITY_UINT32}  {\i length})}}
\par
{\bkmkstart AAAAAAAAGV}
{\bkmkend AAAAAAAAGV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 150 of file unity.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 151 \{\par
152     {\cf17 const} {\cf18 char}* pch = string;\par
153 \par
154     {\cf19 if} (pch != NULL)\par
155     \{\par
156         {\cf19 while} (*pch && ((UNITY_UINT32)(pch - {\cf18 string}) < length))\par
157         \{\par
158             {\cf20 /* printable characters plus CR & LF are printed */}\par
159             {\cf19 if} ((*pch <= 126) && (*pch >= 32))\par
160             \{\par
161                 UNITY_OUTPUT_CHAR(*pch);\par
162             \}\par
163             {\cf20 /* write escaped carriage returns */}\par
164             {\cf19 else} {\cf19 if} (*pch == 13)\par
165             \{\par
166                 UNITY_OUTPUT_CHAR({\cf23 '\\\\'});\par
167                 UNITY_OUTPUT_CHAR({\cf23 'r'});\par
168             \}\par
169             {\cf20 /* write escaped line feeds */}\par
170             {\cf19 else} {\cf19 if} (*pch == 10)\par
171             \{\par
172                 UNITY_OUTPUT_CHAR({\cf23 '\\\\'});\par
173                 UNITY_OUTPUT_CHAR({\cf23 'n'});\par
174             \}\par
175             {\cf20 /* unprintable characters are shown as codes */}\par
176             {\cf19 else}\par
177             \{\par
178                 UNITY_OUTPUT_CHAR({\cf23 '\\\\'});\par
179                 UNITY_OUTPUT_CHAR({\cf23 'x'});\par
180                 UnityPrintNumberHex((UNITY_UINT)*pch, 2);\par
181             \}\par
182             pch++;\par
183         \}\par
184     \}\par
185 \}\par
}
}
{\xe \v UnityPrintMask\:unity.c}
{\xe \v unity.c\:UnityPrintMask}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void UnityPrintMask (const {\b UNITY_UINT}  {\i mask}, const {\b UNITY_UINT}  {\i number})}}
\par
{\bkmkstart AAAAAAAAGW}
{\bkmkend AAAAAAAAGW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 299 of file unity.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 300 \{\par
301     UNITY_UINT current_bit = (UNITY_UINT)1 << (UNITY_INT_WIDTH - 1);\par
302     UNITY_INT32 i;\par
303 \par
304     {\cf19 for} (i = 0; i < UNITY_INT_WIDTH; i++)\par
305     \{\par
306         {\cf19 if} (current_bit & mask)\par
307         \{\par
308             {\cf19 if} (current_bit & number)\par
309             \{\par
310                 UNITY_OUTPUT_CHAR({\cf23 '1'});\par
311             \}\par
312             {\cf19 else}\par
313             \{\par
314                 UNITY_OUTPUT_CHAR({\cf23 '0'});\par
315             \}\par
316         \}\par
317         {\cf19 else}\par
318         \{\par
319             UNITY_OUTPUT_CHAR({\cf23 'X'});\par
320         \}\par
321         current_bit = current_bit >> 1;\par
322     \}\par
323 \}\par
}
}
{\xe \v UnityPrintNumber\:unity.c}
{\xe \v unity.c\:UnityPrintNumber}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void UnityPrintNumber (const {\b UNITY_INT}  {\i number_to_print})}}
\par
{\bkmkstart AAAAAAAAGX}
{\bkmkend AAAAAAAAGX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 239 of file unity.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 240 \{\par
241     UNITY_UINT number = (UNITY_UINT)number_to_print;\par
242 \par
243     {\cf19 if} (number_to_print < 0)\par
244     \{\par
245         {\cf20 /* A negative number, including MIN negative */}\par
246         UNITY_OUTPUT_CHAR({\cf23 '-'});\par
247         number = (~number) + 1;\par
248     \}\par
249     UnityPrintNumberUnsigned(number);\par
250 \}\par
}
}
{\xe \v UnityPrintNumberByStyle\:unity.c}
{\xe \v unity.c\:UnityPrintNumberByStyle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void UnityPrintNumberByStyle (const {\b UNITY_INT}  {\i number}, const {\b UNITY_DISPLAY_STYLE_T}  {\i style})}}
\par
{\bkmkstart AAAAAAAAGY}
{\bkmkend AAAAAAAAGY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 188 of file unity.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 189 \{\par
190     {\cf19 if} ((style & UNITY_DISPLAY_RANGE_INT) == UNITY_DISPLAY_RANGE_INT)\par
191     \{\par
192         {\cf19 if} (style == UNITY_DISPLAY_STYLE_CHAR)\par
193         \{\par
194             {\cf20 /* printable characters plus CR & LF are printed */}\par
195             UNITY_OUTPUT_CHAR({\cf23 '\\''});\par
196             {\cf19 if} ((number <= 126) && (number >= 32))\par
197             \{\par
198                 UNITY_OUTPUT_CHAR(({\cf18 int})number);\par
199             \}\par
200             {\cf20 /* write escaped carriage returns */}\par
201             {\cf19 else} {\cf19 if} (number == 13)\par
202             \{\par
203                 UNITY_OUTPUT_CHAR({\cf23 '\\\\'});\par
204                 UNITY_OUTPUT_CHAR({\cf23 'r'});\par
205             \}\par
206             {\cf20 /* write escaped line feeds */}\par
207             {\cf19 else} {\cf19 if} (number == 10)\par
208             \{\par
209                 UNITY_OUTPUT_CHAR({\cf23 '\\\\'});\par
210                 UNITY_OUTPUT_CHAR({\cf23 'n'});\par
211             \}\par
212             {\cf20 /* unprintable characters are shown as codes */}\par
213             {\cf19 else}\par
214             \{\par
215                 UNITY_OUTPUT_CHAR({\cf23 '\\\\'});\par
216                 UNITY_OUTPUT_CHAR({\cf23 'x'});\par
217                 UnityPrintNumberHex((UNITY_UINT)number, 2);\par
218             \}\par
219             UNITY_OUTPUT_CHAR({\cf23 '\\''});\par
220         \}\par
221         {\cf19 else}\par
222         \{\par
223             UnityPrintNumber(number);\par
224         \}\par
225     \}\par
226     {\cf19 else} {\cf19 if} ((style & UNITY_DISPLAY_RANGE_UINT) == UNITY_DISPLAY_RANGE_UINT)\par
227     \{\par
228         UnityPrintNumberUnsigned((UNITY_UINT)number);\par
229     \}\par
230     {\cf19 else}\par
231     \{\par
232         UNITY_OUTPUT_CHAR({\cf23 '0'});\par
233         UNITY_OUTPUT_CHAR({\cf23 'x'});\par
234         UnityPrintNumberHex((UNITY_UINT)number, ({\cf18 char})((style & 0xF) * 2));\par
235     \}\par
236 \}\par
}
}
{\xe \v UnityPrintNumberHex\:unity.c}
{\xe \v unity.c\:UnityPrintNumberHex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void UnityPrintNumberHex (const {\b UNITY_UINT}  {\i number}, const char  {\i nibbles_to_print})}}
\par
{\bkmkstart AAAAAAAAGZ}
{\bkmkend AAAAAAAAGZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 273 of file unity.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 274 \{\par
275     {\cf18 int} nibble;\par
276     {\cf18 char} nibbles = nibbles_to_print;\par
277 \par
278     {\cf19 if} (({\cf18 unsigned})nibbles > UNITY_MAX_NIBBLES)\par
279     \{\par
280         nibbles = UNITY_MAX_NIBBLES;\par
281     \}\par
282 \par
283     {\cf19 while} (nibbles > 0)\par
284     \{\par
285         nibbles--;\par
286         nibble = (int)(number >> (nibbles * 4)) & 0x0F;\par
287         {\cf19 if} (nibble <= 9)\par
288         \{\par
289             UNITY_OUTPUT_CHAR(({\cf18 char})({\cf23 '0'} + nibble));\par
290         \}\par
291         {\cf19 else}\par
292         \{\par
293             UNITY_OUTPUT_CHAR(({\cf18 char})({\cf23 'A'} - 10 + nibble));\par
294         \}\par
295     \}\par
296 \}\par
}
}
{\xe \v UnityPrintNumberUnsigned\:unity.c}
{\xe \v unity.c\:UnityPrintNumberUnsigned}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void UnityPrintNumberUnsigned (const {\b UNITY_UINT}  {\i number})}}
\par
{\bkmkstart AAAAAAAAHA}
{\bkmkend AAAAAAAAHA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 254 of file unity.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 255 \{\par
256     UNITY_UINT divisor = 1;\par
257 \par
258     {\cf20 /* figure out initial divisor */}\par
259     {\cf19 while} (number / divisor > 9)\par
260     \{\par
261         divisor *= 10;\par
262     \}\par
263 \par
264     {\cf20 /* now mod and print, then divide divisor */}\par
265     {\cf19 do}\par
266     \{\par
267         UNITY_OUTPUT_CHAR(({\cf18 char})({\cf23 '0'} + (number / divisor % 10)));\par
268         divisor /= 10;\par
269     \} {\cf19 while} (divisor > 0);\par
270 \}\par
}
}
{\xe \v UnitySetTestFile\:unity.c}
{\xe \v unity.c\:UnitySetTestFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void UnitySetTestFile (const char *  {\i filename})}}
\par
{\bkmkstart AAAAAAAAHB}
{\bkmkend AAAAAAAAHB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 2215 of file unity.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2216 \{\par
2217     Unity.TestFile = filename;\par
2218 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v f\:unity.c}
{\xe \v unity.c\:f}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float f}}
\par
{\bkmkstart AAAAAAAAHC}
{\bkmkend AAAAAAAAHC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1835 of file unity.c.}\par
}
{\xe \v i16\:unity.c}
{\xe \v unity.c\:i16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UNITY_INT16} i16}}
\par
{\bkmkstart AAAAAAAAHD}
{\bkmkend AAAAAAAAHD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1829 of file unity.c.}\par
}
{\xe \v i32\:unity.c}
{\xe \v unity.c\:i32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UNITY_INT32} i32}}
\par
{\bkmkstart AAAAAAAAHE}
{\bkmkend AAAAAAAAHE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1830 of file unity.c.}\par
}
{\xe \v i8\:unity.c}
{\xe \v unity.c\:i8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UNITY_INT8} i8}}
\par
{\bkmkstart AAAAAAAAHF}
{\bkmkend AAAAAAAAHF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1828 of file unity.c.}\par
}
{\xe \v Unity\:unity.c}
{\xe \v unity.c\:Unity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b UNITY_STORAGE_T} Unity}}
\par
{\bkmkstart AAAAAAAAHG}
{\bkmkend AAAAAAAAHG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1 of file unity.c.}\par
}
{\xe \v UnityStrErr64\:unity.c}
{\xe \v unity.c\:UnityStrErr64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b UNITY_PROGMEM} UnityStrErr64[] = "Unity 64-bit Support Disabled"}}
\par
{\bkmkstart AAAAAAAAHH}
{\bkmkend AAAAAAAAHH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 63 of file unity.c.}\par
}
{\xe \v UnityStrErrDouble\:unity.c}
{\xe \v unity.c\:UnityStrErrDouble}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b UNITY_PROGMEM} UnityStrErrDouble[] = "Unity Double Precision Disabled"}}
\par
{\bkmkstart AAAAAAAAHI}
{\bkmkend AAAAAAAAHI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 62 of file unity.c.}\par
}
{\xe \v UnityStrErrFloat\:unity.c}
{\xe \v unity.c\:UnityStrErrFloat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b UNITY_PROGMEM} UnityStrErrFloat[] = "Unity Floating Point Disabled"}}
\par
{\bkmkstart AAAAAAAAHJ}
{\bkmkend AAAAAAAAHJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 61 of file unity.c.}\par
}
{\xe \v UnityStrErrShorthand\:unity.c}
{\xe \v unity.c\:UnityStrErrShorthand}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b UNITY_PROGMEM} UnityStrErrShorthand[] = "Unity Shorthand Support Disabled"}}
\par
{\bkmkstart AAAAAAAAHK}
{\bkmkend AAAAAAAAHK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 60 of file unity.c.}\par
}
{\xe \v UnityStrFail\:unity.c}
{\xe \v unity.c\:UnityStrFail}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b UNITY_PROGMEM} UnityStrFail[] = "FAIL"}}
\par
{\bkmkstart AAAAAAAAHL}
{\bkmkend AAAAAAAAHL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 34 of file unity.c.}\par
}
{\xe \v UnityStrIgnore\:unity.c}
{\xe \v unity.c\:UnityStrIgnore}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b UNITY_PROGMEM} UnityStrIgnore[] = "IGNORE"}}
\par
{\bkmkstart AAAAAAAAHM}
{\bkmkend AAAAAAAAHM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 35 of file unity.c.}\par
}
{\xe \v UnityStrOk\:unity.c}
{\xe \v unity.c\:UnityStrOk}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b UNITY_PROGMEM} UnityStrOk[] = "OK"}}
\par
{\bkmkstart AAAAAAAAHN}
{\bkmkend AAAAAAAAHN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 32 of file unity.c.}\par
}
{\xe \v UnityStrPass\:unity.c}
{\xe \v unity.c\:UnityStrPass}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b UNITY_PROGMEM} UnityStrPass[] = "PASS"}}
\par
{\bkmkstart AAAAAAAAHO}
{\bkmkend AAAAAAAAHO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 33 of file unity.c.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
test/unity.h File Reference\par \pard\plain 
{\tc\tcl2 \v test/unity.h}
{\xe \v test/unity.h}
{\bkmkstart AAAAAAAAHP}
{\bkmkend AAAAAAAAHP}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "unity_internals.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for unity.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "unity_8h__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "unity_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_VERSION_MAJOR}\~ 2\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_VERSION_MINOR}\~ 6\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_VERSION_BUILD}\~ 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_VERSION}\~ (({\b UNITY_VERSION_MAJOR} << 16) | ({\b UNITY_VERSION_MINOR} << 8) | {\b UNITY_VERSION_BUILD})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_FAIL_MESSAGE}(message)\~ {\b UNITY_TEST_FAIL}(__LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_FAIL}()\~ {\b UNITY_TEST_FAIL}(__LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_IGNORE_MESSAGE}(message)\~ {\b UNITY_TEST_IGNORE}(__LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_IGNORE}()\~ {\b UNITY_TEST_IGNORE}(__LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_MESSAGE}(message)\~ {\b UnityMessage}((message), __LINE__)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ONLY}()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_PASS}()\~ {\b TEST_ABORT}()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_PASS_MESSAGE}(message)\~ do \{ {\b UnityMessage}((message), __LINE__); {\b TEST_ABORT}(); \} while (0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_SOURCE_FILE}(a)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_INCLUDE_PATH}(a)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT}(condition)\~ {\b UNITY_TEST_ASSERT}(       (condition), __LINE__, " Expression Evaluated To FALSE")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_TRUE}(condition)\~ {\b UNITY_TEST_ASSERT}(       (condition), __LINE__, " Expected TRUE Was FALSE")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_UNLESS}(condition)\~ {\b UNITY_TEST_ASSERT}(      !(condition), __LINE__, " Expression Evaluated To TRUE")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_FALSE}(condition)\~ {\b UNITY_TEST_ASSERT}(      !(condition), __LINE__, " Expected FALSE Was TRUE")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_NULL}(pointer)\~ {\b UNITY_TEST_ASSERT_NULL}(    (pointer), __LINE__, " Expected NULL")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_NOT_NULL}(pointer)\~ {\b UNITY_TEST_ASSERT_NOT_NULL}((pointer), __LINE__, " Expected Non-NULL")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EMPTY}(pointer)\~ {\b UNITY_TEST_ASSERT_EMPTY}(    (pointer), __LINE__, " Expected Empty")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_NOT_EMPTY}(pointer)\~ {\b UNITY_TEST_ASSERT_NOT_EMPTY}((pointer), __LINE__, " Expected Non-Empty")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_INT}(expected,  actual)\~ {\b UNITY_TEST_ASSERT_EQUAL_INT}((expected), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_INT8}(expected,  actual)\~ {\b UNITY_TEST_ASSERT_EQUAL_INT8}((expected), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_INT16}(expected,  actual)\~ {\b UNITY_TEST_ASSERT_EQUAL_INT16}((expected), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_INT32}(expected,  actual)\~ {\b UNITY_TEST_ASSERT_EQUAL_INT32}((expected), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_INT64}(expected,  actual)\~ {\b UNITY_TEST_ASSERT_EQUAL_INT64}((expected), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_UINT}(expected,  actual)\~ {\b UNITY_TEST_ASSERT_EQUAL_UINT}( (expected), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_UINT8}(expected,  actual)\~ {\b UNITY_TEST_ASSERT_EQUAL_UINT8}( (expected), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_UINT16}(expected,  actual)\~ {\b UNITY_TEST_ASSERT_EQUAL_UINT16}( (expected), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_UINT32}(expected,  actual)\~ {\b UNITY_TEST_ASSERT_EQUAL_UINT32}( (expected), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_UINT64}(expected,  actual)\~ {\b UNITY_TEST_ASSERT_EQUAL_UINT64}( (expected), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_size_t}(expected,  actual)\~ {\b UNITY_TEST_ASSERT_EQUAL_UINT}((expected), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_HEX}(expected,  actual)\~ {\b UNITY_TEST_ASSERT_EQUAL_HEX32}((expected), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_HEX8}(expected,  actual)\~ {\b UNITY_TEST_ASSERT_EQUAL_HEX8}( (expected), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_HEX16}(expected,  actual)\~ {\b UNITY_TEST_ASSERT_EQUAL_HEX16}((expected), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_HEX32}(expected,  actual)\~ {\b UNITY_TEST_ASSERT_EQUAL_HEX32}((expected), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_HEX64}(expected,  actual)\~ {\b UNITY_TEST_ASSERT_EQUAL_HEX64}((expected), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_CHAR}(expected,  actual)\~ {\b UNITY_TEST_ASSERT_EQUAL_CHAR}((expected), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_BITS}(mask,  expected,  actual)\~ {\b UNITY_TEST_ASSERT_BITS}((mask), (expected), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_BITS_HIGH}(mask,  actual)\~ {\b UNITY_TEST_ASSERT_BITS}((mask), ({\b UNITY_UINT})(-1), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_BITS_LOW}(mask,  actual)\~ {\b UNITY_TEST_ASSERT_BITS}((mask), ({\b UNITY_UINT})(0), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_BIT_HIGH}(bit,  actual)\~ {\b UNITY_TEST_ASSERT_BITS}((({\b UNITY_UINT})1 << (bit)), ({\b UNITY_UINT})(-1), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_BIT_LOW}(bit,  actual)\~ {\b UNITY_TEST_ASSERT_BITS}((({\b UNITY_UINT})1 << (bit)), ({\b UNITY_UINT})(0), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_NOT_EQUAL_INT}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_NOT_EQUAL_INT}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_NOT_EQUAL_INT8}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_NOT_EQUAL_INT8}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_NOT_EQUAL_INT16}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_NOT_EQUAL_INT16}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_NOT_EQUAL_INT32}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_NOT_EQUAL_INT32}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_NOT_EQUAL_INT64}(threshold,  actual)\~ UNITY_TEST_ASSERT_NOT_EQUAL_INT64((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_NOT_EQUAL_UINT}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_NOT_EQUAL_UINT}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_NOT_EQUAL_UINT8}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_NOT_EQUAL_UINT8}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_NOT_EQUAL_UINT16}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_NOT_EQUAL_UINT16}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_NOT_EQUAL_UINT32}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_NOT_EQUAL_UINT32}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_NOT_EQUAL_UINT64}(threshold,  actual)\~ UNITY_TEST_ASSERT_NOT_EQUAL_UINT64((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_NOT_EQUAL_size_t}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_NOT_EQUAL_UINT}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_NOT_EQUAL_HEX8}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_NOT_EQUAL_HEX8}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_NOT_EQUAL_HEX16}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_NOT_EQUAL_HEX16}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_NOT_EQUAL_HEX32}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_NOT_EQUAL_HEX32}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_NOT_EQUAL_HEX64}(threshold,  actual)\~ UNITY_TEST_ASSERT_NOT_EQUAL_HEX64((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_NOT_EQUAL_CHAR}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_NOT_EQUAL_CHAR}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_GREATER_THAN}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_GREATER_THAN_INT}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_GREATER_THAN_INT}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_GREATER_THAN_INT}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_GREATER_THAN_INT8}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_GREATER_THAN_INT8}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_GREATER_THAN_INT16}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_GREATER_THAN_INT16}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_GREATER_THAN_INT32}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_GREATER_THAN_INT32}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_GREATER_THAN_INT64}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_GREATER_THAN_INT64}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_GREATER_THAN_UINT}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_GREATER_THAN_UINT}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_GREATER_THAN_UINT8}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_GREATER_THAN_UINT8}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_GREATER_THAN_UINT16}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_GREATER_THAN_UINT16}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_GREATER_THAN_UINT32}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_GREATER_THAN_UINT32}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_GREATER_THAN_UINT64}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_GREATER_THAN_UINT64}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_GREATER_THAN_size_t}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_GREATER_THAN_UINT}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_GREATER_THAN_HEX8}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_GREATER_THAN_HEX8}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_GREATER_THAN_HEX16}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_GREATER_THAN_HEX16}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_GREATER_THAN_HEX32}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_GREATER_THAN_HEX32}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_GREATER_THAN_HEX64}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_GREATER_THAN_HEX64}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_GREATER_THAN_CHAR}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_GREATER_THAN_CHAR}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_LESS_THAN}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_SMALLER_THAN_INT}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_LESS_THAN_INT}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_SMALLER_THAN_INT}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_LESS_THAN_INT8}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_SMALLER_THAN_INT8}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_LESS_THAN_INT16}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_SMALLER_THAN_INT16}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_LESS_THAN_INT32}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_SMALLER_THAN_INT32}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_LESS_THAN_INT64}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_SMALLER_THAN_INT64}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_LESS_THAN_UINT}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_SMALLER_THAN_UINT}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_LESS_THAN_UINT8}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_SMALLER_THAN_UINT8}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_LESS_THAN_UINT16}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_SMALLER_THAN_UINT16}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_LESS_THAN_UINT32}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_SMALLER_THAN_UINT32}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_LESS_THAN_UINT64}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_SMALLER_THAN_UINT64}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_LESS_THAN_size_t}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_SMALLER_THAN_UINT}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_LESS_THAN_HEX8}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_SMALLER_THAN_HEX8}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_LESS_THAN_HEX16}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_SMALLER_THAN_HEX16}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_LESS_THAN_HEX32}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_SMALLER_THAN_HEX32}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_LESS_THAN_HEX64}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_SMALLER_THAN_HEX64}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_LESS_THAN_CHAR}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_SMALLER_THAN_CHAR}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_GREATER_OR_EQUAL}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_INT}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_GREATER_OR_EQUAL_INT}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_INT}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_GREATER_OR_EQUAL_INT8}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_INT8}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_GREATER_OR_EQUAL_INT16}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_INT16}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_GREATER_OR_EQUAL_INT32}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_INT32}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_GREATER_OR_EQUAL_INT64}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_INT64}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_GREATER_OR_EQUAL_UINT}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_UINT}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_GREATER_OR_EQUAL_UINT8}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_UINT8}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_GREATER_OR_EQUAL_UINT16}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_UINT16}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_GREATER_OR_EQUAL_UINT32}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_UINT32}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_GREATER_OR_EQUAL_UINT64}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_UINT64}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_GREATER_OR_EQUAL_size_t}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_UINT}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_GREATER_OR_EQUAL_HEX8}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_HEX8}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_GREATER_OR_EQUAL_HEX16}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_HEX16}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_GREATER_OR_EQUAL_HEX32}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_HEX32}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_GREATER_OR_EQUAL_HEX64}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_HEX64}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_GREATER_OR_EQUAL_CHAR}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_CHAR}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_LESS_OR_EQUAL}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_INT}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_LESS_OR_EQUAL_INT}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_INT}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_LESS_OR_EQUAL_INT8}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_INT8}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_LESS_OR_EQUAL_INT16}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_INT16}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_LESS_OR_EQUAL_INT32}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_INT32}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_LESS_OR_EQUAL_INT64}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_INT64}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_LESS_OR_EQUAL_UINT}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_UINT}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_LESS_OR_EQUAL_UINT8}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_UINT8}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_LESS_OR_EQUAL_UINT16}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_UINT16}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_LESS_OR_EQUAL_UINT32}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_UINT32}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_LESS_OR_EQUAL_UINT64}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_UINT64}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_LESS_OR_EQUAL_size_t}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_UINT}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_LESS_OR_EQUAL_HEX8}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_HEX8}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_LESS_OR_EQUAL_HEX16}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_HEX16}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_LESS_OR_EQUAL_HEX32}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_HEX32}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_LESS_OR_EQUAL_HEX64}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_HEX64}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_LESS_OR_EQUAL_CHAR}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_CHAR}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_INT_WITHIN}(delta,  expected,  actual)\~ {\b UNITY_TEST_ASSERT_INT_WITHIN}((delta), (expected), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_INT8_WITHIN}(delta,  expected,  actual)\~ {\b UNITY_TEST_ASSERT_INT8_WITHIN}((delta), (expected), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_INT16_WITHIN}(delta,  expected,  actual)\~ {\b UNITY_TEST_ASSERT_INT16_WITHIN}((delta), (expected), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_INT32_WITHIN}(delta,  expected,  actual)\~ {\b UNITY_TEST_ASSERT_INT32_WITHIN}((delta), (expected), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_INT64_WITHIN}(delta,  expected,  actual)\~ {\b UNITY_TEST_ASSERT_INT64_WITHIN}((delta), (expected), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_UINT_WITHIN}(delta,  expected,  actual)\~ {\b UNITY_TEST_ASSERT_UINT_WITHIN}((delta), (expected), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_UINT8_WITHIN}(delta,  expected,  actual)\~ {\b UNITY_TEST_ASSERT_UINT8_WITHIN}((delta), (expected), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_UINT16_WITHIN}(delta,  expected,  actual)\~ {\b UNITY_TEST_ASSERT_UINT16_WITHIN}((delta), (expected), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_UINT32_WITHIN}(delta,  expected,  actual)\~ {\b UNITY_TEST_ASSERT_UINT32_WITHIN}((delta), (expected), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_UINT64_WITHIN}(delta,  expected,  actual)\~ {\b UNITY_TEST_ASSERT_UINT64_WITHIN}((delta), (expected), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_size_t_WITHIN}(delta,  expected,  actual)\~ {\b UNITY_TEST_ASSERT_UINT_WITHIN}((delta), (expected), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_HEX_WITHIN}(delta,  expected,  actual)\~ {\b UNITY_TEST_ASSERT_HEX32_WITHIN}((delta), (expected), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_HEX8_WITHIN}(delta,  expected,  actual)\~ {\b UNITY_TEST_ASSERT_HEX8_WITHIN}((delta), (expected), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_HEX16_WITHIN}(delta,  expected,  actual)\~ {\b UNITY_TEST_ASSERT_HEX16_WITHIN}((delta), (expected), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_HEX32_WITHIN}(delta,  expected,  actual)\~ {\b UNITY_TEST_ASSERT_HEX32_WITHIN}((delta), (expected), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_HEX64_WITHIN}(delta,  expected,  actual)\~ {\b UNITY_TEST_ASSERT_HEX64_WITHIN}((delta), (expected), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_CHAR_WITHIN}(delta,  expected,  actual)\~ {\b UNITY_TEST_ASSERT_CHAR_WITHIN}((delta), (expected), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_INT_ARRAY_WITHIN}(delta,  expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_INT_ARRAY_WITHIN}((delta), (expected), (actual), num_elements, __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_INT8_ARRAY_WITHIN}(delta,  expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_INT8_ARRAY_WITHIN}((delta), (expected), (actual), num_elements, __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_INT16_ARRAY_WITHIN}(delta,  expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_INT16_ARRAY_WITHIN}((delta), (expected), (actual), num_elements, __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_INT32_ARRAY_WITHIN}(delta,  expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_INT32_ARRAY_WITHIN}((delta), (expected), (actual), num_elements, __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_INT64_ARRAY_WITHIN}(delta,  expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_INT64_ARRAY_WITHIN}((delta), (expected), (actual), num_elements, __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_UINT_ARRAY_WITHIN}(delta,  expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_UINT_ARRAY_WITHIN}((delta), (expected), (actual), num_elements, __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_UINT8_ARRAY_WITHIN}(delta,  expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_UINT8_ARRAY_WITHIN}((delta), (expected), (actual), num_elements, __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_UINT16_ARRAY_WITHIN}(delta,  expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_UINT16_ARRAY_WITHIN}((delta), (expected), (actual), num_elements, __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_UINT32_ARRAY_WITHIN}(delta,  expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_UINT32_ARRAY_WITHIN}((delta), (expected), (actual), num_elements, __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_UINT64_ARRAY_WITHIN}(delta,  expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_UINT64_ARRAY_WITHIN}((delta), (expected), (actual), num_elements, __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_size_t_ARRAY_WITHIN}(delta,  expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_UINT_ARRAY_WITHIN}((delta), (expected), (actual), num_elements, __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_HEX_ARRAY_WITHIN}(delta,  expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_HEX32_ARRAY_WITHIN}((delta), (expected), (actual), num_elements, __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_HEX8_ARRAY_WITHIN}(delta,  expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_HEX8_ARRAY_WITHIN}((delta), (expected), (actual), num_elements, __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_HEX16_ARRAY_WITHIN}(delta,  expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_HEX16_ARRAY_WITHIN}((delta), (expected), (actual), num_elements, __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_HEX32_ARRAY_WITHIN}(delta,  expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_HEX32_ARRAY_WITHIN}((delta), (expected), (actual), num_elements, __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_HEX64_ARRAY_WITHIN}(delta,  expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_HEX64_ARRAY_WITHIN}((delta), (expected), (actual), num_elements, __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_CHAR_ARRAY_WITHIN}(delta,  expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_CHAR_ARRAY_WITHIN}((delta), (expected), (actual), num_elements, __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_PTR}(expected,  actual)\~ {\b UNITY_TEST_ASSERT_EQUAL_PTR}((expected), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_STRING}(expected,  actual)\~ {\b UNITY_TEST_ASSERT_EQUAL_STRING}((expected), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_STRING_LEN}(expected,  actual,  len)\~ {\b UNITY_TEST_ASSERT_EQUAL_STRING_LEN}((expected), (actual), (len), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_MEMORY}(expected,  actual,  len)\~ {\b UNITY_TEST_ASSERT_EQUAL_MEMORY}((expected), (actual), (len), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_INT_ARRAY}(expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_EQUAL_INT_ARRAY}((expected), (actual), (num_elements), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_INT8_ARRAY}(expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_EQUAL_INT8_ARRAY}((expected), (actual), (num_elements), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_INT16_ARRAY}(expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_EQUAL_INT16_ARRAY}((expected), (actual), (num_elements), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_INT32_ARRAY}(expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_EQUAL_INT32_ARRAY}((expected), (actual), (num_elements), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_INT64_ARRAY}(expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_EQUAL_INT64_ARRAY}((expected), (actual), (num_elements), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_UINT_ARRAY}(expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_EQUAL_UINT_ARRAY}((expected), (actual), (num_elements), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_UINT8_ARRAY}(expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_EQUAL_UINT8_ARRAY}((expected), (actual), (num_elements), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_UINT16_ARRAY}(expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_EQUAL_UINT16_ARRAY}((expected), (actual), (num_elements), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_UINT32_ARRAY}(expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_EQUAL_UINT32_ARRAY}((expected), (actual), (num_elements), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_UINT64_ARRAY}(expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_EQUAL_UINT64_ARRAY}((expected), (actual), (num_elements), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_size_t_ARRAY}(expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_EQUAL_UINT_ARRAY}((expected), (actual), (num_elements), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_HEX_ARRAY}(expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_EQUAL_HEX32_ARRAY}((expected), (actual), (num_elements), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_HEX8_ARRAY}(expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY}((expected), (actual), (num_elements), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_HEX16_ARRAY}(expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_EQUAL_HEX16_ARRAY}((expected), (actual), (num_elements), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_HEX32_ARRAY}(expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_EQUAL_HEX32_ARRAY}((expected), (actual), (num_elements), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_HEX64_ARRAY}(expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_EQUAL_HEX64_ARRAY}((expected), (actual), (num_elements), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_PTR_ARRAY}(expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_EQUAL_PTR_ARRAY}((expected), (actual), (num_elements), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_STRING_ARRAY}(expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_EQUAL_STRING_ARRAY}((expected), (actual), (num_elements), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_MEMORY_ARRAY}(expected,  actual,  len,  num_elements)\~ {\b UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY}((expected), (actual), (len), (num_elements), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_CHAR_ARRAY}(expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_EQUAL_CHAR_ARRAY}((expected), (actual), (num_elements), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EACH_EQUAL_INT}(expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_EACH_EQUAL_INT}((expected), (actual), (num_elements), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EACH_EQUAL_INT8}(expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_EACH_EQUAL_INT8}((expected), (actual), (num_elements), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EACH_EQUAL_INT16}(expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_EACH_EQUAL_INT16}((expected), (actual), (num_elements), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EACH_EQUAL_INT32}(expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_EACH_EQUAL_INT32}((expected), (actual), (num_elements), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EACH_EQUAL_INT64}(expected,  actual,  num_elements)\~ UNITY_TEST_ASSERT_EACH_EQUAL_INT64((expected), (actual), (num_elements), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EACH_EQUAL_UINT}(expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_EACH_EQUAL_UINT}((expected), (actual), (num_elements), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EACH_EQUAL_UINT8}(expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_EACH_EQUAL_UINT8}((expected), (actual), (num_elements), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EACH_EQUAL_UINT16}(expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_EACH_EQUAL_UINT16}((expected), (actual), (num_elements), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EACH_EQUAL_UINT32}(expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_EACH_EQUAL_UINT32}((expected), (actual), (num_elements), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EACH_EQUAL_UINT64}(expected,  actual,  num_elements)\~ UNITY_TEST_ASSERT_EACH_EQUAL_UINT64((expected), (actual), (num_elements), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EACH_EQUAL_size_t}(expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_EACH_EQUAL_UINT}((expected), (actual), (num_elements), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EACH_EQUAL_HEX}(expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_EACH_EQUAL_HEX32}((expected), (actual), (num_elements), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EACH_EQUAL_HEX8}(expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_EACH_EQUAL_HEX8}((expected), (actual), (num_elements), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EACH_EQUAL_HEX16}(expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_EACH_EQUAL_HEX16}((expected), (actual), (num_elements), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EACH_EQUAL_HEX32}(expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_EACH_EQUAL_HEX32}((expected), (actual), (num_elements), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EACH_EQUAL_HEX64}(expected,  actual,  num_elements)\~ UNITY_TEST_ASSERT_EACH_EQUAL_HEX64((expected), (actual), (num_elements), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EACH_EQUAL_PTR}(expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_EACH_EQUAL_PTR}((expected), (actual), (num_elements), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EACH_EQUAL_STRING}(expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_EACH_EQUAL_STRING}((expected), (actual), (num_elements), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EACH_EQUAL_MEMORY}(expected,  actual,  len,  num_elements)\~ {\b UNITY_TEST_ASSERT_EACH_EQUAL_MEMORY}((expected), (actual), (len), (num_elements), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EACH_EQUAL_CHAR}(expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_EACH_EQUAL_CHAR}((expected), (actual), (num_elements), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_FLOAT_WITHIN}(delta,  expected,  actual)\~ {\b UNITY_TEST_ASSERT_FLOAT_WITHIN}((delta), (expected), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_FLOAT_NOT_WITHIN}(delta,  expected,  actual)\~ {\b UNITY_TEST_ASSERT_FLOAT_NOT_WITHIN}((delta), (expected), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_FLOAT}(expected,  actual)\~ {\b UNITY_TEST_ASSERT_EQUAL_FLOAT}((expected), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_NOT_EQUAL_FLOAT}(expected,  actual)\~ {\b UNITY_TEST_ASSERT_NOT_EQUAL_FLOAT}((expected), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_FLOAT_ARRAY_WITHIN}(delta,  expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_FLOAT_ARRAY_WITHIN}((delta), (expected), (actual), (num_elements), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_FLOAT_ARRAY}(expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_EQUAL_FLOAT_ARRAY}((expected), (actual), (num_elements), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EACH_EQUAL_FLOAT}(expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_EACH_EQUAL_FLOAT}((expected), (actual), (num_elements), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_GREATER_THAN_FLOAT}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_GREATER_THAN_FLOAT}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_GREATER_OR_EQUAL_FLOAT}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_FLOAT}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_LESS_THAN_FLOAT}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_LESS_THAN_FLOAT}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_LESS_OR_EQUAL_FLOAT}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_LESS_OR_EQUAL_FLOAT}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_FLOAT_IS_INF}(actual)\~ {\b UNITY_TEST_ASSERT_FLOAT_IS_INF}((actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_FLOAT_IS_NEG_INF}(actual)\~ {\b UNITY_TEST_ASSERT_FLOAT_IS_NEG_INF}((actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_FLOAT_IS_NAN}(actual)\~ {\b UNITY_TEST_ASSERT_FLOAT_IS_NAN}((actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_FLOAT_IS_DETERMINATE}(actual)\~ {\b UNITY_TEST_ASSERT_FLOAT_IS_DETERMINATE}((actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_FLOAT_IS_NOT_INF}(actual)\~ {\b UNITY_TEST_ASSERT_FLOAT_IS_NOT_INF}((actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_FLOAT_IS_NOT_NEG_INF}(actual)\~ {\b UNITY_TEST_ASSERT_FLOAT_IS_NOT_NEG_INF}((actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_FLOAT_IS_NOT_NAN}(actual)\~ {\b UNITY_TEST_ASSERT_FLOAT_IS_NOT_NAN}((actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_FLOAT_IS_NOT_DETERMINATE}(actual)\~ {\b UNITY_TEST_ASSERT_FLOAT_IS_NOT_DETERMINATE}((actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_DOUBLE_WITHIN}(delta,  expected,  actual)\~ {\b UNITY_TEST_ASSERT_DOUBLE_WITHIN}((delta), (expected), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_DOUBLE_NOT_WITHIN}(delta,  expected,  actual)\~ {\b UNITY_TEST_ASSERT_DOUBLE_NOT_WITHIN}((delta), (expected), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_DOUBLE}(expected,  actual)\~ {\b UNITY_TEST_ASSERT_EQUAL_DOUBLE}((expected), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_NOT_EQUAL_DOUBLE}(expected,  actual)\~ {\b UNITY_TEST_ASSERT_NOT_EQUAL_DOUBLE}((expected), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_DOUBLE_ARRAY_WITHIN}(delta,  expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_DOUBLE_ARRAY_WITHIN}((delta), (expected), (actual), (num_elements), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_DOUBLE_ARRAY}(expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_EQUAL_DOUBLE_ARRAY}((expected), (actual), (num_elements), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EACH_EQUAL_DOUBLE}(expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_EACH_EQUAL_DOUBLE}((expected), (actual), (num_elements), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_GREATER_THAN_DOUBLE}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_GREATER_THAN_DOUBLE}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_GREATER_OR_EQUAL_DOUBLE}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_DOUBLE}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_LESS_THAN_DOUBLE}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_LESS_THAN_DOUBLE}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_LESS_OR_EQUAL_DOUBLE}(threshold,  actual)\~ {\b UNITY_TEST_ASSERT_LESS_OR_EQUAL_DOUBLE}((threshold), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_DOUBLE_IS_INF}(actual)\~ {\b UNITY_TEST_ASSERT_DOUBLE_IS_INF}((actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_DOUBLE_IS_NEG_INF}(actual)\~ {\b UNITY_TEST_ASSERT_DOUBLE_IS_NEG_INF}((actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_DOUBLE_IS_NAN}(actual)\~ {\b UNITY_TEST_ASSERT_DOUBLE_IS_NAN}((actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_DOUBLE_IS_DETERMINATE}(actual)\~ {\b UNITY_TEST_ASSERT_DOUBLE_IS_DETERMINATE}((actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_DOUBLE_IS_NOT_INF}(actual)\~ {\b UNITY_TEST_ASSERT_DOUBLE_IS_NOT_INF}((actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_DOUBLE_IS_NOT_NEG_INF}(actual)\~ {\b UNITY_TEST_ASSERT_DOUBLE_IS_NOT_NEG_INF}((actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_DOUBLE_IS_NOT_NAN}(actual)\~ {\b UNITY_TEST_ASSERT_DOUBLE_IS_NOT_NAN}((actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_DOUBLE_IS_NOT_DETERMINATE}(actual)\~ {\b UNITY_TEST_ASSERT_DOUBLE_IS_NOT_DETERMINATE}((actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL}(expected,  actual)\~ {\b UNITY_TEST_ASSERT_EQUAL_INT}((expected), (actual), __LINE__, NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_NOT_EQUAL}(expected,  actual)\~ {\b UNITY_TEST_ASSERT}(((expected) != (actual)), __LINE__, " Expected Not-Equal")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_MESSAGE}(condition,  message)\~ {\b UNITY_TEST_ASSERT}(       (condition), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_TRUE_MESSAGE}(condition,  message)\~ {\b UNITY_TEST_ASSERT}(       (condition), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_UNLESS_MESSAGE}(condition,  message)\~ {\b UNITY_TEST_ASSERT}(      !(condition), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_FALSE_MESSAGE}(condition,  message)\~ {\b UNITY_TEST_ASSERT}(      !(condition), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_NULL_MESSAGE}(pointer,  message)\~ {\b UNITY_TEST_ASSERT_NULL}(    (pointer), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_NOT_NULL_MESSAGE}(pointer,  message)\~ {\b UNITY_TEST_ASSERT_NOT_NULL}((pointer), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EMPTY_MESSAGE}(pointer,  message)\~ {\b UNITY_TEST_ASSERT_EMPTY}(    (pointer), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_NOT_EMPTY_MESSAGE}(pointer,  message)\~ {\b UNITY_TEST_ASSERT_NOT_EMPTY}((pointer), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_INT_MESSAGE}(expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_INT}((expected), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_INT8_MESSAGE}(expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_INT8}((expected), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_INT16_MESSAGE}(expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_INT16}((expected), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_INT32_MESSAGE}(expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_INT32}((expected), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_INT64_MESSAGE}(expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_INT64}((expected), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_UINT_MESSAGE}(expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_UINT}( (expected), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_UINT8_MESSAGE}(expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_UINT8}( (expected), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_UINT16_MESSAGE}(expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_UINT16}( (expected), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_UINT32_MESSAGE}(expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_UINT32}( (expected), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_UINT64_MESSAGE}(expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_UINT64}( (expected), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_size_t_MESSAGE}(expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_UINT}( (expected), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_HEX_MESSAGE}(expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_HEX32}((expected), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_HEX8_MESSAGE}(expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_HEX8}( (expected), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_HEX16_MESSAGE}(expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_HEX16}((expected), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_HEX32_MESSAGE}(expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_HEX32}((expected), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_HEX64_MESSAGE}(expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_HEX64}((expected), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_BITS_MESSAGE}(mask,  expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_BITS}((mask), (expected), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_BITS_HIGH_MESSAGE}(mask,  actual,  message)\~ {\b UNITY_TEST_ASSERT_BITS}((mask), ({\b UNITY_UINT32})(-1), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_BITS_LOW_MESSAGE}(mask,  actual,  message)\~ {\b UNITY_TEST_ASSERT_BITS}((mask), ({\b UNITY_UINT32})(0), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_BIT_HIGH_MESSAGE}(bit,  actual,  message)\~ {\b UNITY_TEST_ASSERT_BITS}((({\b UNITY_UINT32})1 << (bit)), ({\b UNITY_UINT32})(-1), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_BIT_LOW_MESSAGE}(bit,  actual,  message)\~ {\b UNITY_TEST_ASSERT_BITS}((({\b UNITY_UINT32})1 << (bit)), ({\b UNITY_UINT32})(0), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_CHAR_MESSAGE}(expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_CHAR}((expected), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_NOT_EQUAL_INT_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_NOT_EQUAL_INT}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_NOT_EQUAL_INT8_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_NOT_EQUAL_INT8}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_NOT_EQUAL_INT16_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_NOT_EQUAL_INT16}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_NOT_EQUAL_INT32_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_NOT_EQUAL_INT32}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_NOT_EQUAL_INT64_MESSAGE}(threshold,  actual,  message)\~ UNITY_TEST_ASSERT_NOT_EQUAL_INT64((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_NOT_EQUAL_UINT_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_NOT_EQUAL_UINT}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_NOT_EQUAL_UINT8_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_NOT_EQUAL_UINT8}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_NOT_EQUAL_UINT16_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_NOT_EQUAL_UINT16}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_NOT_EQUAL_UINT32_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_NOT_EQUAL_UINT32}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_NOT_EQUAL_UINT64_MESSAGE}(threshold,  actual,  message)\~ UNITY_TEST_ASSERT_NOT_EQUAL_UINT64((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_NOT_EQUAL_size_t_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_NOT_EQUAL_UINT}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_NOT_EQUAL_HEX8_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_NOT_EQUAL_HEX8}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_NOT_EQUAL_HEX16_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_NOT_EQUAL_HEX16}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_NOT_EQUAL_HEX32_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_NOT_EQUAL_HEX32}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_NOT_EQUAL_HEX64_MESSAGE}(threshold,  actual,  message)\~ UNITY_TEST_ASSERT_NOT_EQUAL_HEX64((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_NOT_EQUAL_CHAR_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_NOT_EQUAL_CHAR}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_GREATER_THAN_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_GREATER_THAN_INT}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_GREATER_THAN_INT_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_GREATER_THAN_INT}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_GREATER_THAN_INT8_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_GREATER_THAN_INT8}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_GREATER_THAN_INT16_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_GREATER_THAN_INT16}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_GREATER_THAN_INT32_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_GREATER_THAN_INT32}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_GREATER_THAN_INT64_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_GREATER_THAN_INT64}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_GREATER_THAN_UINT_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_GREATER_THAN_UINT}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_GREATER_THAN_UINT8_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_GREATER_THAN_UINT8}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_GREATER_THAN_UINT16_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_GREATER_THAN_UINT16}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_GREATER_THAN_UINT32_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_GREATER_THAN_UINT32}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_GREATER_THAN_UINT64_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_GREATER_THAN_UINT64}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_GREATER_THAN_size_t_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_GREATER_THAN_UINT}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_GREATER_THAN_HEX8_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_GREATER_THAN_HEX8}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_GREATER_THAN_HEX16_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_GREATER_THAN_HEX16}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_GREATER_THAN_HEX32_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_GREATER_THAN_HEX32}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_GREATER_THAN_HEX64_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_GREATER_THAN_HEX64}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_GREATER_THAN_CHAR_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_GREATER_THAN_CHAR}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_LESS_THAN_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_SMALLER_THAN_INT}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_LESS_THAN_INT_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_SMALLER_THAN_INT}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_LESS_THAN_INT8_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_SMALLER_THAN_INT8}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_LESS_THAN_INT16_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_SMALLER_THAN_INT16}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_LESS_THAN_INT32_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_SMALLER_THAN_INT32}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_LESS_THAN_INT64_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_SMALLER_THAN_INT64}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_LESS_THAN_UINT_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_SMALLER_THAN_UINT}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_LESS_THAN_UINT8_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_SMALLER_THAN_UINT8}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_LESS_THAN_UINT16_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_SMALLER_THAN_UINT16}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_LESS_THAN_UINT32_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_SMALLER_THAN_UINT32}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_LESS_THAN_UINT64_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_SMALLER_THAN_UINT64}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_LESS_THAN_size_t_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_SMALLER_THAN_UINT}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_LESS_THAN_HEX8_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_SMALLER_THAN_HEX8}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_LESS_THAN_HEX16_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_SMALLER_THAN_HEX16}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_LESS_THAN_HEX32_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_SMALLER_THAN_HEX32}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_LESS_THAN_HEX64_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_SMALLER_THAN_HEX64}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_LESS_THAN_CHAR_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_SMALLER_THAN_CHAR}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_GREATER_OR_EQUAL_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_INT}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_GREATER_OR_EQUAL_INT_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_INT}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_GREATER_OR_EQUAL_INT8_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_INT8}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_GREATER_OR_EQUAL_INT16_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_INT16}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_GREATER_OR_EQUAL_INT32_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_INT32}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_GREATER_OR_EQUAL_INT64_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_INT64}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_GREATER_OR_EQUAL_UINT_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_UINT}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_GREATER_OR_EQUAL_UINT8_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_UINT8}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_GREATER_OR_EQUAL_UINT16_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_UINT16}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_GREATER_OR_EQUAL_UINT32_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_UINT32}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_GREATER_OR_EQUAL_UINT64_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_UINT64}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_GREATER_OR_EQUAL_size_t_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_UINT}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_GREATER_OR_EQUAL_HEX8_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_HEX8}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_GREATER_OR_EQUAL_HEX16_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_HEX16}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_GREATER_OR_EQUAL_HEX32_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_HEX32}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_GREATER_OR_EQUAL_HEX64_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_HEX64}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_GREATER_OR_EQUAL_CHAR_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_CHAR}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_LESS_OR_EQUAL_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_INT}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_LESS_OR_EQUAL_INT_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_INT}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_LESS_OR_EQUAL_INT8_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_INT8}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_LESS_OR_EQUAL_INT16_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_INT16}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_LESS_OR_EQUAL_INT32_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_INT32}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_LESS_OR_EQUAL_INT64_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_INT64}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_LESS_OR_EQUAL_UINT_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_UINT}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_LESS_OR_EQUAL_UINT8_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_UINT8}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_LESS_OR_EQUAL_UINT16_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_UINT16}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_LESS_OR_EQUAL_UINT32_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_UINT32}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_LESS_OR_EQUAL_UINT64_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_UINT64}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_LESS_OR_EQUAL_size_t_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_UINT}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_LESS_OR_EQUAL_HEX8_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_HEX8}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_LESS_OR_EQUAL_HEX16_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_HEX16}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_LESS_OR_EQUAL_HEX32_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_HEX32}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_LESS_OR_EQUAL_HEX64_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_HEX64}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_LESS_OR_EQUAL_CHAR_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_CHAR}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_INT_WITHIN_MESSAGE}(delta,  expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_INT_WITHIN}((delta), (expected), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_INT8_WITHIN_MESSAGE}(delta,  expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_INT8_WITHIN}((delta), (expected), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_INT16_WITHIN_MESSAGE}(delta,  expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_INT16_WITHIN}((delta), (expected), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_INT32_WITHIN_MESSAGE}(delta,  expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_INT32_WITHIN}((delta), (expected), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_INT64_WITHIN_MESSAGE}(delta,  expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_INT64_WITHIN}((delta), (expected), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_UINT_WITHIN_MESSAGE}(delta,  expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_UINT_WITHIN}((delta), (expected), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_UINT8_WITHIN_MESSAGE}(delta,  expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_UINT8_WITHIN}((delta), (expected), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_UINT16_WITHIN_MESSAGE}(delta,  expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_UINT16_WITHIN}((delta), (expected), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_UINT32_WITHIN_MESSAGE}(delta,  expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_UINT32_WITHIN}((delta), (expected), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_UINT64_WITHIN_MESSAGE}(delta,  expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_UINT64_WITHIN}((delta), (expected), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_size_t_WITHIN_MESSAGE}(delta,  expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_UINT_WITHIN}((delta), (expected), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_HEX_WITHIN_MESSAGE}(delta,  expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_HEX32_WITHIN}((delta), (expected), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_HEX8_WITHIN_MESSAGE}(delta,  expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_HEX8_WITHIN}((delta), (expected), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_HEX16_WITHIN_MESSAGE}(delta,  expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_HEX16_WITHIN}((delta), (expected), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_HEX32_WITHIN_MESSAGE}(delta,  expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_HEX32_WITHIN}((delta), (expected), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_HEX64_WITHIN_MESSAGE}(delta,  expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_HEX64_WITHIN}((delta), (expected), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_CHAR_WITHIN_MESSAGE}(delta,  expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_CHAR_WITHIN}((delta), (expected), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_INT_ARRAY_WITHIN_MESSAGE}(delta,  expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_INT_ARRAY_WITHIN}((delta), (expected), (actual), num_elements, __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_INT8_ARRAY_WITHIN_MESSAGE}(delta,  expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_INT8_ARRAY_WITHIN}((delta), (expected), (actual), num_elements, __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_INT16_ARRAY_WITHIN_MESSAGE}(delta,  expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_INT16_ARRAY_WITHIN}((delta), (expected), (actual), num_elements, __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_INT32_ARRAY_WITHIN_MESSAGE}(delta,  expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_INT32_ARRAY_WITHIN}((delta), (expected), (actual), num_elements, __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_INT64_ARRAY_WITHIN_MESSAGE}(delta,  expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_INT64_ARRAY_WITHIN}((delta), (expected), (actual), num_elements, __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_UINT_ARRAY_WITHIN_MESSAGE}(delta,  expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_UINT_ARRAY_WITHIN}((delta), (expected), (actual), num_elements, __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_UINT8_ARRAY_WITHIN_MESSAGE}(delta,  expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_UINT8_ARRAY_WITHIN}((delta), (expected), (actual), num_elements, __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_UINT16_ARRAY_WITHIN_MESSAGE}(delta,  expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_UINT16_ARRAY_WITHIN}((delta), (expected), (actual), num_elements, __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_UINT32_ARRAY_WITHIN_MESSAGE}(delta,  expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_UINT32_ARRAY_WITHIN}((delta), (expected), (actual), num_elements, __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_UINT64_ARRAY_WITHIN_MESSAGE}(delta,  expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_UINT64_ARRAY_WITHIN}((delta), (expected), (actual), num_elements, __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_size_t_ARRAY_WITHIN_MESSAGE}(delta,  expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_UINT_ARRAY_WITHIN}((delta), (expected), (actual), num_elements, __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_HEX_ARRAY_WITHIN_MESSAGE}(delta,  expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_HEX32_ARRAY_WITHIN}((delta), (expected), (actual), num_elements, __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_HEX8_ARRAY_WITHIN_MESSAGE}(delta,  expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_HEX8_ARRAY_WITHIN}((delta), (expected), (actual), num_elements, __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_HEX16_ARRAY_WITHIN_MESSAGE}(delta,  expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_HEX16_ARRAY_WITHIN}((delta), (expected), (actual), num_elements, __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_HEX32_ARRAY_WITHIN_MESSAGE}(delta,  expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_HEX32_ARRAY_WITHIN}((delta), (expected), (actual), num_elements, __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_HEX64_ARRAY_WITHIN_MESSAGE}(delta,  expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_HEX64_ARRAY_WITHIN}((delta), (expected), (actual), num_elements, __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_CHAR_ARRAY_WITHIN_MESSAGE}(delta,  expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_CHAR_ARRAY_WITHIN}((delta), (expected), (actual), num_elements, __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_PTR_MESSAGE}(expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_PTR}((expected), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_STRING_MESSAGE}(expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_STRING}((expected), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_STRING_LEN_MESSAGE}(expected,  actual,  len,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_STRING_LEN}((expected), (actual), (len), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_MEMORY_MESSAGE}(expected,  actual,  len,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_MEMORY}((expected), (actual), (len), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_INT_ARRAY_MESSAGE}(expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_INT_ARRAY}((expected), (actual), (num_elements), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_INT8_ARRAY_MESSAGE}(expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_INT8_ARRAY}((expected), (actual), (num_elements), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_INT16_ARRAY_MESSAGE}(expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_INT16_ARRAY}((expected), (actual), (num_elements), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_INT32_ARRAY_MESSAGE}(expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_INT32_ARRAY}((expected), (actual), (num_elements), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_INT64_ARRAY_MESSAGE}(expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_INT64_ARRAY}((expected), (actual), (num_elements), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_UINT_ARRAY_MESSAGE}(expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_UINT_ARRAY}((expected), (actual), (num_elements), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_UINT8_ARRAY_MESSAGE}(expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_UINT8_ARRAY}((expected), (actual), (num_elements), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_UINT16_ARRAY_MESSAGE}(expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_UINT16_ARRAY}((expected), (actual), (num_elements), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_UINT32_ARRAY_MESSAGE}(expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_UINT32_ARRAY}((expected), (actual), (num_elements), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_UINT64_ARRAY_MESSAGE}(expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_UINT64_ARRAY}((expected), (actual), (num_elements), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_size_t_ARRAY_MESSAGE}(expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_UINT_ARRAY}((expected), (actual), (num_elements), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_HEX_ARRAY_MESSAGE}(expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_HEX32_ARRAY}((expected), (actual), (num_elements), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_HEX8_ARRAY_MESSAGE}(expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY}((expected), (actual), (num_elements), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_HEX16_ARRAY_MESSAGE}(expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_HEX16_ARRAY}((expected), (actual), (num_elements), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_HEX32_ARRAY_MESSAGE}(expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_HEX32_ARRAY}((expected), (actual), (num_elements), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_HEX64_ARRAY_MESSAGE}(expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_HEX64_ARRAY}((expected), (actual), (num_elements), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_PTR_ARRAY_MESSAGE}(expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_PTR_ARRAY}((expected), (actual), (num_elements), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_STRING_ARRAY_MESSAGE}(expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_STRING_ARRAY}((expected), (actual), (num_elements), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_MEMORY_ARRAY_MESSAGE}(expected,  actual,  len,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY}((expected), (actual), (len), (num_elements), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_CHAR_ARRAY_MESSAGE}(expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_CHAR_ARRAY}((expected), (actual), (num_elements), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EACH_EQUAL_INT_MESSAGE}(expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EACH_EQUAL_INT}((expected), (actual), (num_elements), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EACH_EQUAL_INT8_MESSAGE}(expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EACH_EQUAL_INT8}((expected), (actual), (num_elements), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EACH_EQUAL_INT16_MESSAGE}(expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EACH_EQUAL_INT16}((expected), (actual), (num_elements), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EACH_EQUAL_INT32_MESSAGE}(expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EACH_EQUAL_INT32}((expected), (actual), (num_elements), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EACH_EQUAL_INT64_MESSAGE}(expected,  actual,  num_elements,  message)\~ UNITY_TEST_ASSERT_EACH_EQUAL_INT64((expected), (actual), (num_elements), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EACH_EQUAL_UINT_MESSAGE}(expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EACH_EQUAL_UINT}((expected), (actual), (num_elements), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EACH_EQUAL_UINT8_MESSAGE}(expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EACH_EQUAL_UINT8}((expected), (actual), (num_elements), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EACH_EQUAL_UINT16_MESSAGE}(expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EACH_EQUAL_UINT16}((expected), (actual), (num_elements), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EACH_EQUAL_UINT32_MESSAGE}(expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EACH_EQUAL_UINT32}((expected), (actual), (num_elements), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EACH_EQUAL_UINT64_MESSAGE}(expected,  actual,  num_elements,  message)\~ UNITY_TEST_ASSERT_EACH_EQUAL_UINT64((expected), (actual), (num_elements), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EACH_EQUAL_size_t_MESSAGE}(expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EACH_EQUAL_UINT}((expected), (actual), (num_elements), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EACH_EQUAL_HEX_MESSAGE}(expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EACH_EQUAL_HEX32}((expected), (actual), (num_elements), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EACH_EQUAL_HEX8_MESSAGE}(expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EACH_EQUAL_HEX8}((expected), (actual), (num_elements), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EACH_EQUAL_HEX16_MESSAGE}(expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EACH_EQUAL_HEX16}((expected), (actual), (num_elements), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EACH_EQUAL_HEX32_MESSAGE}(expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EACH_EQUAL_HEX32}((expected), (actual), (num_elements), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EACH_EQUAL_HEX64_MESSAGE}(expected,  actual,  num_elements,  message)\~ UNITY_TEST_ASSERT_EACH_EQUAL_HEX64((expected), (actual), (num_elements), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EACH_EQUAL_PTR_MESSAGE}(expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EACH_EQUAL_PTR}((expected), (actual), (num_elements), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EACH_EQUAL_STRING_MESSAGE}(expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EACH_EQUAL_STRING}((expected), (actual), (num_elements), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EACH_EQUAL_MEMORY_MESSAGE}(expected,  actual,  len,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EACH_EQUAL_MEMORY}((expected), (actual), (len), (num_elements), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EACH_EQUAL_CHAR_MESSAGE}(expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EACH_EQUAL_CHAR}((expected), (actual), (num_elements), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_FLOAT_WITHIN_MESSAGE}(delta,  expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_FLOAT_WITHIN}((delta), (expected), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_FLOAT_MESSAGE}(expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_FLOAT}((expected), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_NOT_EQUAL_FLOAT_MESSAGE}(expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_NOT_EQUAL_FLOAT}((expected), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_FLOAT_ARRAY_WITHIN_MESSAGE}(delta,  expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_FLOAT_ARRAY_WITHIN}((delta), (expected), (actual), (num_elements), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_FLOAT_ARRAY_MESSAGE}(expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_FLOAT_ARRAY}((expected), (actual), (num_elements), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EACH_EQUAL_FLOAT_MESSAGE}(expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EACH_EQUAL_FLOAT}((expected), (actual), (num_elements), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_GREATER_THAN_FLOAT_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_GREATER_THAN_FLOAT}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_GREATER_OR_EQUAL_FLOAT_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_FLOAT}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_LESS_THAN_FLOAT_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_LESS_THAN_FLOAT}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_LESS_OR_EQUAL_FLOAT_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_LESS_OR_EQUAL_FLOAT}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_FLOAT_IS_INF_MESSAGE}(actual,  message)\~ {\b UNITY_TEST_ASSERT_FLOAT_IS_INF}((actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_FLOAT_IS_NEG_INF_MESSAGE}(actual,  message)\~ {\b UNITY_TEST_ASSERT_FLOAT_IS_NEG_INF}((actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_FLOAT_IS_NAN_MESSAGE}(actual,  message)\~ {\b UNITY_TEST_ASSERT_FLOAT_IS_NAN}((actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_FLOAT_IS_DETERMINATE_MESSAGE}(actual,  message)\~ {\b UNITY_TEST_ASSERT_FLOAT_IS_DETERMINATE}((actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_FLOAT_IS_NOT_INF_MESSAGE}(actual,  message)\~ {\b UNITY_TEST_ASSERT_FLOAT_IS_NOT_INF}((actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_FLOAT_IS_NOT_NEG_INF_MESSAGE}(actual,  message)\~ {\b UNITY_TEST_ASSERT_FLOAT_IS_NOT_NEG_INF}((actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_FLOAT_IS_NOT_NAN_MESSAGE}(actual,  message)\~ {\b UNITY_TEST_ASSERT_FLOAT_IS_NOT_NAN}((actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_FLOAT_IS_NOT_DETERMINATE_MESSAGE}(actual,  message)\~ {\b UNITY_TEST_ASSERT_FLOAT_IS_NOT_DETERMINATE}((actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_DOUBLE_WITHIN_MESSAGE}(delta,  expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_DOUBLE_WITHIN}((delta), (expected), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_DOUBLE_MESSAGE}(expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_DOUBLE}((expected), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_NOT_EQUAL_DOUBLE_MESSAGE}(expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_NOT_EQUAL_DOUBLE}((expected), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_DOUBLE_ARRAY_WITHIN_MESSAGE}(delta,  expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_DOUBLE_ARRAY_WITHIN}((delta), (expected), (actual), (num_elements), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_DOUBLE_ARRAY_MESSAGE}(expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_DOUBLE_ARRAY}((expected), (actual), (num_elements), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EACH_EQUAL_DOUBLE_MESSAGE}(expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EACH_EQUAL_DOUBLE}((expected), (actual), (num_elements), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_GREATER_THAN_DOUBLE_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_GREATER_THAN_DOUBLE}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_GREATER_OR_EQUAL_DOUBLE_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_DOUBLE}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_LESS_THAN_DOUBLE_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_LESS_THAN_DOUBLE}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_LESS_OR_EQUAL_DOUBLE_MESSAGE}(threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_LESS_OR_EQUAL_DOUBLE}((threshold), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_DOUBLE_IS_INF_MESSAGE}(actual,  message)\~ {\b UNITY_TEST_ASSERT_DOUBLE_IS_INF}((actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_DOUBLE_IS_NEG_INF_MESSAGE}(actual,  message)\~ {\b UNITY_TEST_ASSERT_DOUBLE_IS_NEG_INF}((actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_DOUBLE_IS_NAN_MESSAGE}(actual,  message)\~ {\b UNITY_TEST_ASSERT_DOUBLE_IS_NAN}((actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_DOUBLE_IS_DETERMINATE_MESSAGE}(actual,  message)\~ {\b UNITY_TEST_ASSERT_DOUBLE_IS_DETERMINATE}((actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_DOUBLE_IS_NOT_INF_MESSAGE}(actual,  message)\~ {\b UNITY_TEST_ASSERT_DOUBLE_IS_NOT_INF}((actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_DOUBLE_IS_NOT_NEG_INF_MESSAGE}(actual,  message)\~ {\b UNITY_TEST_ASSERT_DOUBLE_IS_NOT_NEG_INF}((actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_DOUBLE_IS_NOT_NAN_MESSAGE}(actual,  message)\~ {\b UNITY_TEST_ASSERT_DOUBLE_IS_NOT_NAN}((actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_DOUBLE_IS_NOT_DETERMINATE_MESSAGE}(actual,  message)\~ {\b UNITY_TEST_ASSERT_DOUBLE_IS_NOT_DETERMINATE}((actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_EQUAL_MESSAGE}(expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_INT}((expected), (actual), __LINE__, (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ASSERT_NOT_EQUAL_MESSAGE}(expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT}(((expected) != (actual)), __LINE__, (message))\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setUp} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b tearDown} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b suiteSetUp} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b suiteTearDown} (int num_failures)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b resetTest} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b verifyTest} (void)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v TEST_ASSERT\:unity.h}
{\xe \v unity.h\:TEST_ASSERT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT( condition)\~ {\b UNITY_TEST_ASSERT}(       (condition), __LINE__, " Expression Evaluated To FALSE")}}
\par
{\bkmkstart AAAAAAAAHQ}
{\bkmkend AAAAAAAAHQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 136 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_BIT_HIGH\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_BIT_HIGH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_BIT_HIGH( bit,  actual)\~ {\b UNITY_TEST_ASSERT_BITS}((({\b UNITY_UINT})1 << (bit)), ({\b UNITY_UINT})(-1), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAHR}
{\bkmkend AAAAAAAAHR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 166 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_BIT_HIGH_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_BIT_HIGH_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_BIT_HIGH_MESSAGE( bit,  actual,  message)\~ {\b UNITY_TEST_ASSERT_BITS}((({\b UNITY_UINT32})1 << (bit)), ({\b UNITY_UINT32})(-1), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAHS}
{\bkmkend AAAAAAAAHS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 447 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_BIT_LOW\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_BIT_LOW}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_BIT_LOW( bit,  actual)\~ {\b UNITY_TEST_ASSERT_BITS}((({\b UNITY_UINT})1 << (bit)), ({\b UNITY_UINT})(0), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAHT}
{\bkmkend AAAAAAAAHT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 167 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_BIT_LOW_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_BIT_LOW_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_BIT_LOW_MESSAGE( bit,  actual,  message)\~ {\b UNITY_TEST_ASSERT_BITS}((({\b UNITY_UINT32})1 << (bit)), ({\b UNITY_UINT32})(0), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAHU}
{\bkmkend AAAAAAAAHU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 448 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_BITS\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_BITS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_BITS( mask,  expected,  actual)\~ {\b UNITY_TEST_ASSERT_BITS}((mask), (expected), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAHV}
{\bkmkend AAAAAAAAHV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 163 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_BITS_HIGH\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_BITS_HIGH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_BITS_HIGH( mask,  actual)\~ {\b UNITY_TEST_ASSERT_BITS}((mask), ({\b UNITY_UINT})(-1), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAHW}
{\bkmkend AAAAAAAAHW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 164 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_BITS_HIGH_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_BITS_HIGH_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_BITS_HIGH_MESSAGE( mask,  actual,  message)\~ {\b UNITY_TEST_ASSERT_BITS}((mask), ({\b UNITY_UINT32})(-1), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAHX}
{\bkmkend AAAAAAAAHX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 445 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_BITS_LOW\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_BITS_LOW}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_BITS_LOW( mask,  actual)\~ {\b UNITY_TEST_ASSERT_BITS}((mask), ({\b UNITY_UINT})(0), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAHY}
{\bkmkend AAAAAAAAHY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 165 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_BITS_LOW_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_BITS_LOW_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_BITS_LOW_MESSAGE( mask,  actual,  message)\~ {\b UNITY_TEST_ASSERT_BITS}((mask), ({\b UNITY_UINT32})(0), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAHZ}
{\bkmkend AAAAAAAAHZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 446 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_BITS_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_BITS_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_BITS_MESSAGE( mask,  expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_BITS}((mask), (expected), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAIA}
{\bkmkend AAAAAAAAIA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 444 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_CHAR_ARRAY_WITHIN\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_CHAR_ARRAY_WITHIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_CHAR_ARRAY_WITHIN( delta,  expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_CHAR_ARRAY_WITHIN}((delta), (expected), (actual), num_elements, __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAIB}
{\bkmkend AAAAAAAAIB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 296 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_CHAR_ARRAY_WITHIN_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_CHAR_ARRAY_WITHIN_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_CHAR_ARRAY_WITHIN_MESSAGE( delta,  expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_CHAR_ARRAY_WITHIN}((delta), (expected), (actual), num_elements, __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAIC}
{\bkmkend AAAAAAAAIC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 579 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_CHAR_WITHIN\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_CHAR_WITHIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_CHAR_WITHIN( delta,  expected,  actual)\~ {\b UNITY_TEST_ASSERT_CHAR_WITHIN}((delta), (expected), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAID}
{\bkmkend AAAAAAAAID}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 277 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_CHAR_WITHIN_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_CHAR_WITHIN_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_CHAR_WITHIN_MESSAGE( delta,  expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_CHAR_WITHIN}((delta), (expected), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAIE}
{\bkmkend AAAAAAAAIE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 560 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_DOUBLE_ARRAY_WITHIN\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_DOUBLE_ARRAY_WITHIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_DOUBLE_ARRAY_WITHIN( delta,  expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_DOUBLE_ARRAY_WITHIN}((delta), (expected), (actual), (num_elements), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAIF}
{\bkmkend AAAAAAAAIF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 375 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_DOUBLE_ARRAY_WITHIN_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_DOUBLE_ARRAY_WITHIN_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_DOUBLE_ARRAY_WITHIN_MESSAGE( delta,  expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_DOUBLE_ARRAY_WITHIN}((delta), (expected), (actual), (num_elements), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAIG}
{\bkmkend AAAAAAAAIG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 656 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_DOUBLE_IS_DETERMINATE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_DOUBLE_IS_DETERMINATE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_DOUBLE_IS_DETERMINATE( actual)\~ {\b UNITY_TEST_ASSERT_DOUBLE_IS_DETERMINATE}((actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAIH}
{\bkmkend AAAAAAAAIH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 385 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_DOUBLE_IS_DETERMINATE_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_DOUBLE_IS_DETERMINATE_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_DOUBLE_IS_DETERMINATE_MESSAGE( actual,  message)\~ {\b UNITY_TEST_ASSERT_DOUBLE_IS_DETERMINATE}((actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAII}
{\bkmkend AAAAAAAAII}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 666 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_DOUBLE_IS_INF\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_DOUBLE_IS_INF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_DOUBLE_IS_INF( actual)\~ {\b UNITY_TEST_ASSERT_DOUBLE_IS_INF}((actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAIJ}
{\bkmkend AAAAAAAAIJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 382 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_DOUBLE_IS_INF_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_DOUBLE_IS_INF_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_DOUBLE_IS_INF_MESSAGE( actual,  message)\~ {\b UNITY_TEST_ASSERT_DOUBLE_IS_INF}((actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAIK}
{\bkmkend AAAAAAAAIK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 663 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_DOUBLE_IS_NAN\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_DOUBLE_IS_NAN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_DOUBLE_IS_NAN( actual)\~ {\b UNITY_TEST_ASSERT_DOUBLE_IS_NAN}((actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAIL}
{\bkmkend AAAAAAAAIL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 384 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_DOUBLE_IS_NAN_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_DOUBLE_IS_NAN_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_DOUBLE_IS_NAN_MESSAGE( actual,  message)\~ {\b UNITY_TEST_ASSERT_DOUBLE_IS_NAN}((actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAIM}
{\bkmkend AAAAAAAAIM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 665 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_DOUBLE_IS_NEG_INF\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_DOUBLE_IS_NEG_INF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_DOUBLE_IS_NEG_INF( actual)\~ {\b UNITY_TEST_ASSERT_DOUBLE_IS_NEG_INF}((actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAIN}
{\bkmkend AAAAAAAAIN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 383 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_DOUBLE_IS_NEG_INF_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_DOUBLE_IS_NEG_INF_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_DOUBLE_IS_NEG_INF_MESSAGE( actual,  message)\~ {\b UNITY_TEST_ASSERT_DOUBLE_IS_NEG_INF}((actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAIO}
{\bkmkend AAAAAAAAIO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 664 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_DOUBLE_IS_NOT_DETERMINATE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_DOUBLE_IS_NOT_DETERMINATE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_DOUBLE_IS_NOT_DETERMINATE( actual)\~ {\b UNITY_TEST_ASSERT_DOUBLE_IS_NOT_DETERMINATE}((actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAIP}
{\bkmkend AAAAAAAAIP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 389 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_DOUBLE_IS_NOT_DETERMINATE_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_DOUBLE_IS_NOT_DETERMINATE_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_DOUBLE_IS_NOT_DETERMINATE_MESSAGE( actual,  message)\~ {\b UNITY_TEST_ASSERT_DOUBLE_IS_NOT_DETERMINATE}((actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAIQ}
{\bkmkend AAAAAAAAIQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 670 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_DOUBLE_IS_NOT_INF\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_DOUBLE_IS_NOT_INF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_DOUBLE_IS_NOT_INF( actual)\~ {\b UNITY_TEST_ASSERT_DOUBLE_IS_NOT_INF}((actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAIR}
{\bkmkend AAAAAAAAIR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 386 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_DOUBLE_IS_NOT_INF_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_DOUBLE_IS_NOT_INF_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_DOUBLE_IS_NOT_INF_MESSAGE( actual,  message)\~ {\b UNITY_TEST_ASSERT_DOUBLE_IS_NOT_INF}((actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAIS}
{\bkmkend AAAAAAAAIS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 667 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_DOUBLE_IS_NOT_NAN\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_DOUBLE_IS_NOT_NAN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_DOUBLE_IS_NOT_NAN( actual)\~ {\b UNITY_TEST_ASSERT_DOUBLE_IS_NOT_NAN}((actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAIT}
{\bkmkend AAAAAAAAIT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 388 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_DOUBLE_IS_NOT_NAN_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_DOUBLE_IS_NOT_NAN_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_DOUBLE_IS_NOT_NAN_MESSAGE( actual,  message)\~ {\b UNITY_TEST_ASSERT_DOUBLE_IS_NOT_NAN}((actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAIU}
{\bkmkend AAAAAAAAIU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 669 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_DOUBLE_IS_NOT_NEG_INF\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_DOUBLE_IS_NOT_NEG_INF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_DOUBLE_IS_NOT_NEG_INF( actual)\~ {\b UNITY_TEST_ASSERT_DOUBLE_IS_NOT_NEG_INF}((actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAIV}
{\bkmkend AAAAAAAAIV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 387 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_DOUBLE_IS_NOT_NEG_INF_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_DOUBLE_IS_NOT_NEG_INF_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_DOUBLE_IS_NOT_NEG_INF_MESSAGE( actual,  message)\~ {\b UNITY_TEST_ASSERT_DOUBLE_IS_NOT_NEG_INF}((actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAIW}
{\bkmkend AAAAAAAAIW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 668 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_DOUBLE_NOT_WITHIN\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_DOUBLE_NOT_WITHIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_DOUBLE_NOT_WITHIN( delta,  expected,  actual)\~ {\b UNITY_TEST_ASSERT_DOUBLE_NOT_WITHIN}((delta), (expected), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAIX}
{\bkmkend AAAAAAAAIX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 372 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_DOUBLE_WITHIN\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_DOUBLE_WITHIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_DOUBLE_WITHIN( delta,  expected,  actual)\~ {\b UNITY_TEST_ASSERT_DOUBLE_WITHIN}((delta), (expected), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAIY}
{\bkmkend AAAAAAAAIY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 371 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_DOUBLE_WITHIN_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_DOUBLE_WITHIN_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_DOUBLE_WITHIN_MESSAGE( delta,  expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_DOUBLE_WITHIN}((delta), (expected), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAIZ}
{\bkmkend AAAAAAAAIZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 653 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EACH_EQUAL_CHAR\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EACH_EQUAL_CHAR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EACH_EQUAL_CHAR( expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_EACH_EQUAL_CHAR}((expected), (actual), (num_elements), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAJA}
{\bkmkend AAAAAAAAJA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 347 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EACH_EQUAL_CHAR_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EACH_EQUAL_CHAR_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EACH_EQUAL_CHAR_MESSAGE( expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EACH_EQUAL_CHAR}((expected), (actual), (num_elements), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAJB}
{\bkmkend AAAAAAAAJB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 630 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EACH_EQUAL_DOUBLE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EACH_EQUAL_DOUBLE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EACH_EQUAL_DOUBLE( expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_EACH_EQUAL_DOUBLE}((expected), (actual), (num_elements), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAJC}
{\bkmkend AAAAAAAAJC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 377 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EACH_EQUAL_DOUBLE_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EACH_EQUAL_DOUBLE_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EACH_EQUAL_DOUBLE_MESSAGE( expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EACH_EQUAL_DOUBLE}((expected), (actual), (num_elements), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAJD}
{\bkmkend AAAAAAAAJD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 658 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EACH_EQUAL_FLOAT\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EACH_EQUAL_FLOAT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EACH_EQUAL_FLOAT( expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_EACH_EQUAL_FLOAT}((expected), (actual), (num_elements), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAJE}
{\bkmkend AAAAAAAAJE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 356 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EACH_EQUAL_FLOAT_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EACH_EQUAL_FLOAT_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EACH_EQUAL_FLOAT_MESSAGE( expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EACH_EQUAL_FLOAT}((expected), (actual), (num_elements), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAJF}
{\bkmkend AAAAAAAAJF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 638 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EACH_EQUAL_HEX\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EACH_EQUAL_HEX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EACH_EQUAL_HEX( expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_EACH_EQUAL_HEX32}((expected), (actual), (num_elements), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAJG}
{\bkmkend AAAAAAAAJG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 339 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EACH_EQUAL_HEX16\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EACH_EQUAL_HEX16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EACH_EQUAL_HEX16( expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_EACH_EQUAL_HEX16}((expected), (actual), (num_elements), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAJH}
{\bkmkend AAAAAAAAJH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 341 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EACH_EQUAL_HEX16_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EACH_EQUAL_HEX16_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EACH_EQUAL_HEX16_MESSAGE( expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EACH_EQUAL_HEX16}((expected), (actual), (num_elements), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAJI}
{\bkmkend AAAAAAAAJI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 624 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EACH_EQUAL_HEX32\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EACH_EQUAL_HEX32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EACH_EQUAL_HEX32( expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_EACH_EQUAL_HEX32}((expected), (actual), (num_elements), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAJJ}
{\bkmkend AAAAAAAAJJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 342 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EACH_EQUAL_HEX32_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EACH_EQUAL_HEX32_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EACH_EQUAL_HEX32_MESSAGE( expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EACH_EQUAL_HEX32}((expected), (actual), (num_elements), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAJK}
{\bkmkend AAAAAAAAJK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 625 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EACH_EQUAL_HEX64\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EACH_EQUAL_HEX64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EACH_EQUAL_HEX64( expected,  actual,  num_elements)\~ UNITY_TEST_ASSERT_EACH_EQUAL_HEX64((expected), (actual), (num_elements), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAJL}
{\bkmkend AAAAAAAAJL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 343 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EACH_EQUAL_HEX64_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EACH_EQUAL_HEX64_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EACH_EQUAL_HEX64_MESSAGE( expected,  actual,  num_elements,  message)\~ UNITY_TEST_ASSERT_EACH_EQUAL_HEX64((expected), (actual), (num_elements), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAJM}
{\bkmkend AAAAAAAAJM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 626 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EACH_EQUAL_HEX8\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EACH_EQUAL_HEX8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EACH_EQUAL_HEX8( expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_EACH_EQUAL_HEX8}((expected), (actual), (num_elements), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAJN}
{\bkmkend AAAAAAAAJN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 340 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EACH_EQUAL_HEX8_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EACH_EQUAL_HEX8_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EACH_EQUAL_HEX8_MESSAGE( expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EACH_EQUAL_HEX8}((expected), (actual), (num_elements), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAJO}
{\bkmkend AAAAAAAAJO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 623 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EACH_EQUAL_HEX_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EACH_EQUAL_HEX_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EACH_EQUAL_HEX_MESSAGE( expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EACH_EQUAL_HEX32}((expected), (actual), (num_elements), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAJP}
{\bkmkend AAAAAAAAJP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 622 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EACH_EQUAL_INT\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EACH_EQUAL_INT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EACH_EQUAL_INT( expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_EACH_EQUAL_INT}((expected), (actual), (num_elements), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAJQ}
{\bkmkend AAAAAAAAJQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 328 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EACH_EQUAL_INT16\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EACH_EQUAL_INT16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EACH_EQUAL_INT16( expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_EACH_EQUAL_INT16}((expected), (actual), (num_elements), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAJR}
{\bkmkend AAAAAAAAJR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 330 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EACH_EQUAL_INT16_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EACH_EQUAL_INT16_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EACH_EQUAL_INT16_MESSAGE( expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EACH_EQUAL_INT16}((expected), (actual), (num_elements), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAJS}
{\bkmkend AAAAAAAAJS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 613 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EACH_EQUAL_INT32\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EACH_EQUAL_INT32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EACH_EQUAL_INT32( expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_EACH_EQUAL_INT32}((expected), (actual), (num_elements), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAJT}
{\bkmkend AAAAAAAAJT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 331 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EACH_EQUAL_INT32_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EACH_EQUAL_INT32_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EACH_EQUAL_INT32_MESSAGE( expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EACH_EQUAL_INT32}((expected), (actual), (num_elements), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAJU}
{\bkmkend AAAAAAAAJU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 614 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EACH_EQUAL_INT64\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EACH_EQUAL_INT64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EACH_EQUAL_INT64( expected,  actual,  num_elements)\~ UNITY_TEST_ASSERT_EACH_EQUAL_INT64((expected), (actual), (num_elements), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAJV}
{\bkmkend AAAAAAAAJV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 332 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EACH_EQUAL_INT64_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EACH_EQUAL_INT64_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EACH_EQUAL_INT64_MESSAGE( expected,  actual,  num_elements,  message)\~ UNITY_TEST_ASSERT_EACH_EQUAL_INT64((expected), (actual), (num_elements), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAJW}
{\bkmkend AAAAAAAAJW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 615 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EACH_EQUAL_INT8\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EACH_EQUAL_INT8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EACH_EQUAL_INT8( expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_EACH_EQUAL_INT8}((expected), (actual), (num_elements), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAJX}
{\bkmkend AAAAAAAAJX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 329 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EACH_EQUAL_INT8_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EACH_EQUAL_INT8_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EACH_EQUAL_INT8_MESSAGE( expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EACH_EQUAL_INT8}((expected), (actual), (num_elements), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAJY}
{\bkmkend AAAAAAAAJY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 612 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EACH_EQUAL_INT_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EACH_EQUAL_INT_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EACH_EQUAL_INT_MESSAGE( expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EACH_EQUAL_INT}((expected), (actual), (num_elements), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAJZ}
{\bkmkend AAAAAAAAJZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 611 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EACH_EQUAL_MEMORY\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EACH_EQUAL_MEMORY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EACH_EQUAL_MEMORY( expected,  actual,  len,  num_elements)\~ {\b UNITY_TEST_ASSERT_EACH_EQUAL_MEMORY}((expected), (actual), (len), (num_elements), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAKA}
{\bkmkend AAAAAAAAKA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 346 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EACH_EQUAL_MEMORY_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EACH_EQUAL_MEMORY_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EACH_EQUAL_MEMORY_MESSAGE( expected,  actual,  len,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EACH_EQUAL_MEMORY}((expected), (actual), (len), (num_elements), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAKB}
{\bkmkend AAAAAAAAKB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 629 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EACH_EQUAL_PTR\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EACH_EQUAL_PTR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EACH_EQUAL_PTR( expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_EACH_EQUAL_PTR}((expected), (actual), (num_elements), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAKC}
{\bkmkend AAAAAAAAKC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 344 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EACH_EQUAL_PTR_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EACH_EQUAL_PTR_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EACH_EQUAL_PTR_MESSAGE( expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EACH_EQUAL_PTR}((expected), (actual), (num_elements), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAKD}
{\bkmkend AAAAAAAAKD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 627 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EACH_EQUAL_size_t\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EACH_EQUAL_size_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EACH_EQUAL_size_t( expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_EACH_EQUAL_UINT}((expected), (actual), (num_elements), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAKE}
{\bkmkend AAAAAAAAKE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 338 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EACH_EQUAL_size_t_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EACH_EQUAL_size_t_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EACH_EQUAL_size_t_MESSAGE( expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EACH_EQUAL_UINT}((expected), (actual), (num_elements), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAKF}
{\bkmkend AAAAAAAAKF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 621 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EACH_EQUAL_STRING\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EACH_EQUAL_STRING}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EACH_EQUAL_STRING( expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_EACH_EQUAL_STRING}((expected), (actual), (num_elements), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAKG}
{\bkmkend AAAAAAAAKG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 345 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EACH_EQUAL_STRING_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EACH_EQUAL_STRING_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EACH_EQUAL_STRING_MESSAGE( expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EACH_EQUAL_STRING}((expected), (actual), (num_elements), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAKH}
{\bkmkend AAAAAAAAKH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 628 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EACH_EQUAL_UINT\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EACH_EQUAL_UINT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EACH_EQUAL_UINT( expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_EACH_EQUAL_UINT}((expected), (actual), (num_elements), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAKI}
{\bkmkend AAAAAAAAKI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 333 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EACH_EQUAL_UINT16\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EACH_EQUAL_UINT16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EACH_EQUAL_UINT16( expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_EACH_EQUAL_UINT16}((expected), (actual), (num_elements), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAKJ}
{\bkmkend AAAAAAAAKJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 335 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EACH_EQUAL_UINT16_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EACH_EQUAL_UINT16_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EACH_EQUAL_UINT16_MESSAGE( expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EACH_EQUAL_UINT16}((expected), (actual), (num_elements), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAKK}
{\bkmkend AAAAAAAAKK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 618 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EACH_EQUAL_UINT32\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EACH_EQUAL_UINT32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EACH_EQUAL_UINT32( expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_EACH_EQUAL_UINT32}((expected), (actual), (num_elements), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAKL}
{\bkmkend AAAAAAAAKL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 336 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EACH_EQUAL_UINT32_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EACH_EQUAL_UINT32_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EACH_EQUAL_UINT32_MESSAGE( expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EACH_EQUAL_UINT32}((expected), (actual), (num_elements), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAKM}
{\bkmkend AAAAAAAAKM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 619 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EACH_EQUAL_UINT64\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EACH_EQUAL_UINT64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EACH_EQUAL_UINT64( expected,  actual,  num_elements)\~ UNITY_TEST_ASSERT_EACH_EQUAL_UINT64((expected), (actual), (num_elements), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAKN}
{\bkmkend AAAAAAAAKN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 337 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EACH_EQUAL_UINT64_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EACH_EQUAL_UINT64_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EACH_EQUAL_UINT64_MESSAGE( expected,  actual,  num_elements,  message)\~ UNITY_TEST_ASSERT_EACH_EQUAL_UINT64((expected), (actual), (num_elements), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAKO}
{\bkmkend AAAAAAAAKO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 620 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EACH_EQUAL_UINT8\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EACH_EQUAL_UINT8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EACH_EQUAL_UINT8( expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_EACH_EQUAL_UINT8}((expected), (actual), (num_elements), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAKP}
{\bkmkend AAAAAAAAKP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 334 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EACH_EQUAL_UINT8_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EACH_EQUAL_UINT8_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EACH_EQUAL_UINT8_MESSAGE( expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EACH_EQUAL_UINT8}((expected), (actual), (num_elements), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAKQ}
{\bkmkend AAAAAAAAKQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 617 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EACH_EQUAL_UINT_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EACH_EQUAL_UINT_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EACH_EQUAL_UINT_MESSAGE( expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EACH_EQUAL_UINT}((expected), (actual), (num_elements), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAKR}
{\bkmkend AAAAAAAAKR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 616 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EMPTY\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EMPTY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EMPTY( pointer)\~ {\b UNITY_TEST_ASSERT_EMPTY}(    (pointer), __LINE__, " Expected Empty")}}
\par
{\bkmkstart AAAAAAAAKS}
{\bkmkend AAAAAAAAKS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 142 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EMPTY_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EMPTY_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EMPTY_MESSAGE( pointer,  message)\~ {\b UNITY_TEST_ASSERT_EMPTY}(    (pointer), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAKT}
{\bkmkend AAAAAAAAKT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 424 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL( expected,  actual)\~ {\b UNITY_TEST_ASSERT_EQUAL_INT}((expected), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAKU}
{\bkmkend AAAAAAAAKU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 393 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_CHAR\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_CHAR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_CHAR( expected,  actual)\~ {\b UNITY_TEST_ASSERT_EQUAL_CHAR}((expected), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAKV}
{\bkmkend AAAAAAAAKV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 162 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_CHAR_ARRAY\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_CHAR_ARRAY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_CHAR_ARRAY( expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_EQUAL_CHAR_ARRAY}((expected), (actual), (num_elements), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAKW}
{\bkmkend AAAAAAAAKW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 325 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_CHAR_ARRAY_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_CHAR_ARRAY_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_CHAR_ARRAY_MESSAGE( expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_CHAR_ARRAY}((expected), (actual), (num_elements), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAKX}
{\bkmkend AAAAAAAAKX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 608 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_CHAR_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_CHAR_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_CHAR_MESSAGE( expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_CHAR}((expected), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAKY}
{\bkmkend AAAAAAAAKY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 449 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_DOUBLE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_DOUBLE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_DOUBLE( expected,  actual)\~ {\b UNITY_TEST_ASSERT_EQUAL_DOUBLE}((expected), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAKZ}
{\bkmkend AAAAAAAAKZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 373 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_DOUBLE_ARRAY\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_DOUBLE_ARRAY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_DOUBLE_ARRAY( expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_EQUAL_DOUBLE_ARRAY}((expected), (actual), (num_elements), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAALA}
{\bkmkend AAAAAAAALA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 376 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_DOUBLE_ARRAY_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_DOUBLE_ARRAY_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_DOUBLE_ARRAY_MESSAGE( expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_DOUBLE_ARRAY}((expected), (actual), (num_elements), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAALB}
{\bkmkend AAAAAAAALB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 657 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_DOUBLE_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_DOUBLE_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_DOUBLE_MESSAGE( expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_DOUBLE}((expected), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAALC}
{\bkmkend AAAAAAAALC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 654 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_FLOAT\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_FLOAT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_FLOAT( expected,  actual)\~ {\b UNITY_TEST_ASSERT_EQUAL_FLOAT}((expected), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAALD}
{\bkmkend AAAAAAAALD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 352 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_FLOAT_ARRAY\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_FLOAT_ARRAY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_FLOAT_ARRAY( expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_EQUAL_FLOAT_ARRAY}((expected), (actual), (num_elements), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAALE}
{\bkmkend AAAAAAAALE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 355 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_FLOAT_ARRAY_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_FLOAT_ARRAY_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_FLOAT_ARRAY_MESSAGE( expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_FLOAT_ARRAY}((expected), (actual), (num_elements), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAALF}
{\bkmkend AAAAAAAALF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 637 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_FLOAT_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_FLOAT_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_FLOAT_MESSAGE( expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_FLOAT}((expected), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAALG}
{\bkmkend AAAAAAAALG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 634 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_HEX\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_HEX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_HEX( expected,  actual)\~ {\b UNITY_TEST_ASSERT_EQUAL_HEX32}((expected), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAALH}
{\bkmkend AAAAAAAALH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 157 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_HEX16\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_HEX16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_HEX16( expected,  actual)\~ {\b UNITY_TEST_ASSERT_EQUAL_HEX16}((expected), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAALI}
{\bkmkend AAAAAAAALI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 159 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_HEX16_ARRAY\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_HEX16_ARRAY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_HEX16_ARRAY( expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_EQUAL_HEX16_ARRAY}((expected), (actual), (num_elements), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAALJ}
{\bkmkend AAAAAAAALJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 319 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_HEX16_ARRAY_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_HEX16_ARRAY_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_HEX16_ARRAY_MESSAGE( expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_HEX16_ARRAY}((expected), (actual), (num_elements), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAALK}
{\bkmkend AAAAAAAALK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 602 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_HEX16_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_HEX16_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_HEX16_MESSAGE( expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_HEX16}((expected), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAALL}
{\bkmkend AAAAAAAALL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 441 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_HEX32\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_HEX32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_HEX32( expected,  actual)\~ {\b UNITY_TEST_ASSERT_EQUAL_HEX32}((expected), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAALM}
{\bkmkend AAAAAAAALM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 160 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_HEX32_ARRAY\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_HEX32_ARRAY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_HEX32_ARRAY( expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_EQUAL_HEX32_ARRAY}((expected), (actual), (num_elements), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAALN}
{\bkmkend AAAAAAAALN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 320 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_HEX32_ARRAY_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_HEX32_ARRAY_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_HEX32_ARRAY_MESSAGE( expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_HEX32_ARRAY}((expected), (actual), (num_elements), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAALO}
{\bkmkend AAAAAAAALO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 603 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_HEX32_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_HEX32_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_HEX32_MESSAGE( expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_HEX32}((expected), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAALP}
{\bkmkend AAAAAAAALP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 442 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_HEX64\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_HEX64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_HEX64( expected,  actual)\~ {\b UNITY_TEST_ASSERT_EQUAL_HEX64}((expected), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAALQ}
{\bkmkend AAAAAAAALQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 161 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_HEX64_ARRAY\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_HEX64_ARRAY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_HEX64_ARRAY( expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_EQUAL_HEX64_ARRAY}((expected), (actual), (num_elements), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAALR}
{\bkmkend AAAAAAAALR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 321 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_HEX64_ARRAY_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_HEX64_ARRAY_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_HEX64_ARRAY_MESSAGE( expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_HEX64_ARRAY}((expected), (actual), (num_elements), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAALS}
{\bkmkend AAAAAAAALS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 604 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_HEX64_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_HEX64_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_HEX64_MESSAGE( expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_HEX64}((expected), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAALT}
{\bkmkend AAAAAAAALT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 443 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_HEX8\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_HEX8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_HEX8( expected,  actual)\~ {\b UNITY_TEST_ASSERT_EQUAL_HEX8}( (expected), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAALU}
{\bkmkend AAAAAAAALU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 158 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_HEX8_ARRAY\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_HEX8_ARRAY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_HEX8_ARRAY( expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY}((expected), (actual), (num_elements), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAALV}
{\bkmkend AAAAAAAALV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 318 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_HEX8_ARRAY_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_HEX8_ARRAY_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_HEX8_ARRAY_MESSAGE( expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY}((expected), (actual), (num_elements), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAALW}
{\bkmkend AAAAAAAALW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 601 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_HEX8_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_HEX8_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_HEX8_MESSAGE( expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_HEX8}( (expected), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAALX}
{\bkmkend AAAAAAAALX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 440 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_HEX_ARRAY\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_HEX_ARRAY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_HEX_ARRAY( expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_EQUAL_HEX32_ARRAY}((expected), (actual), (num_elements), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAALY}
{\bkmkend AAAAAAAALY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 317 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_HEX_ARRAY_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_HEX_ARRAY_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_HEX_ARRAY_MESSAGE( expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_HEX32_ARRAY}((expected), (actual), (num_elements), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAALZ}
{\bkmkend AAAAAAAALZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 600 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_HEX_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_HEX_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_HEX_MESSAGE( expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_HEX32}((expected), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAMA}
{\bkmkend AAAAAAAAMA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 439 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_INT\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_INT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_INT( expected,  actual)\~ {\b UNITY_TEST_ASSERT_EQUAL_INT}((expected), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAMB}
{\bkmkend AAAAAAAAMB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 146 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_INT16\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_INT16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_INT16( expected,  actual)\~ {\b UNITY_TEST_ASSERT_EQUAL_INT16}((expected), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAMC}
{\bkmkend AAAAAAAAMC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 148 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_INT16_ARRAY\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_INT16_ARRAY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_INT16_ARRAY( expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_EQUAL_INT16_ARRAY}((expected), (actual), (num_elements), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAMD}
{\bkmkend AAAAAAAAMD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 308 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_INT16_ARRAY_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_INT16_ARRAY_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_INT16_ARRAY_MESSAGE( expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_INT16_ARRAY}((expected), (actual), (num_elements), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAME}
{\bkmkend AAAAAAAAME}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 591 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_INT16_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_INT16_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_INT16_MESSAGE( expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_INT16}((expected), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAMF}
{\bkmkend AAAAAAAAMF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 430 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_INT32\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_INT32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_INT32( expected,  actual)\~ {\b UNITY_TEST_ASSERT_EQUAL_INT32}((expected), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAMG}
{\bkmkend AAAAAAAAMG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 149 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_INT32_ARRAY\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_INT32_ARRAY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_INT32_ARRAY( expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_EQUAL_INT32_ARRAY}((expected), (actual), (num_elements), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAMH}
{\bkmkend AAAAAAAAMH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 309 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_INT32_ARRAY_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_INT32_ARRAY_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_INT32_ARRAY_MESSAGE( expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_INT32_ARRAY}((expected), (actual), (num_elements), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAMI}
{\bkmkend AAAAAAAAMI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 592 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_INT32_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_INT32_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_INT32_MESSAGE( expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_INT32}((expected), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAMJ}
{\bkmkend AAAAAAAAMJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 431 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_INT64\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_INT64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_INT64( expected,  actual)\~ {\b UNITY_TEST_ASSERT_EQUAL_INT64}((expected), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAMK}
{\bkmkend AAAAAAAAMK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 150 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_INT64_ARRAY\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_INT64_ARRAY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_INT64_ARRAY( expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_EQUAL_INT64_ARRAY}((expected), (actual), (num_elements), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAML}
{\bkmkend AAAAAAAAML}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 310 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_INT64_ARRAY_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_INT64_ARRAY_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_INT64_ARRAY_MESSAGE( expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_INT64_ARRAY}((expected), (actual), (num_elements), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAMM}
{\bkmkend AAAAAAAAMM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 593 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_INT64_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_INT64_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_INT64_MESSAGE( expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_INT64}((expected), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAMN}
{\bkmkend AAAAAAAAMN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 432 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_INT8\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_INT8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_INT8( expected,  actual)\~ {\b UNITY_TEST_ASSERT_EQUAL_INT8}((expected), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAMO}
{\bkmkend AAAAAAAAMO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 147 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_INT8_ARRAY\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_INT8_ARRAY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_INT8_ARRAY( expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_EQUAL_INT8_ARRAY}((expected), (actual), (num_elements), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAMP}
{\bkmkend AAAAAAAAMP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 307 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_INT8_ARRAY_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_INT8_ARRAY_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_INT8_ARRAY_MESSAGE( expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_INT8_ARRAY}((expected), (actual), (num_elements), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAMQ}
{\bkmkend AAAAAAAAMQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 590 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_INT8_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_INT8_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_INT8_MESSAGE( expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_INT8}((expected), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAMR}
{\bkmkend AAAAAAAAMR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 429 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_INT_ARRAY\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_INT_ARRAY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_INT_ARRAY( expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_EQUAL_INT_ARRAY}((expected), (actual), (num_elements), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAMS}
{\bkmkend AAAAAAAAMS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 306 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_INT_ARRAY_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_INT_ARRAY_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_INT_ARRAY_MESSAGE( expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_INT_ARRAY}((expected), (actual), (num_elements), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAMT}
{\bkmkend AAAAAAAAMT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 589 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_INT_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_INT_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_INT_MESSAGE( expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_INT}((expected), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAMU}
{\bkmkend AAAAAAAAMU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 428 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_MEMORY\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_MEMORY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_MEMORY( expected,  actual,  len)\~ {\b UNITY_TEST_ASSERT_EQUAL_MEMORY}((expected), (actual), (len), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAMV}
{\bkmkend AAAAAAAAMV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 303 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_MEMORY_ARRAY\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_MEMORY_ARRAY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_MEMORY_ARRAY( expected,  actual,  len,  num_elements)\~ {\b UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY}((expected), (actual), (len), (num_elements), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAMW}
{\bkmkend AAAAAAAAMW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 324 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_MEMORY_ARRAY_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_MEMORY_ARRAY_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_MEMORY_ARRAY_MESSAGE( expected,  actual,  len,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY}((expected), (actual), (len), (num_elements), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAMX}
{\bkmkend AAAAAAAAMX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 607 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_MEMORY_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_MEMORY_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_MEMORY_MESSAGE( expected,  actual,  len,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_MEMORY}((expected), (actual), (len), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAMY}
{\bkmkend AAAAAAAAMY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 586 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_MESSAGE( expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_INT}((expected), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAMZ}
{\bkmkend AAAAAAAAMZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 674 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_PTR\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_PTR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_PTR( expected,  actual)\~ {\b UNITY_TEST_ASSERT_EQUAL_PTR}((expected), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAANA}
{\bkmkend AAAAAAAANA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 300 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_PTR_ARRAY\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_PTR_ARRAY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_PTR_ARRAY( expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_EQUAL_PTR_ARRAY}((expected), (actual), (num_elements), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAANB}
{\bkmkend AAAAAAAANB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 322 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_PTR_ARRAY_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_PTR_ARRAY_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_PTR_ARRAY_MESSAGE( expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_PTR_ARRAY}((expected), (actual), (num_elements), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAANC}
{\bkmkend AAAAAAAANC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 605 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_PTR_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_PTR_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_PTR_MESSAGE( expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_PTR}((expected), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAND}
{\bkmkend AAAAAAAAND}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 583 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_size_t\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_size_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_size_t( expected,  actual)\~ {\b UNITY_TEST_ASSERT_EQUAL_UINT}((expected), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAANE}
{\bkmkend AAAAAAAANE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 156 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_size_t_ARRAY\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_size_t_ARRAY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_size_t_ARRAY( expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_EQUAL_UINT_ARRAY}((expected), (actual), (num_elements), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAANF}
{\bkmkend AAAAAAAANF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 316 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_size_t_ARRAY_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_size_t_ARRAY_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_size_t_ARRAY_MESSAGE( expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_UINT_ARRAY}((expected), (actual), (num_elements), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAANG}
{\bkmkend AAAAAAAANG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 599 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_size_t_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_size_t_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_size_t_MESSAGE( expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_UINT}( (expected), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAANH}
{\bkmkend AAAAAAAANH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 438 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_STRING\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_STRING}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_STRING( expected,  actual)\~ {\b UNITY_TEST_ASSERT_EQUAL_STRING}((expected), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAANI}
{\bkmkend AAAAAAAANI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 301 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_STRING_ARRAY\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_STRING_ARRAY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_STRING_ARRAY( expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_EQUAL_STRING_ARRAY}((expected), (actual), (num_elements), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAANJ}
{\bkmkend AAAAAAAANJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 323 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_STRING_ARRAY_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_STRING_ARRAY_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_STRING_ARRAY_MESSAGE( expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_STRING_ARRAY}((expected), (actual), (num_elements), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAANK}
{\bkmkend AAAAAAAANK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 606 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_STRING_LEN\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_STRING_LEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_STRING_LEN( expected,  actual,  len)\~ {\b UNITY_TEST_ASSERT_EQUAL_STRING_LEN}((expected), (actual), (len), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAANL}
{\bkmkend AAAAAAAANL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 302 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_STRING_LEN_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_STRING_LEN_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_STRING_LEN_MESSAGE( expected,  actual,  len,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_STRING_LEN}((expected), (actual), (len), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAANM}
{\bkmkend AAAAAAAANM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 585 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_STRING_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_STRING_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_STRING_MESSAGE( expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_STRING}((expected), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAANN}
{\bkmkend AAAAAAAANN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 584 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_UINT\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_UINT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_UINT( expected,  actual)\~ {\b UNITY_TEST_ASSERT_EQUAL_UINT}( (expected), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAANO}
{\bkmkend AAAAAAAANO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 151 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_UINT16\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_UINT16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_UINT16( expected,  actual)\~ {\b UNITY_TEST_ASSERT_EQUAL_UINT16}( (expected), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAANP}
{\bkmkend AAAAAAAANP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 153 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_UINT16_ARRAY\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_UINT16_ARRAY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_UINT16_ARRAY( expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_EQUAL_UINT16_ARRAY}((expected), (actual), (num_elements), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAANQ}
{\bkmkend AAAAAAAANQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 313 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_UINT16_ARRAY_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_UINT16_ARRAY_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_UINT16_ARRAY_MESSAGE( expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_UINT16_ARRAY}((expected), (actual), (num_elements), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAANR}
{\bkmkend AAAAAAAANR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 596 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_UINT16_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_UINT16_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_UINT16_MESSAGE( expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_UINT16}( (expected), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAANS}
{\bkmkend AAAAAAAANS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 435 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_UINT32\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_UINT32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_UINT32( expected,  actual)\~ {\b UNITY_TEST_ASSERT_EQUAL_UINT32}( (expected), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAANT}
{\bkmkend AAAAAAAANT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 154 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_UINT32_ARRAY\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_UINT32_ARRAY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_UINT32_ARRAY( expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_EQUAL_UINT32_ARRAY}((expected), (actual), (num_elements), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAANU}
{\bkmkend AAAAAAAANU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 314 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_UINT32_ARRAY_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_UINT32_ARRAY_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_UINT32_ARRAY_MESSAGE( expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_UINT32_ARRAY}((expected), (actual), (num_elements), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAANV}
{\bkmkend AAAAAAAANV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 597 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_UINT32_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_UINT32_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_UINT32_MESSAGE( expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_UINT32}( (expected), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAANW}
{\bkmkend AAAAAAAANW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 436 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_UINT64\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_UINT64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_UINT64( expected,  actual)\~ {\b UNITY_TEST_ASSERT_EQUAL_UINT64}( (expected), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAANX}
{\bkmkend AAAAAAAANX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 155 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_UINT64_ARRAY\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_UINT64_ARRAY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_UINT64_ARRAY( expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_EQUAL_UINT64_ARRAY}((expected), (actual), (num_elements), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAANY}
{\bkmkend AAAAAAAANY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 315 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_UINT64_ARRAY_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_UINT64_ARRAY_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_UINT64_ARRAY_MESSAGE( expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_UINT64_ARRAY}((expected), (actual), (num_elements), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAANZ}
{\bkmkend AAAAAAAANZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 598 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_UINT64_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_UINT64_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_UINT64_MESSAGE( expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_UINT64}( (expected), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAOA}
{\bkmkend AAAAAAAAOA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 437 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_UINT8\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_UINT8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_UINT8( expected,  actual)\~ {\b UNITY_TEST_ASSERT_EQUAL_UINT8}( (expected), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAOB}
{\bkmkend AAAAAAAAOB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 152 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_UINT8_ARRAY\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_UINT8_ARRAY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_UINT8_ARRAY( expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_EQUAL_UINT8_ARRAY}((expected), (actual), (num_elements), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAOC}
{\bkmkend AAAAAAAAOC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 312 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_UINT8_ARRAY_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_UINT8_ARRAY_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_UINT8_ARRAY_MESSAGE( expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_UINT8_ARRAY}((expected), (actual), (num_elements), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAOD}
{\bkmkend AAAAAAAAOD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 595 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_UINT8_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_UINT8_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_UINT8_MESSAGE( expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_UINT8}( (expected), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAOE}
{\bkmkend AAAAAAAAOE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 434 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_UINT_ARRAY\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_UINT_ARRAY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_UINT_ARRAY( expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_EQUAL_UINT_ARRAY}((expected), (actual), (num_elements), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAOF}
{\bkmkend AAAAAAAAOF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 311 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_UINT_ARRAY_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_UINT_ARRAY_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_UINT_ARRAY_MESSAGE( expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_UINT_ARRAY}((expected), (actual), (num_elements), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAOG}
{\bkmkend AAAAAAAAOG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 594 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_EQUAL_UINT_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_EQUAL_UINT_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_EQUAL_UINT_MESSAGE( expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_EQUAL_UINT}( (expected), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAOH}
{\bkmkend AAAAAAAAOH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 433 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_FALSE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_FALSE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_FALSE( condition)\~ {\b UNITY_TEST_ASSERT}(      !(condition), __LINE__, " Expected FALSE Was TRUE")}}
\par
{\bkmkstart AAAAAAAAOI}
{\bkmkend AAAAAAAAOI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 139 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_FALSE_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_FALSE_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_FALSE_MESSAGE( condition,  message)\~ {\b UNITY_TEST_ASSERT}(      !(condition), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAOJ}
{\bkmkend AAAAAAAAOJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 421 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_FLOAT_ARRAY_WITHIN\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_FLOAT_ARRAY_WITHIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_FLOAT_ARRAY_WITHIN( delta,  expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_FLOAT_ARRAY_WITHIN}((delta), (expected), (actual), (num_elements), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAOK}
{\bkmkend AAAAAAAAOK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 354 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_FLOAT_ARRAY_WITHIN_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_FLOAT_ARRAY_WITHIN_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_FLOAT_ARRAY_WITHIN_MESSAGE( delta,  expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_FLOAT_ARRAY_WITHIN}((delta), (expected), (actual), (num_elements), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAOL}
{\bkmkend AAAAAAAAOL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 636 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_FLOAT_IS_DETERMINATE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_FLOAT_IS_DETERMINATE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_FLOAT_IS_DETERMINATE( actual)\~ {\b UNITY_TEST_ASSERT_FLOAT_IS_DETERMINATE}((actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAOM}
{\bkmkend AAAAAAAAOM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 364 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_FLOAT_IS_DETERMINATE_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_FLOAT_IS_DETERMINATE_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_FLOAT_IS_DETERMINATE_MESSAGE( actual,  message)\~ {\b UNITY_TEST_ASSERT_FLOAT_IS_DETERMINATE}((actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAON}
{\bkmkend AAAAAAAAON}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 646 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_FLOAT_IS_INF\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_FLOAT_IS_INF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_FLOAT_IS_INF( actual)\~ {\b UNITY_TEST_ASSERT_FLOAT_IS_INF}((actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAOO}
{\bkmkend AAAAAAAAOO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 361 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_FLOAT_IS_INF_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_FLOAT_IS_INF_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_FLOAT_IS_INF_MESSAGE( actual,  message)\~ {\b UNITY_TEST_ASSERT_FLOAT_IS_INF}((actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAOP}
{\bkmkend AAAAAAAAOP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 643 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_FLOAT_IS_NAN\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_FLOAT_IS_NAN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_FLOAT_IS_NAN( actual)\~ {\b UNITY_TEST_ASSERT_FLOAT_IS_NAN}((actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAOQ}
{\bkmkend AAAAAAAAOQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 363 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_FLOAT_IS_NAN_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_FLOAT_IS_NAN_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_FLOAT_IS_NAN_MESSAGE( actual,  message)\~ {\b UNITY_TEST_ASSERT_FLOAT_IS_NAN}((actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAOR}
{\bkmkend AAAAAAAAOR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 645 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_FLOAT_IS_NEG_INF\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_FLOAT_IS_NEG_INF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_FLOAT_IS_NEG_INF( actual)\~ {\b UNITY_TEST_ASSERT_FLOAT_IS_NEG_INF}((actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAOS}
{\bkmkend AAAAAAAAOS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 362 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_FLOAT_IS_NEG_INF_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_FLOAT_IS_NEG_INF_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_FLOAT_IS_NEG_INF_MESSAGE( actual,  message)\~ {\b UNITY_TEST_ASSERT_FLOAT_IS_NEG_INF}((actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAOT}
{\bkmkend AAAAAAAAOT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 644 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_FLOAT_IS_NOT_DETERMINATE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_FLOAT_IS_NOT_DETERMINATE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_FLOAT_IS_NOT_DETERMINATE( actual)\~ {\b UNITY_TEST_ASSERT_FLOAT_IS_NOT_DETERMINATE}((actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAOU}
{\bkmkend AAAAAAAAOU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 368 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_FLOAT_IS_NOT_DETERMINATE_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_FLOAT_IS_NOT_DETERMINATE_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_FLOAT_IS_NOT_DETERMINATE_MESSAGE( actual,  message)\~ {\b UNITY_TEST_ASSERT_FLOAT_IS_NOT_DETERMINATE}((actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAOV}
{\bkmkend AAAAAAAAOV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 650 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_FLOAT_IS_NOT_INF\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_FLOAT_IS_NOT_INF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_FLOAT_IS_NOT_INF( actual)\~ {\b UNITY_TEST_ASSERT_FLOAT_IS_NOT_INF}((actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAOW}
{\bkmkend AAAAAAAAOW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 365 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_FLOAT_IS_NOT_INF_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_FLOAT_IS_NOT_INF_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_FLOAT_IS_NOT_INF_MESSAGE( actual,  message)\~ {\b UNITY_TEST_ASSERT_FLOAT_IS_NOT_INF}((actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAOX}
{\bkmkend AAAAAAAAOX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 647 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_FLOAT_IS_NOT_NAN\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_FLOAT_IS_NOT_NAN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_FLOAT_IS_NOT_NAN( actual)\~ {\b UNITY_TEST_ASSERT_FLOAT_IS_NOT_NAN}((actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAOY}
{\bkmkend AAAAAAAAOY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 367 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_FLOAT_IS_NOT_NAN_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_FLOAT_IS_NOT_NAN_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_FLOAT_IS_NOT_NAN_MESSAGE( actual,  message)\~ {\b UNITY_TEST_ASSERT_FLOAT_IS_NOT_NAN}((actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAOZ}
{\bkmkend AAAAAAAAOZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 649 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_FLOAT_IS_NOT_NEG_INF\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_FLOAT_IS_NOT_NEG_INF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_FLOAT_IS_NOT_NEG_INF( actual)\~ {\b UNITY_TEST_ASSERT_FLOAT_IS_NOT_NEG_INF}((actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAPA}
{\bkmkend AAAAAAAAPA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 366 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_FLOAT_IS_NOT_NEG_INF_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_FLOAT_IS_NOT_NEG_INF_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_FLOAT_IS_NOT_NEG_INF_MESSAGE( actual,  message)\~ {\b UNITY_TEST_ASSERT_FLOAT_IS_NOT_NEG_INF}((actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAPB}
{\bkmkend AAAAAAAAPB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 648 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_FLOAT_NOT_WITHIN\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_FLOAT_NOT_WITHIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_FLOAT_NOT_WITHIN( delta,  expected,  actual)\~ {\b UNITY_TEST_ASSERT_FLOAT_NOT_WITHIN}((delta), (expected), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAPC}
{\bkmkend AAAAAAAAPC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 351 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_FLOAT_WITHIN\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_FLOAT_WITHIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_FLOAT_WITHIN( delta,  expected,  actual)\~ {\b UNITY_TEST_ASSERT_FLOAT_WITHIN}((delta), (expected), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAPD}
{\bkmkend AAAAAAAAPD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 350 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_FLOAT_WITHIN_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_FLOAT_WITHIN_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_FLOAT_WITHIN_MESSAGE( delta,  expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_FLOAT_WITHIN}((delta), (expected), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAPE}
{\bkmkend AAAAAAAAPE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 633 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_GREATER_OR_EQUAL\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_GREATER_OR_EQUAL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_GREATER_OR_EQUAL( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_INT}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAPF}
{\bkmkend AAAAAAAAPF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 224 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_GREATER_OR_EQUAL_CHAR\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_GREATER_OR_EQUAL_CHAR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_GREATER_OR_EQUAL_CHAR( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_CHAR}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAPG}
{\bkmkend AAAAAAAAPG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 240 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_GREATER_OR_EQUAL_CHAR_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_GREATER_OR_EQUAL_CHAR_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_GREATER_OR_EQUAL_CHAR_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_CHAR}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAPH}
{\bkmkend AAAAAAAAPH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 523 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_GREATER_OR_EQUAL_DOUBLE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_GREATER_OR_EQUAL_DOUBLE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_GREATER_OR_EQUAL_DOUBLE( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_DOUBLE}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAPI}
{\bkmkend AAAAAAAAPI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 379 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_GREATER_OR_EQUAL_DOUBLE_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_GREATER_OR_EQUAL_DOUBLE_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_GREATER_OR_EQUAL_DOUBLE_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_DOUBLE}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAPJ}
{\bkmkend AAAAAAAAPJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 660 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_GREATER_OR_EQUAL_FLOAT\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_GREATER_OR_EQUAL_FLOAT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_GREATER_OR_EQUAL_FLOAT( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_FLOAT}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAPK}
{\bkmkend AAAAAAAAPK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 358 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_GREATER_OR_EQUAL_FLOAT_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_GREATER_OR_EQUAL_FLOAT_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_GREATER_OR_EQUAL_FLOAT_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_FLOAT}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAPL}
{\bkmkend AAAAAAAAPL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 640 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_GREATER_OR_EQUAL_HEX16\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_GREATER_OR_EQUAL_HEX16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_GREATER_OR_EQUAL_HEX16( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_HEX16}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAPM}
{\bkmkend AAAAAAAAPM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 237 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_GREATER_OR_EQUAL_HEX16_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_GREATER_OR_EQUAL_HEX16_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_GREATER_OR_EQUAL_HEX16_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_HEX16}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAPN}
{\bkmkend AAAAAAAAPN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 520 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_GREATER_OR_EQUAL_HEX32\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_GREATER_OR_EQUAL_HEX32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_GREATER_OR_EQUAL_HEX32( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_HEX32}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAPO}
{\bkmkend AAAAAAAAPO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 238 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_GREATER_OR_EQUAL_HEX32_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_GREATER_OR_EQUAL_HEX32_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_GREATER_OR_EQUAL_HEX32_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_HEX32}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAPP}
{\bkmkend AAAAAAAAPP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 521 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_GREATER_OR_EQUAL_HEX64\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_GREATER_OR_EQUAL_HEX64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_GREATER_OR_EQUAL_HEX64( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_HEX64}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAPQ}
{\bkmkend AAAAAAAAPQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 239 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_GREATER_OR_EQUAL_HEX64_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_GREATER_OR_EQUAL_HEX64_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_GREATER_OR_EQUAL_HEX64_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_HEX64}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAPR}
{\bkmkend AAAAAAAAPR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 522 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_GREATER_OR_EQUAL_HEX8\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_GREATER_OR_EQUAL_HEX8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_GREATER_OR_EQUAL_HEX8( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_HEX8}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAPS}
{\bkmkend AAAAAAAAPS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 236 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_GREATER_OR_EQUAL_HEX8_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_GREATER_OR_EQUAL_HEX8_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_GREATER_OR_EQUAL_HEX8_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_HEX8}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAPT}
{\bkmkend AAAAAAAAPT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 519 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_GREATER_OR_EQUAL_INT\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_GREATER_OR_EQUAL_INT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_GREATER_OR_EQUAL_INT( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_INT}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAPU}
{\bkmkend AAAAAAAAPU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 225 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_GREATER_OR_EQUAL_INT16\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_GREATER_OR_EQUAL_INT16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_GREATER_OR_EQUAL_INT16( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_INT16}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAPV}
{\bkmkend AAAAAAAAPV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 227 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_GREATER_OR_EQUAL_INT16_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_GREATER_OR_EQUAL_INT16_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_GREATER_OR_EQUAL_INT16_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_INT16}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAPW}
{\bkmkend AAAAAAAAPW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 510 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_GREATER_OR_EQUAL_INT32\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_GREATER_OR_EQUAL_INT32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_GREATER_OR_EQUAL_INT32( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_INT32}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAPX}
{\bkmkend AAAAAAAAPX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 228 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_GREATER_OR_EQUAL_INT32_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_GREATER_OR_EQUAL_INT32_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_GREATER_OR_EQUAL_INT32_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_INT32}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAPY}
{\bkmkend AAAAAAAAPY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 511 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_GREATER_OR_EQUAL_INT64\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_GREATER_OR_EQUAL_INT64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_GREATER_OR_EQUAL_INT64( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_INT64}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAPZ}
{\bkmkend AAAAAAAAPZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 229 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_GREATER_OR_EQUAL_INT64_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_GREATER_OR_EQUAL_INT64_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_GREATER_OR_EQUAL_INT64_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_INT64}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAQA}
{\bkmkend AAAAAAAAQA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 512 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_GREATER_OR_EQUAL_INT8\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_GREATER_OR_EQUAL_INT8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_GREATER_OR_EQUAL_INT8( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_INT8}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAQB}
{\bkmkend AAAAAAAAQB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 226 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_GREATER_OR_EQUAL_INT8_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_GREATER_OR_EQUAL_INT8_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_GREATER_OR_EQUAL_INT8_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_INT8}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAQC}
{\bkmkend AAAAAAAAQC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 509 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_GREATER_OR_EQUAL_INT_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_GREATER_OR_EQUAL_INT_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_GREATER_OR_EQUAL_INT_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_INT}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAQD}
{\bkmkend AAAAAAAAQD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 508 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_GREATER_OR_EQUAL_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_GREATER_OR_EQUAL_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_GREATER_OR_EQUAL_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_INT}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAQE}
{\bkmkend AAAAAAAAQE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 507 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_GREATER_OR_EQUAL_size_t\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_GREATER_OR_EQUAL_size_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_GREATER_OR_EQUAL_size_t( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_UINT}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAQF}
{\bkmkend AAAAAAAAQF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 235 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_GREATER_OR_EQUAL_size_t_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_GREATER_OR_EQUAL_size_t_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_GREATER_OR_EQUAL_size_t_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_UINT}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAQG}
{\bkmkend AAAAAAAAQG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 518 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_GREATER_OR_EQUAL_UINT\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_GREATER_OR_EQUAL_UINT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_GREATER_OR_EQUAL_UINT( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_UINT}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAQH}
{\bkmkend AAAAAAAAQH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 230 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_GREATER_OR_EQUAL_UINT16\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_GREATER_OR_EQUAL_UINT16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_GREATER_OR_EQUAL_UINT16( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_UINT16}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAQI}
{\bkmkend AAAAAAAAQI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 232 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_GREATER_OR_EQUAL_UINT16_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_GREATER_OR_EQUAL_UINT16_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_GREATER_OR_EQUAL_UINT16_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_UINT16}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAQJ}
{\bkmkend AAAAAAAAQJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 515 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_GREATER_OR_EQUAL_UINT32\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_GREATER_OR_EQUAL_UINT32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_GREATER_OR_EQUAL_UINT32( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_UINT32}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAQK}
{\bkmkend AAAAAAAAQK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 233 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_GREATER_OR_EQUAL_UINT32_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_GREATER_OR_EQUAL_UINT32_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_GREATER_OR_EQUAL_UINT32_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_UINT32}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAQL}
{\bkmkend AAAAAAAAQL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 516 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_GREATER_OR_EQUAL_UINT64\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_GREATER_OR_EQUAL_UINT64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_GREATER_OR_EQUAL_UINT64( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_UINT64}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAQM}
{\bkmkend AAAAAAAAQM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 234 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_GREATER_OR_EQUAL_UINT64_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_GREATER_OR_EQUAL_UINT64_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_GREATER_OR_EQUAL_UINT64_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_UINT64}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAQN}
{\bkmkend AAAAAAAAQN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 517 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_GREATER_OR_EQUAL_UINT8\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_GREATER_OR_EQUAL_UINT8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_GREATER_OR_EQUAL_UINT8( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_UINT8}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAQO}
{\bkmkend AAAAAAAAQO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 231 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_GREATER_OR_EQUAL_UINT8_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_GREATER_OR_EQUAL_UINT8_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_GREATER_OR_EQUAL_UINT8_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_UINT8}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAQP}
{\bkmkend AAAAAAAAQP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 514 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_GREATER_OR_EQUAL_UINT_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_GREATER_OR_EQUAL_UINT_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_GREATER_OR_EQUAL_UINT_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_UINT}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAQQ}
{\bkmkend AAAAAAAAQQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 513 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_GREATER_THAN\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_GREATER_THAN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_GREATER_THAN( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_GREATER_THAN_INT}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAQR}
{\bkmkend AAAAAAAAQR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 188 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_GREATER_THAN_CHAR\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_GREATER_THAN_CHAR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_GREATER_THAN_CHAR( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_GREATER_THAN_CHAR}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAQS}
{\bkmkend AAAAAAAAQS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 204 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_GREATER_THAN_CHAR_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_GREATER_THAN_CHAR_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_GREATER_THAN_CHAR_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_GREATER_THAN_CHAR}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAQT}
{\bkmkend AAAAAAAAQT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 487 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_GREATER_THAN_DOUBLE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_GREATER_THAN_DOUBLE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_GREATER_THAN_DOUBLE( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_GREATER_THAN_DOUBLE}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAQU}
{\bkmkend AAAAAAAAQU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 378 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_GREATER_THAN_DOUBLE_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_GREATER_THAN_DOUBLE_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_GREATER_THAN_DOUBLE_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_GREATER_THAN_DOUBLE}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAQV}
{\bkmkend AAAAAAAAQV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 659 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_GREATER_THAN_FLOAT\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_GREATER_THAN_FLOAT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_GREATER_THAN_FLOAT( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_GREATER_THAN_FLOAT}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAQW}
{\bkmkend AAAAAAAAQW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 357 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_GREATER_THAN_FLOAT_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_GREATER_THAN_FLOAT_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_GREATER_THAN_FLOAT_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_GREATER_THAN_FLOAT}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAQX}
{\bkmkend AAAAAAAAQX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 639 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_GREATER_THAN_HEX16\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_GREATER_THAN_HEX16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_GREATER_THAN_HEX16( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_GREATER_THAN_HEX16}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAQY}
{\bkmkend AAAAAAAAQY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 201 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_GREATER_THAN_HEX16_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_GREATER_THAN_HEX16_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_GREATER_THAN_HEX16_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_GREATER_THAN_HEX16}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAQZ}
{\bkmkend AAAAAAAAQZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 484 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_GREATER_THAN_HEX32\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_GREATER_THAN_HEX32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_GREATER_THAN_HEX32( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_GREATER_THAN_HEX32}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAARA}
{\bkmkend AAAAAAAARA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 202 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_GREATER_THAN_HEX32_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_GREATER_THAN_HEX32_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_GREATER_THAN_HEX32_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_GREATER_THAN_HEX32}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAARB}
{\bkmkend AAAAAAAARB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 485 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_GREATER_THAN_HEX64\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_GREATER_THAN_HEX64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_GREATER_THAN_HEX64( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_GREATER_THAN_HEX64}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAARC}
{\bkmkend AAAAAAAARC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 203 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_GREATER_THAN_HEX64_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_GREATER_THAN_HEX64_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_GREATER_THAN_HEX64_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_GREATER_THAN_HEX64}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAARD}
{\bkmkend AAAAAAAARD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 486 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_GREATER_THAN_HEX8\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_GREATER_THAN_HEX8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_GREATER_THAN_HEX8( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_GREATER_THAN_HEX8}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAARE}
{\bkmkend AAAAAAAARE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 200 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_GREATER_THAN_HEX8_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_GREATER_THAN_HEX8_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_GREATER_THAN_HEX8_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_GREATER_THAN_HEX8}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAARF}
{\bkmkend AAAAAAAARF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 483 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_GREATER_THAN_INT\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_GREATER_THAN_INT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_GREATER_THAN_INT( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_GREATER_THAN_INT}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAARG}
{\bkmkend AAAAAAAARG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 189 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_GREATER_THAN_INT16\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_GREATER_THAN_INT16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_GREATER_THAN_INT16( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_GREATER_THAN_INT16}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAARH}
{\bkmkend AAAAAAAARH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 191 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_GREATER_THAN_INT16_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_GREATER_THAN_INT16_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_GREATER_THAN_INT16_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_GREATER_THAN_INT16}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAARI}
{\bkmkend AAAAAAAARI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 474 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_GREATER_THAN_INT32\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_GREATER_THAN_INT32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_GREATER_THAN_INT32( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_GREATER_THAN_INT32}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAARJ}
{\bkmkend AAAAAAAARJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 192 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_GREATER_THAN_INT32_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_GREATER_THAN_INT32_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_GREATER_THAN_INT32_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_GREATER_THAN_INT32}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAARK}
{\bkmkend AAAAAAAARK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 475 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_GREATER_THAN_INT64\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_GREATER_THAN_INT64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_GREATER_THAN_INT64( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_GREATER_THAN_INT64}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAARL}
{\bkmkend AAAAAAAARL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 193 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_GREATER_THAN_INT64_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_GREATER_THAN_INT64_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_GREATER_THAN_INT64_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_GREATER_THAN_INT64}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAARM}
{\bkmkend AAAAAAAARM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 476 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_GREATER_THAN_INT8\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_GREATER_THAN_INT8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_GREATER_THAN_INT8( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_GREATER_THAN_INT8}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAARN}
{\bkmkend AAAAAAAARN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 190 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_GREATER_THAN_INT8_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_GREATER_THAN_INT8_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_GREATER_THAN_INT8_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_GREATER_THAN_INT8}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAARO}
{\bkmkend AAAAAAAARO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 473 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_GREATER_THAN_INT_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_GREATER_THAN_INT_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_GREATER_THAN_INT_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_GREATER_THAN_INT}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAARP}
{\bkmkend AAAAAAAARP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 472 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_GREATER_THAN_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_GREATER_THAN_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_GREATER_THAN_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_GREATER_THAN_INT}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAARQ}
{\bkmkend AAAAAAAARQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 471 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_GREATER_THAN_size_t\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_GREATER_THAN_size_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_GREATER_THAN_size_t( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_GREATER_THAN_UINT}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAARR}
{\bkmkend AAAAAAAARR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 199 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_GREATER_THAN_size_t_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_GREATER_THAN_size_t_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_GREATER_THAN_size_t_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_GREATER_THAN_UINT}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAARS}
{\bkmkend AAAAAAAARS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 482 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_GREATER_THAN_UINT\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_GREATER_THAN_UINT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_GREATER_THAN_UINT( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_GREATER_THAN_UINT}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAART}
{\bkmkend AAAAAAAART}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 194 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_GREATER_THAN_UINT16\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_GREATER_THAN_UINT16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_GREATER_THAN_UINT16( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_GREATER_THAN_UINT16}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAARU}
{\bkmkend AAAAAAAARU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 196 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_GREATER_THAN_UINT16_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_GREATER_THAN_UINT16_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_GREATER_THAN_UINT16_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_GREATER_THAN_UINT16}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAARV}
{\bkmkend AAAAAAAARV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 479 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_GREATER_THAN_UINT32\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_GREATER_THAN_UINT32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_GREATER_THAN_UINT32( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_GREATER_THAN_UINT32}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAARW}
{\bkmkend AAAAAAAARW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 197 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_GREATER_THAN_UINT32_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_GREATER_THAN_UINT32_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_GREATER_THAN_UINT32_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_GREATER_THAN_UINT32}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAARX}
{\bkmkend AAAAAAAARX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 480 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_GREATER_THAN_UINT64\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_GREATER_THAN_UINT64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_GREATER_THAN_UINT64( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_GREATER_THAN_UINT64}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAARY}
{\bkmkend AAAAAAAARY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 198 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_GREATER_THAN_UINT64_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_GREATER_THAN_UINT64_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_GREATER_THAN_UINT64_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_GREATER_THAN_UINT64}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAARZ}
{\bkmkend AAAAAAAARZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 481 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_GREATER_THAN_UINT8\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_GREATER_THAN_UINT8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_GREATER_THAN_UINT8( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_GREATER_THAN_UINT8}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAASA}
{\bkmkend AAAAAAAASA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 195 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_GREATER_THAN_UINT8_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_GREATER_THAN_UINT8_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_GREATER_THAN_UINT8_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_GREATER_THAN_UINT8}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAASB}
{\bkmkend AAAAAAAASB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 478 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_GREATER_THAN_UINT_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_GREATER_THAN_UINT_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_GREATER_THAN_UINT_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_GREATER_THAN_UINT}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAASC}
{\bkmkend AAAAAAAASC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 477 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_HEX16_ARRAY_WITHIN\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_HEX16_ARRAY_WITHIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_HEX16_ARRAY_WITHIN( delta,  expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_HEX16_ARRAY_WITHIN}((delta), (expected), (actual), num_elements, __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAASD}
{\bkmkend AAAAAAAASD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 293 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_HEX16_ARRAY_WITHIN_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_HEX16_ARRAY_WITHIN_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_HEX16_ARRAY_WITHIN_MESSAGE( delta,  expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_HEX16_ARRAY_WITHIN}((delta), (expected), (actual), num_elements, __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAASE}
{\bkmkend AAAAAAAASE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 576 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_HEX16_WITHIN\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_HEX16_WITHIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_HEX16_WITHIN( delta,  expected,  actual)\~ {\b UNITY_TEST_ASSERT_HEX16_WITHIN}((delta), (expected), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAASF}
{\bkmkend AAAAAAAASF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 274 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_HEX16_WITHIN_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_HEX16_WITHIN_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_HEX16_WITHIN_MESSAGE( delta,  expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_HEX16_WITHIN}((delta), (expected), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAASG}
{\bkmkend AAAAAAAASG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 557 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_HEX32_ARRAY_WITHIN\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_HEX32_ARRAY_WITHIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_HEX32_ARRAY_WITHIN( delta,  expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_HEX32_ARRAY_WITHIN}((delta), (expected), (actual), num_elements, __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAASH}
{\bkmkend AAAAAAAASH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 294 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_HEX32_ARRAY_WITHIN_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_HEX32_ARRAY_WITHIN_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_HEX32_ARRAY_WITHIN_MESSAGE( delta,  expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_HEX32_ARRAY_WITHIN}((delta), (expected), (actual), num_elements, __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAASI}
{\bkmkend AAAAAAAASI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 577 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_HEX32_WITHIN\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_HEX32_WITHIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_HEX32_WITHIN( delta,  expected,  actual)\~ {\b UNITY_TEST_ASSERT_HEX32_WITHIN}((delta), (expected), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAASJ}
{\bkmkend AAAAAAAASJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 275 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_HEX32_WITHIN_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_HEX32_WITHIN_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_HEX32_WITHIN_MESSAGE( delta,  expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_HEX32_WITHIN}((delta), (expected), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAASK}
{\bkmkend AAAAAAAASK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 558 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_HEX64_ARRAY_WITHIN\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_HEX64_ARRAY_WITHIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_HEX64_ARRAY_WITHIN( delta,  expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_HEX64_ARRAY_WITHIN}((delta), (expected), (actual), num_elements, __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAASL}
{\bkmkend AAAAAAAASL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 295 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_HEX64_ARRAY_WITHIN_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_HEX64_ARRAY_WITHIN_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_HEX64_ARRAY_WITHIN_MESSAGE( delta,  expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_HEX64_ARRAY_WITHIN}((delta), (expected), (actual), num_elements, __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAASM}
{\bkmkend AAAAAAAASM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 578 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_HEX64_WITHIN\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_HEX64_WITHIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_HEX64_WITHIN( delta,  expected,  actual)\~ {\b UNITY_TEST_ASSERT_HEX64_WITHIN}((delta), (expected), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAASN}
{\bkmkend AAAAAAAASN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 276 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_HEX64_WITHIN_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_HEX64_WITHIN_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_HEX64_WITHIN_MESSAGE( delta,  expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_HEX64_WITHIN}((delta), (expected), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAASO}
{\bkmkend AAAAAAAASO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 559 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_HEX8_ARRAY_WITHIN\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_HEX8_ARRAY_WITHIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_HEX8_ARRAY_WITHIN( delta,  expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_HEX8_ARRAY_WITHIN}((delta), (expected), (actual), num_elements, __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAASP}
{\bkmkend AAAAAAAASP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 292 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_HEX8_ARRAY_WITHIN_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_HEX8_ARRAY_WITHIN_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_HEX8_ARRAY_WITHIN_MESSAGE( delta,  expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_HEX8_ARRAY_WITHIN}((delta), (expected), (actual), num_elements, __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAASQ}
{\bkmkend AAAAAAAASQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 575 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_HEX8_WITHIN\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_HEX8_WITHIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_HEX8_WITHIN( delta,  expected,  actual)\~ {\b UNITY_TEST_ASSERT_HEX8_WITHIN}((delta), (expected), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAASR}
{\bkmkend AAAAAAAASR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 273 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_HEX8_WITHIN_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_HEX8_WITHIN_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_HEX8_WITHIN_MESSAGE( delta,  expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_HEX8_WITHIN}((delta), (expected), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAASS}
{\bkmkend AAAAAAAASS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 556 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_HEX_ARRAY_WITHIN\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_HEX_ARRAY_WITHIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_HEX_ARRAY_WITHIN( delta,  expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_HEX32_ARRAY_WITHIN}((delta), (expected), (actual), num_elements, __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAST}
{\bkmkend AAAAAAAAST}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 291 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_HEX_ARRAY_WITHIN_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_HEX_ARRAY_WITHIN_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_HEX_ARRAY_WITHIN_MESSAGE( delta,  expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_HEX32_ARRAY_WITHIN}((delta), (expected), (actual), num_elements, __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAASU}
{\bkmkend AAAAAAAASU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 574 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_HEX_WITHIN\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_HEX_WITHIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_HEX_WITHIN( delta,  expected,  actual)\~ {\b UNITY_TEST_ASSERT_HEX32_WITHIN}((delta), (expected), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAASV}
{\bkmkend AAAAAAAASV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 272 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_HEX_WITHIN_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_HEX_WITHIN_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_HEX_WITHIN_MESSAGE( delta,  expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_HEX32_WITHIN}((delta), (expected), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAASW}
{\bkmkend AAAAAAAASW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 555 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_INT16_ARRAY_WITHIN\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_INT16_ARRAY_WITHIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_INT16_ARRAY_WITHIN( delta,  expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_INT16_ARRAY_WITHIN}((delta), (expected), (actual), num_elements, __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAASX}
{\bkmkend AAAAAAAASX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 282 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_INT16_ARRAY_WITHIN_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_INT16_ARRAY_WITHIN_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_INT16_ARRAY_WITHIN_MESSAGE( delta,  expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_INT16_ARRAY_WITHIN}((delta), (expected), (actual), num_elements, __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAASY}
{\bkmkend AAAAAAAASY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 565 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_INT16_WITHIN\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_INT16_WITHIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_INT16_WITHIN( delta,  expected,  actual)\~ {\b UNITY_TEST_ASSERT_INT16_WITHIN}((delta), (expected), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAASZ}
{\bkmkend AAAAAAAASZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 263 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_INT16_WITHIN_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_INT16_WITHIN_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_INT16_WITHIN_MESSAGE( delta,  expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_INT16_WITHIN}((delta), (expected), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAATA}
{\bkmkend AAAAAAAATA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 546 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_INT32_ARRAY_WITHIN\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_INT32_ARRAY_WITHIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_INT32_ARRAY_WITHIN( delta,  expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_INT32_ARRAY_WITHIN}((delta), (expected), (actual), num_elements, __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAATB}
{\bkmkend AAAAAAAATB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 283 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_INT32_ARRAY_WITHIN_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_INT32_ARRAY_WITHIN_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_INT32_ARRAY_WITHIN_MESSAGE( delta,  expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_INT32_ARRAY_WITHIN}((delta), (expected), (actual), num_elements, __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAATC}
{\bkmkend AAAAAAAATC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 566 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_INT32_WITHIN\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_INT32_WITHIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_INT32_WITHIN( delta,  expected,  actual)\~ {\b UNITY_TEST_ASSERT_INT32_WITHIN}((delta), (expected), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAATD}
{\bkmkend AAAAAAAATD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 264 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_INT32_WITHIN_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_INT32_WITHIN_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_INT32_WITHIN_MESSAGE( delta,  expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_INT32_WITHIN}((delta), (expected), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAATE}
{\bkmkend AAAAAAAATE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 547 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_INT64_ARRAY_WITHIN\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_INT64_ARRAY_WITHIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_INT64_ARRAY_WITHIN( delta,  expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_INT64_ARRAY_WITHIN}((delta), (expected), (actual), num_elements, __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAATF}
{\bkmkend AAAAAAAATF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 284 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_INT64_ARRAY_WITHIN_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_INT64_ARRAY_WITHIN_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_INT64_ARRAY_WITHIN_MESSAGE( delta,  expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_INT64_ARRAY_WITHIN}((delta), (expected), (actual), num_elements, __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAATG}
{\bkmkend AAAAAAAATG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 567 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_INT64_WITHIN\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_INT64_WITHIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_INT64_WITHIN( delta,  expected,  actual)\~ {\b UNITY_TEST_ASSERT_INT64_WITHIN}((delta), (expected), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAATH}
{\bkmkend AAAAAAAATH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 265 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_INT64_WITHIN_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_INT64_WITHIN_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_INT64_WITHIN_MESSAGE( delta,  expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_INT64_WITHIN}((delta), (expected), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAATI}
{\bkmkend AAAAAAAATI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 548 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_INT8_ARRAY_WITHIN\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_INT8_ARRAY_WITHIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_INT8_ARRAY_WITHIN( delta,  expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_INT8_ARRAY_WITHIN}((delta), (expected), (actual), num_elements, __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAATJ}
{\bkmkend AAAAAAAATJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 281 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_INT8_ARRAY_WITHIN_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_INT8_ARRAY_WITHIN_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_INT8_ARRAY_WITHIN_MESSAGE( delta,  expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_INT8_ARRAY_WITHIN}((delta), (expected), (actual), num_elements, __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAATK}
{\bkmkend AAAAAAAATK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 564 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_INT8_WITHIN\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_INT8_WITHIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_INT8_WITHIN( delta,  expected,  actual)\~ {\b UNITY_TEST_ASSERT_INT8_WITHIN}((delta), (expected), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAATL}
{\bkmkend AAAAAAAATL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 262 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_INT8_WITHIN_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_INT8_WITHIN_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_INT8_WITHIN_MESSAGE( delta,  expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_INT8_WITHIN}((delta), (expected), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAATM}
{\bkmkend AAAAAAAATM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 545 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_INT_ARRAY_WITHIN\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_INT_ARRAY_WITHIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_INT_ARRAY_WITHIN( delta,  expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_INT_ARRAY_WITHIN}((delta), (expected), (actual), num_elements, __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAATN}
{\bkmkend AAAAAAAATN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 280 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_INT_ARRAY_WITHIN_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_INT_ARRAY_WITHIN_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_INT_ARRAY_WITHIN_MESSAGE( delta,  expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_INT_ARRAY_WITHIN}((delta), (expected), (actual), num_elements, __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAATO}
{\bkmkend AAAAAAAATO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 563 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_INT_WITHIN\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_INT_WITHIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_INT_WITHIN( delta,  expected,  actual)\~ {\b UNITY_TEST_ASSERT_INT_WITHIN}((delta), (expected), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAATP}
{\bkmkend AAAAAAAATP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 261 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_INT_WITHIN_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_INT_WITHIN_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_INT_WITHIN_MESSAGE( delta,  expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_INT_WITHIN}((delta), (expected), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAATQ}
{\bkmkend AAAAAAAATQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 544 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_LESS_OR_EQUAL\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_LESS_OR_EQUAL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_LESS_OR_EQUAL( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_INT}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAATR}
{\bkmkend AAAAAAAATR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 242 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_LESS_OR_EQUAL_CHAR\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_LESS_OR_EQUAL_CHAR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_LESS_OR_EQUAL_CHAR( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_CHAR}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAATS}
{\bkmkend AAAAAAAATS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 258 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_LESS_OR_EQUAL_CHAR_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_LESS_OR_EQUAL_CHAR_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_LESS_OR_EQUAL_CHAR_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_CHAR}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAATT}
{\bkmkend AAAAAAAATT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 541 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_LESS_OR_EQUAL_DOUBLE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_LESS_OR_EQUAL_DOUBLE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_LESS_OR_EQUAL_DOUBLE( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_LESS_OR_EQUAL_DOUBLE}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAATU}
{\bkmkend AAAAAAAATU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 381 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_LESS_OR_EQUAL_DOUBLE_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_LESS_OR_EQUAL_DOUBLE_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_LESS_OR_EQUAL_DOUBLE_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_LESS_OR_EQUAL_DOUBLE}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAATV}
{\bkmkend AAAAAAAATV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 662 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_LESS_OR_EQUAL_FLOAT\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_LESS_OR_EQUAL_FLOAT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_LESS_OR_EQUAL_FLOAT( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_LESS_OR_EQUAL_FLOAT}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAATW}
{\bkmkend AAAAAAAATW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 360 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_LESS_OR_EQUAL_FLOAT_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_LESS_OR_EQUAL_FLOAT_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_LESS_OR_EQUAL_FLOAT_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_LESS_OR_EQUAL_FLOAT}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAATX}
{\bkmkend AAAAAAAATX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 642 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_LESS_OR_EQUAL_HEX16\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_LESS_OR_EQUAL_HEX16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_LESS_OR_EQUAL_HEX16( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_HEX16}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAATY}
{\bkmkend AAAAAAAATY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 255 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_LESS_OR_EQUAL_HEX16_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_LESS_OR_EQUAL_HEX16_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_LESS_OR_EQUAL_HEX16_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_HEX16}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAATZ}
{\bkmkend AAAAAAAATZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 538 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_LESS_OR_EQUAL_HEX32\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_LESS_OR_EQUAL_HEX32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_LESS_OR_EQUAL_HEX32( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_HEX32}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAUA}
{\bkmkend AAAAAAAAUA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 256 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_LESS_OR_EQUAL_HEX32_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_LESS_OR_EQUAL_HEX32_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_LESS_OR_EQUAL_HEX32_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_HEX32}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAUB}
{\bkmkend AAAAAAAAUB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 539 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_LESS_OR_EQUAL_HEX64\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_LESS_OR_EQUAL_HEX64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_LESS_OR_EQUAL_HEX64( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_HEX64}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAUC}
{\bkmkend AAAAAAAAUC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 257 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_LESS_OR_EQUAL_HEX64_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_LESS_OR_EQUAL_HEX64_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_LESS_OR_EQUAL_HEX64_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_HEX64}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAUD}
{\bkmkend AAAAAAAAUD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 540 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_LESS_OR_EQUAL_HEX8\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_LESS_OR_EQUAL_HEX8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_LESS_OR_EQUAL_HEX8( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_HEX8}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAUE}
{\bkmkend AAAAAAAAUE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 254 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_LESS_OR_EQUAL_HEX8_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_LESS_OR_EQUAL_HEX8_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_LESS_OR_EQUAL_HEX8_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_HEX8}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAUF}
{\bkmkend AAAAAAAAUF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 537 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_LESS_OR_EQUAL_INT\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_LESS_OR_EQUAL_INT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_LESS_OR_EQUAL_INT( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_INT}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAUG}
{\bkmkend AAAAAAAAUG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 243 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_LESS_OR_EQUAL_INT16\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_LESS_OR_EQUAL_INT16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_LESS_OR_EQUAL_INT16( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_INT16}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAUH}
{\bkmkend AAAAAAAAUH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 245 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_LESS_OR_EQUAL_INT16_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_LESS_OR_EQUAL_INT16_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_LESS_OR_EQUAL_INT16_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_INT16}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAUI}
{\bkmkend AAAAAAAAUI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 528 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_LESS_OR_EQUAL_INT32\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_LESS_OR_EQUAL_INT32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_LESS_OR_EQUAL_INT32( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_INT32}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAUJ}
{\bkmkend AAAAAAAAUJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 246 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_LESS_OR_EQUAL_INT32_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_LESS_OR_EQUAL_INT32_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_LESS_OR_EQUAL_INT32_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_INT32}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAUK}
{\bkmkend AAAAAAAAUK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 529 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_LESS_OR_EQUAL_INT64\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_LESS_OR_EQUAL_INT64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_LESS_OR_EQUAL_INT64( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_INT64}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAUL}
{\bkmkend AAAAAAAAUL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 247 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_LESS_OR_EQUAL_INT64_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_LESS_OR_EQUAL_INT64_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_LESS_OR_EQUAL_INT64_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_INT64}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAUM}
{\bkmkend AAAAAAAAUM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 530 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_LESS_OR_EQUAL_INT8\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_LESS_OR_EQUAL_INT8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_LESS_OR_EQUAL_INT8( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_INT8}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAUN}
{\bkmkend AAAAAAAAUN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 244 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_LESS_OR_EQUAL_INT8_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_LESS_OR_EQUAL_INT8_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_LESS_OR_EQUAL_INT8_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_INT8}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAUO}
{\bkmkend AAAAAAAAUO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 527 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_LESS_OR_EQUAL_INT_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_LESS_OR_EQUAL_INT_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_LESS_OR_EQUAL_INT_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_INT}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAUP}
{\bkmkend AAAAAAAAUP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 526 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_LESS_OR_EQUAL_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_LESS_OR_EQUAL_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_LESS_OR_EQUAL_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_INT}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAUQ}
{\bkmkend AAAAAAAAUQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 525 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_LESS_OR_EQUAL_size_t\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_LESS_OR_EQUAL_size_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_LESS_OR_EQUAL_size_t( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_UINT}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAUR}
{\bkmkend AAAAAAAAUR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 253 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_LESS_OR_EQUAL_size_t_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_LESS_OR_EQUAL_size_t_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_LESS_OR_EQUAL_size_t_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_UINT}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAUS}
{\bkmkend AAAAAAAAUS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 536 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_LESS_OR_EQUAL_UINT\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_LESS_OR_EQUAL_UINT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_LESS_OR_EQUAL_UINT( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_UINT}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAUT}
{\bkmkend AAAAAAAAUT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 248 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_LESS_OR_EQUAL_UINT16\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_LESS_OR_EQUAL_UINT16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_LESS_OR_EQUAL_UINT16( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_UINT16}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAUU}
{\bkmkend AAAAAAAAUU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 250 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_LESS_OR_EQUAL_UINT16_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_LESS_OR_EQUAL_UINT16_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_LESS_OR_EQUAL_UINT16_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_UINT16}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAUV}
{\bkmkend AAAAAAAAUV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 533 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_LESS_OR_EQUAL_UINT32\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_LESS_OR_EQUAL_UINT32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_LESS_OR_EQUAL_UINT32( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_UINT32}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAUW}
{\bkmkend AAAAAAAAUW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 251 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_LESS_OR_EQUAL_UINT32_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_LESS_OR_EQUAL_UINT32_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_LESS_OR_EQUAL_UINT32_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_UINT32}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAUX}
{\bkmkend AAAAAAAAUX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 534 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_LESS_OR_EQUAL_UINT64\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_LESS_OR_EQUAL_UINT64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_LESS_OR_EQUAL_UINT64( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_UINT64}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAUY}
{\bkmkend AAAAAAAAUY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 252 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_LESS_OR_EQUAL_UINT64_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_LESS_OR_EQUAL_UINT64_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_LESS_OR_EQUAL_UINT64_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_UINT64}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAUZ}
{\bkmkend AAAAAAAAUZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 535 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_LESS_OR_EQUAL_UINT8\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_LESS_OR_EQUAL_UINT8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_LESS_OR_EQUAL_UINT8( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_UINT8}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAVA}
{\bkmkend AAAAAAAAVA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 249 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_LESS_OR_EQUAL_UINT8_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_LESS_OR_EQUAL_UINT8_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_LESS_OR_EQUAL_UINT8_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_UINT8}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAVB}
{\bkmkend AAAAAAAAVB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 532 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_LESS_OR_EQUAL_UINT_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_LESS_OR_EQUAL_UINT_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_LESS_OR_EQUAL_UINT_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_UINT}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAVC}
{\bkmkend AAAAAAAAVC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 531 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_LESS_THAN\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_LESS_THAN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_LESS_THAN( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_SMALLER_THAN_INT}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAVD}
{\bkmkend AAAAAAAAVD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 206 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_LESS_THAN_CHAR\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_LESS_THAN_CHAR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_LESS_THAN_CHAR( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_SMALLER_THAN_CHAR}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAVE}
{\bkmkend AAAAAAAAVE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 222 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_LESS_THAN_CHAR_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_LESS_THAN_CHAR_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_LESS_THAN_CHAR_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_SMALLER_THAN_CHAR}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAVF}
{\bkmkend AAAAAAAAVF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 505 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_LESS_THAN_DOUBLE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_LESS_THAN_DOUBLE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_LESS_THAN_DOUBLE( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_LESS_THAN_DOUBLE}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAVG}
{\bkmkend AAAAAAAAVG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 380 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_LESS_THAN_DOUBLE_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_LESS_THAN_DOUBLE_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_LESS_THAN_DOUBLE_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_LESS_THAN_DOUBLE}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAVH}
{\bkmkend AAAAAAAAVH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 661 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_LESS_THAN_FLOAT\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_LESS_THAN_FLOAT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_LESS_THAN_FLOAT( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_LESS_THAN_FLOAT}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAVI}
{\bkmkend AAAAAAAAVI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 359 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_LESS_THAN_FLOAT_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_LESS_THAN_FLOAT_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_LESS_THAN_FLOAT_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_LESS_THAN_FLOAT}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAVJ}
{\bkmkend AAAAAAAAVJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 641 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_LESS_THAN_HEX16\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_LESS_THAN_HEX16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_LESS_THAN_HEX16( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_SMALLER_THAN_HEX16}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAVK}
{\bkmkend AAAAAAAAVK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 219 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_LESS_THAN_HEX16_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_LESS_THAN_HEX16_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_LESS_THAN_HEX16_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_SMALLER_THAN_HEX16}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAVL}
{\bkmkend AAAAAAAAVL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 502 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_LESS_THAN_HEX32\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_LESS_THAN_HEX32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_LESS_THAN_HEX32( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_SMALLER_THAN_HEX32}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAVM}
{\bkmkend AAAAAAAAVM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 220 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_LESS_THAN_HEX32_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_LESS_THAN_HEX32_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_LESS_THAN_HEX32_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_SMALLER_THAN_HEX32}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAVN}
{\bkmkend AAAAAAAAVN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 503 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_LESS_THAN_HEX64\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_LESS_THAN_HEX64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_LESS_THAN_HEX64( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_SMALLER_THAN_HEX64}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAVO}
{\bkmkend AAAAAAAAVO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 221 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_LESS_THAN_HEX64_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_LESS_THAN_HEX64_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_LESS_THAN_HEX64_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_SMALLER_THAN_HEX64}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAVP}
{\bkmkend AAAAAAAAVP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 504 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_LESS_THAN_HEX8\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_LESS_THAN_HEX8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_LESS_THAN_HEX8( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_SMALLER_THAN_HEX8}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAVQ}
{\bkmkend AAAAAAAAVQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 218 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_LESS_THAN_HEX8_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_LESS_THAN_HEX8_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_LESS_THAN_HEX8_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_SMALLER_THAN_HEX8}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAVR}
{\bkmkend AAAAAAAAVR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 501 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_LESS_THAN_INT\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_LESS_THAN_INT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_LESS_THAN_INT( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_SMALLER_THAN_INT}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAVS}
{\bkmkend AAAAAAAAVS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 207 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_LESS_THAN_INT16\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_LESS_THAN_INT16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_LESS_THAN_INT16( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_SMALLER_THAN_INT16}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAVT}
{\bkmkend AAAAAAAAVT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 209 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_LESS_THAN_INT16_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_LESS_THAN_INT16_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_LESS_THAN_INT16_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_SMALLER_THAN_INT16}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAVU}
{\bkmkend AAAAAAAAVU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 492 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_LESS_THAN_INT32\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_LESS_THAN_INT32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_LESS_THAN_INT32( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_SMALLER_THAN_INT32}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAVV}
{\bkmkend AAAAAAAAVV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 210 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_LESS_THAN_INT32_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_LESS_THAN_INT32_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_LESS_THAN_INT32_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_SMALLER_THAN_INT32}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAVW}
{\bkmkend AAAAAAAAVW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 493 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_LESS_THAN_INT64\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_LESS_THAN_INT64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_LESS_THAN_INT64( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_SMALLER_THAN_INT64}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAVX}
{\bkmkend AAAAAAAAVX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 211 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_LESS_THAN_INT64_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_LESS_THAN_INT64_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_LESS_THAN_INT64_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_SMALLER_THAN_INT64}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAVY}
{\bkmkend AAAAAAAAVY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 494 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_LESS_THAN_INT8\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_LESS_THAN_INT8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_LESS_THAN_INT8( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_SMALLER_THAN_INT8}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAVZ}
{\bkmkend AAAAAAAAVZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 208 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_LESS_THAN_INT8_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_LESS_THAN_INT8_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_LESS_THAN_INT8_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_SMALLER_THAN_INT8}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAWA}
{\bkmkend AAAAAAAAWA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 491 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_LESS_THAN_INT_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_LESS_THAN_INT_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_LESS_THAN_INT_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_SMALLER_THAN_INT}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAWB}
{\bkmkend AAAAAAAAWB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 490 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_LESS_THAN_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_LESS_THAN_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_LESS_THAN_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_SMALLER_THAN_INT}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAWC}
{\bkmkend AAAAAAAAWC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 489 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_LESS_THAN_size_t\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_LESS_THAN_size_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_LESS_THAN_size_t( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_SMALLER_THAN_UINT}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAWD}
{\bkmkend AAAAAAAAWD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 217 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_LESS_THAN_size_t_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_LESS_THAN_size_t_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_LESS_THAN_size_t_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_SMALLER_THAN_UINT}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAWE}
{\bkmkend AAAAAAAAWE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 500 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_LESS_THAN_UINT\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_LESS_THAN_UINT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_LESS_THAN_UINT( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_SMALLER_THAN_UINT}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAWF}
{\bkmkend AAAAAAAAWF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 212 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_LESS_THAN_UINT16\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_LESS_THAN_UINT16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_LESS_THAN_UINT16( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_SMALLER_THAN_UINT16}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAWG}
{\bkmkend AAAAAAAAWG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 214 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_LESS_THAN_UINT16_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_LESS_THAN_UINT16_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_LESS_THAN_UINT16_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_SMALLER_THAN_UINT16}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAWH}
{\bkmkend AAAAAAAAWH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 497 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_LESS_THAN_UINT32\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_LESS_THAN_UINT32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_LESS_THAN_UINT32( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_SMALLER_THAN_UINT32}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAWI}
{\bkmkend AAAAAAAAWI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 215 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_LESS_THAN_UINT32_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_LESS_THAN_UINT32_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_LESS_THAN_UINT32_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_SMALLER_THAN_UINT32}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAWJ}
{\bkmkend AAAAAAAAWJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 498 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_LESS_THAN_UINT64\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_LESS_THAN_UINT64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_LESS_THAN_UINT64( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_SMALLER_THAN_UINT64}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAWK}
{\bkmkend AAAAAAAAWK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 216 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_LESS_THAN_UINT64_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_LESS_THAN_UINT64_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_LESS_THAN_UINT64_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_SMALLER_THAN_UINT64}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAWL}
{\bkmkend AAAAAAAAWL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 499 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_LESS_THAN_UINT8\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_LESS_THAN_UINT8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_LESS_THAN_UINT8( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_SMALLER_THAN_UINT8}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAWM}
{\bkmkend AAAAAAAAWM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 213 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_LESS_THAN_UINT8_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_LESS_THAN_UINT8_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_LESS_THAN_UINT8_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_SMALLER_THAN_UINT8}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAWN}
{\bkmkend AAAAAAAAWN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 496 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_LESS_THAN_UINT_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_LESS_THAN_UINT_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_LESS_THAN_UINT_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_SMALLER_THAN_UINT}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAWO}
{\bkmkend AAAAAAAAWO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 495 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_MESSAGE( condition,  message)\~ {\b UNITY_TEST_ASSERT}(       (condition), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAWP}
{\bkmkend AAAAAAAAWP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 418 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_NOT_EMPTY\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_NOT_EMPTY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_NOT_EMPTY( pointer)\~ {\b UNITY_TEST_ASSERT_NOT_EMPTY}((pointer), __LINE__, " Expected Non-Empty")}}
\par
{\bkmkstart AAAAAAAAWQ}
{\bkmkend AAAAAAAAWQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 143 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_NOT_EMPTY_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_NOT_EMPTY_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_NOT_EMPTY_MESSAGE( pointer,  message)\~ {\b UNITY_TEST_ASSERT_NOT_EMPTY}((pointer), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAWR}
{\bkmkend AAAAAAAAWR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 425 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_NOT_EQUAL\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_NOT_EQUAL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_NOT_EQUAL( expected,  actual)\~ {\b UNITY_TEST_ASSERT}(((expected) != (actual)), __LINE__, " Expected Not-Equal")}}
\par
{\bkmkstart AAAAAAAAWS}
{\bkmkend AAAAAAAAWS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 394 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_NOT_EQUAL_CHAR\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_NOT_EQUAL_CHAR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_NOT_EQUAL_CHAR( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_NOT_EQUAL_CHAR}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAWT}
{\bkmkend AAAAAAAAWT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 185 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_NOT_EQUAL_CHAR_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_NOT_EQUAL_CHAR_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_NOT_EQUAL_CHAR_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_NOT_EQUAL_CHAR}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAWU}
{\bkmkend AAAAAAAAWU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 467 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_NOT_EQUAL_DOUBLE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_NOT_EQUAL_DOUBLE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_NOT_EQUAL_DOUBLE( expected,  actual)\~ {\b UNITY_TEST_ASSERT_NOT_EQUAL_DOUBLE}((expected), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAWV}
{\bkmkend AAAAAAAAWV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 374 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_NOT_EQUAL_DOUBLE_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_NOT_EQUAL_DOUBLE_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_NOT_EQUAL_DOUBLE_MESSAGE( expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_NOT_EQUAL_DOUBLE}((expected), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAWW}
{\bkmkend AAAAAAAAWW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 655 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_NOT_EQUAL_FLOAT\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_NOT_EQUAL_FLOAT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_NOT_EQUAL_FLOAT( expected,  actual)\~ {\b UNITY_TEST_ASSERT_NOT_EQUAL_FLOAT}((expected), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAWX}
{\bkmkend AAAAAAAAWX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 353 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_NOT_EQUAL_FLOAT_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_NOT_EQUAL_FLOAT_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_NOT_EQUAL_FLOAT_MESSAGE( expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_NOT_EQUAL_FLOAT}((expected), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAWY}
{\bkmkend AAAAAAAAWY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 635 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_NOT_EQUAL_HEX16\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_NOT_EQUAL_HEX16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_NOT_EQUAL_HEX16( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_NOT_EQUAL_HEX16}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAWZ}
{\bkmkend AAAAAAAAWZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 182 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_NOT_EQUAL_HEX16_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_NOT_EQUAL_HEX16_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_NOT_EQUAL_HEX16_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_NOT_EQUAL_HEX16}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAXA}
{\bkmkend AAAAAAAAXA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 464 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_NOT_EQUAL_HEX32\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_NOT_EQUAL_HEX32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_NOT_EQUAL_HEX32( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_NOT_EQUAL_HEX32}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAXB}
{\bkmkend AAAAAAAAXB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 183 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_NOT_EQUAL_HEX32_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_NOT_EQUAL_HEX32_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_NOT_EQUAL_HEX32_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_NOT_EQUAL_HEX32}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAXC}
{\bkmkend AAAAAAAAXC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 465 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_NOT_EQUAL_HEX64\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_NOT_EQUAL_HEX64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_NOT_EQUAL_HEX64( threshold,  actual)\~ UNITY_TEST_ASSERT_NOT_EQUAL_HEX64((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAXD}
{\bkmkend AAAAAAAAXD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 184 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_NOT_EQUAL_HEX64_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_NOT_EQUAL_HEX64_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_NOT_EQUAL_HEX64_MESSAGE( threshold,  actual,  message)\~ UNITY_TEST_ASSERT_NOT_EQUAL_HEX64((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAXE}
{\bkmkend AAAAAAAAXE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 466 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_NOT_EQUAL_HEX8\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_NOT_EQUAL_HEX8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_NOT_EQUAL_HEX8( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_NOT_EQUAL_HEX8}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAXF}
{\bkmkend AAAAAAAAXF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 181 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_NOT_EQUAL_HEX8_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_NOT_EQUAL_HEX8_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_NOT_EQUAL_HEX8_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_NOT_EQUAL_HEX8}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAXG}
{\bkmkend AAAAAAAAXG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 463 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_NOT_EQUAL_INT\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_NOT_EQUAL_INT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_NOT_EQUAL_INT( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_NOT_EQUAL_INT}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAXH}
{\bkmkend AAAAAAAAXH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 170 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_NOT_EQUAL_INT16\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_NOT_EQUAL_INT16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_NOT_EQUAL_INT16( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_NOT_EQUAL_INT16}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAXI}
{\bkmkend AAAAAAAAXI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 172 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_NOT_EQUAL_INT16_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_NOT_EQUAL_INT16_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_NOT_EQUAL_INT16_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_NOT_EQUAL_INT16}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAXJ}
{\bkmkend AAAAAAAAXJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 454 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_NOT_EQUAL_INT32\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_NOT_EQUAL_INT32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_NOT_EQUAL_INT32( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_NOT_EQUAL_INT32}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAXK}
{\bkmkend AAAAAAAAXK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 173 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_NOT_EQUAL_INT32_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_NOT_EQUAL_INT32_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_NOT_EQUAL_INT32_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_NOT_EQUAL_INT32}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAXL}
{\bkmkend AAAAAAAAXL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 455 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_NOT_EQUAL_INT64\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_NOT_EQUAL_INT64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_NOT_EQUAL_INT64( threshold,  actual)\~ UNITY_TEST_ASSERT_NOT_EQUAL_INT64((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAXM}
{\bkmkend AAAAAAAAXM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 174 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_NOT_EQUAL_INT64_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_NOT_EQUAL_INT64_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_NOT_EQUAL_INT64_MESSAGE( threshold,  actual,  message)\~ UNITY_TEST_ASSERT_NOT_EQUAL_INT64((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAXN}
{\bkmkend AAAAAAAAXN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 456 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_NOT_EQUAL_INT8\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_NOT_EQUAL_INT8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_NOT_EQUAL_INT8( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_NOT_EQUAL_INT8}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAXO}
{\bkmkend AAAAAAAAXO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 171 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_NOT_EQUAL_INT8_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_NOT_EQUAL_INT8_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_NOT_EQUAL_INT8_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_NOT_EQUAL_INT8}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAXP}
{\bkmkend AAAAAAAAXP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 453 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_NOT_EQUAL_INT_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_NOT_EQUAL_INT_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_NOT_EQUAL_INT_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_NOT_EQUAL_INT}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAXQ}
{\bkmkend AAAAAAAAXQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 452 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_NOT_EQUAL_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_NOT_EQUAL_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_NOT_EQUAL_MESSAGE( expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT}(((expected) != (actual)), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAXR}
{\bkmkend AAAAAAAAXR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 675 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_NOT_EQUAL_size_t\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_NOT_EQUAL_size_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_NOT_EQUAL_size_t( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_NOT_EQUAL_UINT}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAXS}
{\bkmkend AAAAAAAAXS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 180 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_NOT_EQUAL_size_t_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_NOT_EQUAL_size_t_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_NOT_EQUAL_size_t_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_NOT_EQUAL_UINT}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAXT}
{\bkmkend AAAAAAAAXT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 462 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_NOT_EQUAL_UINT\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_NOT_EQUAL_UINT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_NOT_EQUAL_UINT( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_NOT_EQUAL_UINT}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAXU}
{\bkmkend AAAAAAAAXU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 175 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_NOT_EQUAL_UINT16\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_NOT_EQUAL_UINT16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_NOT_EQUAL_UINT16( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_NOT_EQUAL_UINT16}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAXV}
{\bkmkend AAAAAAAAXV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 177 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_NOT_EQUAL_UINT16_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_NOT_EQUAL_UINT16_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_NOT_EQUAL_UINT16_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_NOT_EQUAL_UINT16}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAXW}
{\bkmkend AAAAAAAAXW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 459 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_NOT_EQUAL_UINT32\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_NOT_EQUAL_UINT32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_NOT_EQUAL_UINT32( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_NOT_EQUAL_UINT32}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAXX}
{\bkmkend AAAAAAAAXX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 178 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_NOT_EQUAL_UINT32_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_NOT_EQUAL_UINT32_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_NOT_EQUAL_UINT32_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_NOT_EQUAL_UINT32}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAXY}
{\bkmkend AAAAAAAAXY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 460 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_NOT_EQUAL_UINT64\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_NOT_EQUAL_UINT64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_NOT_EQUAL_UINT64( threshold,  actual)\~ UNITY_TEST_ASSERT_NOT_EQUAL_UINT64((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAXZ}
{\bkmkend AAAAAAAAXZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 179 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_NOT_EQUAL_UINT64_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_NOT_EQUAL_UINT64_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_NOT_EQUAL_UINT64_MESSAGE( threshold,  actual,  message)\~ UNITY_TEST_ASSERT_NOT_EQUAL_UINT64((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAYA}
{\bkmkend AAAAAAAAYA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 461 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_NOT_EQUAL_UINT8\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_NOT_EQUAL_UINT8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_NOT_EQUAL_UINT8( threshold,  actual)\~ {\b UNITY_TEST_ASSERT_NOT_EQUAL_UINT8}((threshold), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAYB}
{\bkmkend AAAAAAAAYB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 176 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_NOT_EQUAL_UINT8_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_NOT_EQUAL_UINT8_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_NOT_EQUAL_UINT8_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_NOT_EQUAL_UINT8}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAYC}
{\bkmkend AAAAAAAAYC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 458 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_NOT_EQUAL_UINT_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_NOT_EQUAL_UINT_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_NOT_EQUAL_UINT_MESSAGE( threshold,  actual,  message)\~ {\b UNITY_TEST_ASSERT_NOT_EQUAL_UINT}((threshold), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAYD}
{\bkmkend AAAAAAAAYD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 457 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_NOT_NULL\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_NOT_NULL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_NOT_NULL( pointer)\~ {\b UNITY_TEST_ASSERT_NOT_NULL}((pointer), __LINE__, " Expected Non-NULL")}}
\par
{\bkmkstart AAAAAAAAYE}
{\bkmkend AAAAAAAAYE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 141 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_NOT_NULL_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_NOT_NULL_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_NOT_NULL_MESSAGE( pointer,  message)\~ {\b UNITY_TEST_ASSERT_NOT_NULL}((pointer), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAYF}
{\bkmkend AAAAAAAAYF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 423 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_NULL\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_NULL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_NULL( pointer)\~ {\b UNITY_TEST_ASSERT_NULL}(    (pointer), __LINE__, " Expected NULL")}}
\par
{\bkmkstart AAAAAAAAYG}
{\bkmkend AAAAAAAAYG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 140 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_NULL_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_NULL_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_NULL_MESSAGE( pointer,  message)\~ {\b UNITY_TEST_ASSERT_NULL}(    (pointer), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAYH}
{\bkmkend AAAAAAAAYH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 422 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_size_t_ARRAY_WITHIN\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_size_t_ARRAY_WITHIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_size_t_ARRAY_WITHIN( delta,  expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_UINT_ARRAY_WITHIN}((delta), (expected), (actual), num_elements, __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAYI}
{\bkmkend AAAAAAAAYI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 290 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_size_t_ARRAY_WITHIN_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_size_t_ARRAY_WITHIN_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_size_t_ARRAY_WITHIN_MESSAGE( delta,  expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_UINT_ARRAY_WITHIN}((delta), (expected), (actual), num_elements, __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAYJ}
{\bkmkend AAAAAAAAYJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 573 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_size_t_WITHIN\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_size_t_WITHIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_size_t_WITHIN( delta,  expected,  actual)\~ {\b UNITY_TEST_ASSERT_UINT_WITHIN}((delta), (expected), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAYK}
{\bkmkend AAAAAAAAYK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 271 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_size_t_WITHIN_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_size_t_WITHIN_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_size_t_WITHIN_MESSAGE( delta,  expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_UINT_WITHIN}((delta), (expected), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAYL}
{\bkmkend AAAAAAAAYL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 554 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_TRUE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_TRUE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_TRUE( condition)\~ {\b UNITY_TEST_ASSERT}(       (condition), __LINE__, " Expected TRUE Was FALSE")}}
\par
{\bkmkstart AAAAAAAAYM}
{\bkmkend AAAAAAAAYM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 137 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_TRUE_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_TRUE_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_TRUE_MESSAGE( condition,  message)\~ {\b UNITY_TEST_ASSERT}(       (condition), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAYN}
{\bkmkend AAAAAAAAYN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 419 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_UINT16_ARRAY_WITHIN\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_UINT16_ARRAY_WITHIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_UINT16_ARRAY_WITHIN( delta,  expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_UINT16_ARRAY_WITHIN}((delta), (expected), (actual), num_elements, __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAYO}
{\bkmkend AAAAAAAAYO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 287 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_UINT16_ARRAY_WITHIN_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_UINT16_ARRAY_WITHIN_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_UINT16_ARRAY_WITHIN_MESSAGE( delta,  expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_UINT16_ARRAY_WITHIN}((delta), (expected), (actual), num_elements, __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAYP}
{\bkmkend AAAAAAAAYP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 570 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_UINT16_WITHIN\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_UINT16_WITHIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_UINT16_WITHIN( delta,  expected,  actual)\~ {\b UNITY_TEST_ASSERT_UINT16_WITHIN}((delta), (expected), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAYQ}
{\bkmkend AAAAAAAAYQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 268 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_UINT16_WITHIN_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_UINT16_WITHIN_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_UINT16_WITHIN_MESSAGE( delta,  expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_UINT16_WITHIN}((delta), (expected), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAYR}
{\bkmkend AAAAAAAAYR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 551 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_UINT32_ARRAY_WITHIN\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_UINT32_ARRAY_WITHIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_UINT32_ARRAY_WITHIN( delta,  expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_UINT32_ARRAY_WITHIN}((delta), (expected), (actual), num_elements, __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAYS}
{\bkmkend AAAAAAAAYS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 288 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_UINT32_ARRAY_WITHIN_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_UINT32_ARRAY_WITHIN_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_UINT32_ARRAY_WITHIN_MESSAGE( delta,  expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_UINT32_ARRAY_WITHIN}((delta), (expected), (actual), num_elements, __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAYT}
{\bkmkend AAAAAAAAYT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 571 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_UINT32_WITHIN\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_UINT32_WITHIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_UINT32_WITHIN( delta,  expected,  actual)\~ {\b UNITY_TEST_ASSERT_UINT32_WITHIN}((delta), (expected), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAYU}
{\bkmkend AAAAAAAAYU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 269 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_UINT32_WITHIN_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_UINT32_WITHIN_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_UINT32_WITHIN_MESSAGE( delta,  expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_UINT32_WITHIN}((delta), (expected), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAYV}
{\bkmkend AAAAAAAAYV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 552 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_UINT64_ARRAY_WITHIN\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_UINT64_ARRAY_WITHIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_UINT64_ARRAY_WITHIN( delta,  expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_UINT64_ARRAY_WITHIN}((delta), (expected), (actual), num_elements, __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAYW}
{\bkmkend AAAAAAAAYW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 289 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_UINT64_ARRAY_WITHIN_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_UINT64_ARRAY_WITHIN_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_UINT64_ARRAY_WITHIN_MESSAGE( delta,  expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_UINT64_ARRAY_WITHIN}((delta), (expected), (actual), num_elements, __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAYX}
{\bkmkend AAAAAAAAYX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 572 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_UINT64_WITHIN\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_UINT64_WITHIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_UINT64_WITHIN( delta,  expected,  actual)\~ {\b UNITY_TEST_ASSERT_UINT64_WITHIN}((delta), (expected), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAYY}
{\bkmkend AAAAAAAAYY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 270 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_UINT64_WITHIN_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_UINT64_WITHIN_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_UINT64_WITHIN_MESSAGE( delta,  expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_UINT64_WITHIN}((delta), (expected), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAYZ}
{\bkmkend AAAAAAAAYZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 553 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_UINT8_ARRAY_WITHIN\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_UINT8_ARRAY_WITHIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_UINT8_ARRAY_WITHIN( delta,  expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_UINT8_ARRAY_WITHIN}((delta), (expected), (actual), num_elements, __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAZA}
{\bkmkend AAAAAAAAZA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 286 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_UINT8_ARRAY_WITHIN_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_UINT8_ARRAY_WITHIN_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_UINT8_ARRAY_WITHIN_MESSAGE( delta,  expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_UINT8_ARRAY_WITHIN}((delta), (expected), (actual), num_elements, __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAZB}
{\bkmkend AAAAAAAAZB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 569 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_UINT8_WITHIN\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_UINT8_WITHIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_UINT8_WITHIN( delta,  expected,  actual)\~ {\b UNITY_TEST_ASSERT_UINT8_WITHIN}((delta), (expected), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAZC}
{\bkmkend AAAAAAAAZC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 267 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_UINT8_WITHIN_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_UINT8_WITHIN_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_UINT8_WITHIN_MESSAGE( delta,  expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_UINT8_WITHIN}((delta), (expected), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAZD}
{\bkmkend AAAAAAAAZD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 550 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_UINT_ARRAY_WITHIN\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_UINT_ARRAY_WITHIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_UINT_ARRAY_WITHIN( delta,  expected,  actual,  num_elements)\~ {\b UNITY_TEST_ASSERT_UINT_ARRAY_WITHIN}((delta), (expected), (actual), num_elements, __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAZE}
{\bkmkend AAAAAAAAZE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 285 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_UINT_ARRAY_WITHIN_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_UINT_ARRAY_WITHIN_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_UINT_ARRAY_WITHIN_MESSAGE( delta,  expected,  actual,  num_elements,  message)\~ {\b UNITY_TEST_ASSERT_UINT_ARRAY_WITHIN}((delta), (expected), (actual), num_elements, __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAZF}
{\bkmkend AAAAAAAAZF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 568 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_UINT_WITHIN\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_UINT_WITHIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_UINT_WITHIN( delta,  expected,  actual)\~ {\b UNITY_TEST_ASSERT_UINT_WITHIN}((delta), (expected), (actual), __LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAZG}
{\bkmkend AAAAAAAAZG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 266 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_UINT_WITHIN_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_UINT_WITHIN_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_UINT_WITHIN_MESSAGE( delta,  expected,  actual,  message)\~ {\b UNITY_TEST_ASSERT_UINT_WITHIN}((delta), (expected), (actual), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAZH}
{\bkmkend AAAAAAAAZH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 549 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_UNLESS\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_UNLESS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_UNLESS( condition)\~ {\b UNITY_TEST_ASSERT}(      !(condition), __LINE__, " Expression Evaluated To TRUE")}}
\par
{\bkmkstart AAAAAAAAZI}
{\bkmkend AAAAAAAAZI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 138 of file unity.h.}\par
}
{\xe \v TEST_ASSERT_UNLESS_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_ASSERT_UNLESS_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ASSERT_UNLESS_MESSAGE( condition,  message)\~ {\b UNITY_TEST_ASSERT}(      !(condition), __LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAZJ}
{\bkmkend AAAAAAAAZJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 420 of file unity.h.}\par
}
{\xe \v TEST_FAIL\:unity.h}
{\xe \v unity.h\:TEST_FAIL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_FAIL()\~ {\b UNITY_TEST_FAIL}(__LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAZK}
{\bkmkend AAAAAAAAZK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 103 of file unity.h.}\par
}
{\xe \v TEST_FAIL_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_FAIL_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_FAIL_MESSAGE( message)\~ {\b UNITY_TEST_FAIL}(__LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAZL}
{\bkmkend AAAAAAAAZL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 102 of file unity.h.}\par
}
{\xe \v TEST_IGNORE\:unity.h}
{\xe \v unity.h\:TEST_IGNORE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_IGNORE()\~ {\b UNITY_TEST_IGNORE}(__LINE__, NULL)}}
\par
{\bkmkstart AAAAAAAAZM}
{\bkmkend AAAAAAAAZM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 105 of file unity.h.}\par
}
{\xe \v TEST_IGNORE_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_IGNORE_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_IGNORE_MESSAGE( message)\~ {\b UNITY_TEST_IGNORE}(__LINE__, (message))}}
\par
{\bkmkstart AAAAAAAAZN}
{\bkmkend AAAAAAAAZN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 104 of file unity.h.}\par
}
{\xe \v TEST_INCLUDE_PATH\:unity.h}
{\xe \v unity.h\:TEST_INCLUDE_PATH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_INCLUDE_PATH( a)}}
\par
{\bkmkstart AAAAAAAAZO}
{\bkmkend AAAAAAAAZO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 129 of file unity.h.}\par
}
{\xe \v TEST_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_MESSAGE( message)\~ {\b UnityMessage}((message), __LINE__)}}
\par
{\bkmkstart AAAAAAAAZP}
{\bkmkend AAAAAAAAZP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 106 of file unity.h.}\par
}
{\xe \v TEST_ONLY\:unity.h}
{\xe \v unity.h\:TEST_ONLY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ONLY()}}
\par
{\bkmkstart AAAAAAAAZQ}
{\bkmkend AAAAAAAAZQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 107 of file unity.h.}\par
}
{\xe \v TEST_PASS\:unity.h}
{\xe \v unity.h\:TEST_PASS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_PASS()\~ {\b TEST_ABORT}()}}
\par
{\bkmkstart AAAAAAAAZR}
{\bkmkend AAAAAAAAZR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 114 of file unity.h.}\par
}
{\xe \v TEST_PASS_MESSAGE\:unity.h}
{\xe \v unity.h\:TEST_PASS_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_PASS_MESSAGE( message)\~ do \{ {\b UnityMessage}((message), __LINE__); {\b TEST_ABORT}(); \} while (0)}}
\par
{\bkmkstart AAAAAAAAZS}
{\bkmkend AAAAAAAAZS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 115 of file unity.h.}\par
}
{\xe \v TEST_SOURCE_FILE\:unity.h}
{\xe \v unity.h\:TEST_SOURCE_FILE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_SOURCE_FILE( a)}}
\par
{\bkmkstart AAAAAAAAZT}
{\bkmkend AAAAAAAAZT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 126 of file unity.h.}\par
}
{\xe \v UNITY\:unity.h}
{\xe \v unity.h\:UNITY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY}}
\par
{\bkmkstart AAAAAAAAZU}
{\bkmkend AAAAAAAAZU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 10 of file unity.h.}\par
}
{\xe \v UNITY_VERSION\:unity.h}
{\xe \v unity.h\:UNITY_VERSION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_VERSION\~ (({\b UNITY_VERSION_MAJOR} << 16) | ({\b UNITY_VERSION_MINOR} << 8) | {\b UNITY_VERSION_BUILD})}}
\par
{\bkmkstart AAAAAAAAZV}
{\bkmkend AAAAAAAAZV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 15 of file unity.h.}\par
}
{\xe \v UNITY_VERSION_BUILD\:unity.h}
{\xe \v unity.h\:UNITY_VERSION_BUILD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_VERSION_BUILD\~ 1}}
\par
{\bkmkstart AAAAAAAAZW}
{\bkmkend AAAAAAAAZW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 14 of file unity.h.}\par
}
{\xe \v UNITY_VERSION_MAJOR\:unity.h}
{\xe \v unity.h\:UNITY_VERSION_MAJOR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_VERSION_MAJOR\~ 2}}
\par
{\bkmkstart AAAAAAAAZX}
{\bkmkend AAAAAAAAZX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 12 of file unity.h.}\par
}
{\xe \v UNITY_VERSION_MINOR\:unity.h}
{\xe \v unity.h\:UNITY_VERSION_MINOR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_VERSION_MINOR\~ 6}}
\par
{\bkmkstart AAAAAAAAZY}
{\bkmkend AAAAAAAAZY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 13 of file unity.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v resetTest\:unity.h}
{\xe \v unity.h\:resetTest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void resetTest (void )}}
\par
{\bkmkstart AAAAAAAAZZ}
{\bkmkend AAAAAAAAZZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v setUp\:unity.h}
{\xe \v unity.h\:setUp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setUp (void )}}
\par
{\bkmkstart AAAAAAABAA}
{\bkmkend AAAAAAABAA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 6 of file test_mq_utils.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7 \{\par
8     {\cf20 // set stuff up here}\par
9 \}\par
}
}
{\xe \v suiteSetUp\:unity.h}
{\xe \v unity.h\:suiteSetUp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void suiteSetUp (void )}}
\par
{\bkmkstart AAAAAAABAB}
{\bkmkend AAAAAAABAB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v suiteTearDown\:unity.h}
{\xe \v unity.h\:suiteTearDown}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int suiteTearDown (int  {\i num_failures})}}
\par
{\bkmkstart AAAAAAABAC}
{\bkmkend AAAAAAABAC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v tearDown\:unity.h}
{\xe \v unity.h\:tearDown}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void tearDown (void )}}
\par
{\bkmkstart AAAAAAABAD}
{\bkmkend AAAAAAABAD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 11 of file test_mq_utils.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 12 \{\par
13     {\cf20 // clean stuff up here}\par
14 \}\par
}
}
{\xe \v verifyTest\:unity.h}
{\xe \v unity.h\:verifyTest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void verifyTest (void )}}
\par
{\bkmkstart AAAAAAABAE}
{\bkmkend AAAAAAABAE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
test/unity_internals.h File Reference\par \pard\plain 
{\tc\tcl2 \v test/unity_internals.h}
{\xe \v test/unity_internals.h}
{\bkmkstart AAAAAAABAF}
{\bkmkend AAAAAAABAF}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <setjmp.h>}\par
{\f2 #include <math.h>}\par
{\f2 #include <stddef.h>}\par
{\f2 #include <stdint.h>}\par
{\f2 #include <limits.h>}\par
{\f2 #include <stdio.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for unity_internals.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "unity__internals_8h__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "unity__internals_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b UNITY_STORAGE_T}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_FUNCTION_ATTR}(a)\~ /* ignore */\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_NORETURN}\~ {\b UNITY_FUNCTION_ATTR}(__noreturn__)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_INT_WIDTH}\~ (32)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_LONG_WIDTH}\~ (32)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_POINTER_WIDTH}\~ {\b UNITY_LONG_WIDTH}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_MAX_NIBBLES}\~ (8)  /* Maximum number of nibbles in a UNITY_(U)INT */\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_PTR_TO_INT}\~ {\b UNITY_INT32}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_DISPLAY_STYLE_POINTER}\~ {\b UNITY_DISPLAY_STYLE_HEX32}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_PTR_ATTRIBUTE}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_INTERNAL_PTR}\~ {\b UNITY_PTR_ATTRIBUTE} const void*\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_FLOAT_PRECISION}\~ (0.00001{\b f})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_FLOAT_TYPE}\~ float\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_IS_NAN}(n)\~ ((n != n) ? 1 : 0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_IS_INF}(n)\~ ({\b UNITY_IS_NAN}((n) - (n)) && !{\b UNITY_IS_NAN}(n))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_EXCLUDE_DOUBLE}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_DOUBLE_TYPE}\~ double\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_OUTPUT_CHAR}(a)\~ (void)putchar(a)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_OUTPUT_FLUSH}()\~ (void)0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_FLUSH_CALL}()\~ {\b UNITY_OUTPUT_FLUSH}()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_PRINT_EOL}()\~ {\b UNITY_OUTPUT_CHAR}('\\n')\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_OUTPUT_START}()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_OUTPUT_COMPLETE}()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_EXEC_TIME_START}()\~ do \{ /* nothing*/ \} while (0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_EXEC_TIME_STOP}()\~ do \{ /* nothing*/ \} while (0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TIME_TYPE}\~ {\b UNITY_UINT}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_PRINT_EXEC_TIME}()\~ do \{ /* nothing*/ \} while (0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_LINE_TYPE}\~ {\b UNITY_UINT}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_COUNTER_TYPE}\~ {\b UNITY_UINT}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_DISPLAY_RANGE_INT}\~ (0x10)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_DISPLAY_RANGE_UINT}\~ (0x20)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_DISPLAY_RANGE_HEX}\~ (0x40)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_DISPLAY_RANGE_CHAR}\~ (0x80)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_CLR_DETAILS}()\~ do \{ Unity.CurrentDetail1 = 0;     Unity.CurrentDetail2 = 0;    \} while (0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_SET_DETAIL}(d1)\~ do \{ Unity.CurrentDetail1 = (d1);  Unity.CurrentDetail2 = 0;    \} while (0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_SET_DETAILS}(d1,  d2)\~ do \{ Unity.CurrentDetail1 = (d1);  Unity.CurrentDetail2 = (d2); \} while (0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_DETAIL1_NAME}\~ "Function"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_DETAIL2_NAME}\~ "Argument"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_PROTECT}()\~ (setjmp(Unity.AbortFrame) == 0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_ABORT}()\~ longjmp(Unity.AbortFrame, 1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b RUN_TEST}(func)\~ {\b UnityDefaultTestRun}(func, #func, __LINE__)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_LINE_NUM}\~ (Unity.CurrentTestLineNumber)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_IS_IGNORED}\~ (Unity.CurrentTestIgnored)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_NEW_TEST}(a)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_BEGIN}()\~ {\b UnityBegin}(__FILE__)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_END}()\~ {\b UnityEnd}()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_SHORTHAND_AS_OLD}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_FAIL}(line,  message)\~ {\b UnityFail}(   (message), ({\b UNITY_LINE_TYPE})(line))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_IGNORE}(line,  message)\~ {\b UnityIgnore}( (message), ({\b UNITY_LINE_TYPE})(line))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT}(condition,  line,  message)\~ do \{ if (condition) \{ /* nothing*/ \} else \{ {\b UNITY_TEST_FAIL}((line), (message)); \} \} while (0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_NULL}(pointer,  line,  message)\~ {\b UNITY_TEST_ASSERT}(((pointer) == NULL),  (line), (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_NOT_NULL}(pointer,  line,  message)\~ {\b UNITY_TEST_ASSERT}(((pointer) != NULL),  (line), (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_EMPTY}(pointer,  line,  message)\~ {\b UNITY_TEST_ASSERT}(((pointer[0]) == 0),  (line), (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_NOT_EMPTY}(pointer,  line,  message)\~ {\b UNITY_TEST_ASSERT}(((pointer[0]) != 0),  (line), (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_EQUAL_INT}(expected,  actual,  line,  message)\~ {\b UnityAssertEqualNumber}(({\b UNITY_INT})(expected), ({\b UNITY_INT})(actual), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_INT})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_EQUAL_INT8}(expected,  actual,  line,  message)\~ {\b UnityAssertEqualNumber}(({\b UNITY_INT})({\b UNITY_INT8} )(expected), ({\b UNITY_INT})({\b UNITY_INT8} )(actual), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_INT8})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_EQUAL_INT16}(expected,  actual,  line,  message)\~ {\b UnityAssertEqualNumber}(({\b UNITY_INT})({\b UNITY_INT16})(expected), ({\b UNITY_INT})({\b UNITY_INT16})(actual), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_INT16})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_EQUAL_INT32}(expected,  actual,  line,  message)\~ {\b UnityAssertEqualNumber}(({\b UNITY_INT})({\b UNITY_INT32})(expected), ({\b UNITY_INT})({\b UNITY_INT32})(actual), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_INT32})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_EQUAL_UINT}(expected,  actual,  line,  message)\~ {\b UnityAssertEqualNumber}(({\b UNITY_INT})(expected), ({\b UNITY_INT})(actual), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_UINT})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_EQUAL_UINT8}(expected,  actual,  line,  message)\~ {\b UnityAssertEqualNumber}(({\b UNITY_INT})({\b UNITY_UINT8} )(expected), ({\b UNITY_INT})({\b UNITY_UINT8} )(actual), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_UINT8})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_EQUAL_UINT16}(expected,  actual,  line,  message)\~ {\b UnityAssertEqualNumber}(({\b UNITY_INT})({\b UNITY_UINT16})(expected), ({\b UNITY_INT})({\b UNITY_UINT16})(actual), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_UINT16})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_EQUAL_UINT32}(expected,  actual,  line,  message)\~ {\b UnityAssertEqualNumber}(({\b UNITY_INT})({\b UNITY_UINT32})(expected), ({\b UNITY_INT})({\b UNITY_UINT32})(actual), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_UINT32})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_EQUAL_HEX8}(expected,  actual,  line,  message)\~ {\b UnityAssertEqualNumber}(({\b UNITY_INT})({\b UNITY_INT8} )(expected), ({\b UNITY_INT})({\b UNITY_INT8} )(actual), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_HEX8})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_EQUAL_HEX16}(expected,  actual,  line,  message)\~ {\b UnityAssertEqualNumber}(({\b UNITY_INT})({\b UNITY_INT16})(expected), ({\b UNITY_INT})({\b UNITY_INT16})(actual), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_HEX16})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_EQUAL_HEX32}(expected,  actual,  line,  message)\~ {\b UnityAssertEqualNumber}(({\b UNITY_INT})({\b UNITY_INT32})(expected), ({\b UNITY_INT})({\b UNITY_INT32})(actual), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_HEX32})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_EQUAL_CHAR}(expected,  actual,  line,  message)\~ {\b UnityAssertEqualNumber}(({\b UNITY_INT})({\b UNITY_INT8} )(expected), ({\b UNITY_INT})({\b UNITY_INT8} )(actual), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_CHAR})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_BITS}(mask,  expected,  actual,  line,  message)\~ {\b UnityAssertBits}(({\b UNITY_INT})(mask), ({\b UNITY_INT})(expected), ({\b UNITY_INT})(actual), (message), ({\b UNITY_LINE_TYPE})(line))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_NOT_EQUAL_INT}(threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})(threshold),               ({\b UNITY_INT})(actual),               {\b UNITY_NOT_EQUAL}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_INT})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_NOT_EQUAL_INT8}(threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_INT8} )(threshold),  ({\b UNITY_INT})({\b UNITY_INT8} )(actual),  {\b UNITY_NOT_EQUAL}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_INT8})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_NOT_EQUAL_INT16}(threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_INT16})(threshold),  ({\b UNITY_INT})({\b UNITY_INT16})(actual),  {\b UNITY_NOT_EQUAL}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_INT16})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_NOT_EQUAL_INT32}(threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_INT32})(threshold),  ({\b UNITY_INT})({\b UNITY_INT32})(actual),  {\b UNITY_NOT_EQUAL}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_INT32})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_NOT_EQUAL_UINT}(threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})(threshold),               ({\b UNITY_INT})(actual),               {\b UNITY_NOT_EQUAL}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_UINT})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_NOT_EQUAL_UINT8}(threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_UINT8} )(threshold), ({\b UNITY_INT})({\b UNITY_UINT8} )(actual), {\b UNITY_NOT_EQUAL}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_UINT8})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_NOT_EQUAL_UINT16}(threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_UINT16})(threshold), ({\b UNITY_INT})({\b UNITY_UINT16})(actual), {\b UNITY_NOT_EQUAL}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_UINT16})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_NOT_EQUAL_UINT32}(threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_UINT32})(threshold), ({\b UNITY_INT})({\b UNITY_UINT32})(actual), {\b UNITY_NOT_EQUAL}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_UINT32})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_NOT_EQUAL_HEX8}(threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_UINT8} )(threshold), ({\b UNITY_INT})({\b UNITY_UINT8} )(actual), {\b UNITY_NOT_EQUAL}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_HEX8})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_NOT_EQUAL_HEX16}(threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_UINT16})(threshold), ({\b UNITY_INT})({\b UNITY_UINT16})(actual), {\b UNITY_NOT_EQUAL}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_HEX16})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_NOT_EQUAL_HEX32}(threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_UINT32})(threshold), ({\b UNITY_INT})({\b UNITY_UINT32})(actual), {\b UNITY_NOT_EQUAL}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_HEX32})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_NOT_EQUAL_CHAR}(threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_INT8} )(threshold),  ({\b UNITY_INT})({\b UNITY_INT8} )(actual),  {\b UNITY_NOT_EQUAL}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_CHAR})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_GREATER_THAN_INT}(threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})(threshold),              ({\b UNITY_INT})(actual),              {\b UNITY_GREATER_THAN}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_INT})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_GREATER_THAN_INT8}(threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_INT8} )(threshold), ({\b UNITY_INT})({\b UNITY_INT8} )(actual), {\b UNITY_GREATER_THAN}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_INT8})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_GREATER_THAN_INT16}(threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_INT16})(threshold), ({\b UNITY_INT})({\b UNITY_INT16})(actual), {\b UNITY_GREATER_THAN}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_INT16})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_GREATER_THAN_INT32}(threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_INT32})(threshold), ({\b UNITY_INT})({\b UNITY_INT32})(actual), {\b UNITY_GREATER_THAN}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_INT32})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_GREATER_THAN_UINT}(threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})(threshold),              ({\b UNITY_INT})(actual),              {\b UNITY_GREATER_THAN}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_UINT})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_GREATER_THAN_UINT8}(threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_UINT8} )(threshold), ({\b UNITY_INT})({\b UNITY_UINT8} )(actual), {\b UNITY_GREATER_THAN}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_UINT8})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_GREATER_THAN_UINT16}(threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_UINT16})(threshold), ({\b UNITY_INT})({\b UNITY_UINT16})(actual), {\b UNITY_GREATER_THAN}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_UINT16})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_GREATER_THAN_UINT32}(threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_UINT32})(threshold), ({\b UNITY_INT})({\b UNITY_UINT32})(actual), {\b UNITY_GREATER_THAN}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_UINT32})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_GREATER_THAN_HEX8}(threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_UINT8} )(threshold), ({\b UNITY_INT})({\b UNITY_UINT8} )(actual), {\b UNITY_GREATER_THAN}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_HEX8})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_GREATER_THAN_HEX16}(threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_UINT16})(threshold), ({\b UNITY_INT})({\b UNITY_UINT16})(actual), {\b UNITY_GREATER_THAN}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_HEX16})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_GREATER_THAN_HEX32}(threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_UINT32})(threshold), ({\b UNITY_INT})({\b UNITY_UINT32})(actual), {\b UNITY_GREATER_THAN}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_HEX32})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_GREATER_THAN_CHAR}(threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_INT8} )(threshold), ({\b UNITY_INT})({\b UNITY_INT8} )(actual), {\b UNITY_GREATER_THAN}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_CHAR})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_SMALLER_THAN_INT}(threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})(threshold),              ({\b UNITY_INT})(actual),              {\b UNITY_SMALLER_THAN}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_INT})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_SMALLER_THAN_INT8}(threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_INT8} )(threshold), ({\b UNITY_INT})({\b UNITY_INT8} )(actual), {\b UNITY_SMALLER_THAN}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_INT8})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_SMALLER_THAN_INT16}(threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_INT16})(threshold), ({\b UNITY_INT})({\b UNITY_INT16})(actual), {\b UNITY_SMALLER_THAN}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_INT16})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_SMALLER_THAN_INT32}(threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_INT32})(threshold), ({\b UNITY_INT})({\b UNITY_INT32})(actual), {\b UNITY_SMALLER_THAN}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_INT32})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_SMALLER_THAN_UINT}(threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})(threshold),              ({\b UNITY_INT})(actual),              {\b UNITY_SMALLER_THAN}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_UINT})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_SMALLER_THAN_UINT8}(threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_UINT8} )(threshold), ({\b UNITY_INT})({\b UNITY_UINT8} )(actual), {\b UNITY_SMALLER_THAN}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_UINT8})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_SMALLER_THAN_UINT16}(threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_UINT16})(threshold), ({\b UNITY_INT})({\b UNITY_UINT16})(actual), {\b UNITY_SMALLER_THAN}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_UINT16})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_SMALLER_THAN_UINT32}(threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_UINT32})(threshold), ({\b UNITY_INT})({\b UNITY_UINT32})(actual), {\b UNITY_SMALLER_THAN}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_UINT32})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_SMALLER_THAN_HEX8}(threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_UINT8} )(threshold), ({\b UNITY_INT})({\b UNITY_UINT8} )(actual), {\b UNITY_SMALLER_THAN}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_HEX8})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_SMALLER_THAN_HEX16}(threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_UINT16})(threshold), ({\b UNITY_INT})({\b UNITY_UINT16})(actual), {\b UNITY_SMALLER_THAN}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_HEX16})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_SMALLER_THAN_HEX32}(threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_UINT32})(threshold), ({\b UNITY_INT})({\b UNITY_UINT32})(actual), {\b UNITY_SMALLER_THAN}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_HEX32})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_SMALLER_THAN_CHAR}(threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_INT8} )(threshold), ({\b UNITY_INT})({\b UNITY_INT8} )(actual), {\b UNITY_SMALLER_THAN}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_CHAR})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_INT}(threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})              (threshold), ({\b UNITY_INT})              (actual), {\b UNITY_GREATER_OR_EQUAL}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_INT})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_INT8}(threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_INT8} ) (threshold), ({\b UNITY_INT})({\b UNITY_INT8} ) (actual), {\b UNITY_GREATER_OR_EQUAL}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_INT8})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_INT16}(threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_INT16}) (threshold), ({\b UNITY_INT})({\b UNITY_INT16}) (actual), {\b UNITY_GREATER_OR_EQUAL}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_INT16})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_INT32}(threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_INT32}) (threshold), ({\b UNITY_INT})({\b UNITY_INT32}) (actual), {\b UNITY_GREATER_OR_EQUAL}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_INT32})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_UINT}(threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})              (threshold), ({\b UNITY_INT})              (actual), {\b UNITY_GREATER_OR_EQUAL}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_UINT})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_UINT8}(threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_UINT8} )(threshold), ({\b UNITY_INT})({\b UNITY_UINT8} )(actual), {\b UNITY_GREATER_OR_EQUAL}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_UINT8})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_UINT16}(threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_UINT16})(threshold), ({\b UNITY_INT})({\b UNITY_UINT16})(actual), {\b UNITY_GREATER_OR_EQUAL}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_UINT16})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_UINT32}(threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_UINT32})(threshold), ({\b UNITY_INT})({\b UNITY_UINT32})(actual), {\b UNITY_GREATER_OR_EQUAL}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_UINT32})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_HEX8}(threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_UINT8} )(threshold), ({\b UNITY_INT})({\b UNITY_UINT8} )(actual), {\b UNITY_GREATER_OR_EQUAL}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_HEX8})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_HEX16}(threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_UINT16})(threshold), ({\b UNITY_INT})({\b UNITY_UINT16})(actual), {\b UNITY_GREATER_OR_EQUAL}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_HEX16})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_HEX32}(threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_UINT32})(threshold), ({\b UNITY_INT})({\b UNITY_UINT32})(actual), {\b UNITY_GREATER_OR_EQUAL}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_HEX32})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_CHAR}(threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_INT8} ) (threshold), ({\b UNITY_INT})({\b UNITY_INT8} ) (actual), {\b UNITY_GREATER_OR_EQUAL}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_CHAR})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_INT}(threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})             (threshold),  ({\b UNITY_INT})              (actual), {\b UNITY_SMALLER_OR_EQUAL}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_INT})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_INT8}(threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_INT8} )(threshold),  ({\b UNITY_INT})({\b UNITY_INT8} ) (actual), {\b UNITY_SMALLER_OR_EQUAL}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_INT8})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_INT16}(threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_INT16})(threshold),  ({\b UNITY_INT})({\b UNITY_INT16}) (actual), {\b UNITY_SMALLER_OR_EQUAL}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_INT16})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_INT32}(threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_INT32})(threshold),  ({\b UNITY_INT})({\b UNITY_INT32}) (actual), {\b UNITY_SMALLER_OR_EQUAL}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_INT32})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_UINT}(threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})             (threshold),  ({\b UNITY_INT})              (actual), {\b UNITY_SMALLER_OR_EQUAL}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_UINT})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_UINT8}(threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_UINT8} )(threshold), ({\b UNITY_INT})({\b UNITY_UINT8} )(actual), {\b UNITY_SMALLER_OR_EQUAL}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_UINT8})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_UINT16}(threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_UINT16})(threshold), ({\b UNITY_INT})({\b UNITY_UINT16})(actual), {\b UNITY_SMALLER_OR_EQUAL}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_UINT16})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_UINT32}(threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_UINT32})(threshold), ({\b UNITY_INT})({\b UNITY_UINT32})(actual), {\b UNITY_SMALLER_OR_EQUAL}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_UINT32})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_HEX8}(threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_UINT8} )(threshold), ({\b UNITY_INT})({\b UNITY_UINT8} )(actual), {\b UNITY_SMALLER_OR_EQUAL}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_HEX8})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_HEX16}(threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_UINT16})(threshold), ({\b UNITY_INT})({\b UNITY_UINT16})(actual), {\b UNITY_SMALLER_OR_EQUAL}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_HEX16})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_HEX32}(threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_UINT32})(threshold), ({\b UNITY_INT})({\b UNITY_UINT32})(actual), {\b UNITY_SMALLER_OR_EQUAL}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_HEX32})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_CHAR}(threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_INT8} )(threshold),  ({\b UNITY_INT})({\b UNITY_INT8} ) (actual), {\b UNITY_SMALLER_OR_EQUAL}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_CHAR})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_INT_WITHIN}(delta,  expected,  actual,  line,  message)\~ {\b UnityAssertNumbersWithin}(              (delta), ({\b UNITY_INT})                          (expected), ({\b UNITY_INT})                          (actual), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_INT})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_INT8_WITHIN}(delta,  expected,  actual,  line,  message)\~ {\b UnityAssertNumbersWithin}(({\b UNITY_UINT8} )(delta), ({\b UNITY_INT})({\b UNITY_INT8} )             (expected), ({\b UNITY_INT})({\b UNITY_INT8} )             (actual), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_INT8})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_INT16_WITHIN}(delta,  expected,  actual,  line,  message)\~ {\b UnityAssertNumbersWithin}(({\b UNITY_UINT16})(delta), ({\b UNITY_INT})({\b UNITY_INT16})             (expected), ({\b UNITY_INT})({\b UNITY_INT16})             (actual), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_INT16})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_INT32_WITHIN}(delta,  expected,  actual,  line,  message)\~ {\b UnityAssertNumbersWithin}(({\b UNITY_UINT32})(delta), ({\b UNITY_INT})({\b UNITY_INT32})             (expected), ({\b UNITY_INT})({\b UNITY_INT32})             (actual), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_INT32})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_UINT_WITHIN}(delta,  expected,  actual,  line,  message)\~ {\b UnityAssertNumbersWithin}(              (delta), ({\b UNITY_INT})                          (expected), ({\b UNITY_INT})                          (actual), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_UINT})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_UINT8_WITHIN}(delta,  expected,  actual,  line,  message)\~ {\b UnityAssertNumbersWithin}(({\b UNITY_UINT8} )(delta), ({\b UNITY_INT})({\b UNITY_UINT})({\b UNITY_UINT8} )(expected), ({\b UNITY_INT})({\b UNITY_UINT})({\b UNITY_UINT8} )(actual), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_UINT8})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_UINT16_WITHIN}(delta,  expected,  actual,  line,  message)\~ {\b UnityAssertNumbersWithin}(({\b UNITY_UINT16})(delta), ({\b UNITY_INT})({\b UNITY_UINT})({\b UNITY_UINT16})(expected), ({\b UNITY_INT})({\b UNITY_UINT})({\b UNITY_UINT16})(actual), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_UINT16})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_UINT32_WITHIN}(delta,  expected,  actual,  line,  message)\~ {\b UnityAssertNumbersWithin}(({\b UNITY_UINT32})(delta), ({\b UNITY_INT})({\b UNITY_UINT})({\b UNITY_UINT32})(expected), ({\b UNITY_INT})({\b UNITY_UINT})({\b UNITY_UINT32})(actual), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_UINT32})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_HEX8_WITHIN}(delta,  expected,  actual,  line,  message)\~ {\b UnityAssertNumbersWithin}(({\b UNITY_UINT8} )(delta), ({\b UNITY_INT})({\b UNITY_UINT})({\b UNITY_UINT8} )(expected), ({\b UNITY_INT})({\b UNITY_UINT})({\b UNITY_UINT8} )(actual), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_HEX8})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_HEX16_WITHIN}(delta,  expected,  actual,  line,  message)\~ {\b UnityAssertNumbersWithin}(({\b UNITY_UINT16})(delta), ({\b UNITY_INT})({\b UNITY_UINT})({\b UNITY_UINT16})(expected), ({\b UNITY_INT})({\b UNITY_UINT})({\b UNITY_UINT16})(actual), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_HEX16})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_HEX32_WITHIN}(delta,  expected,  actual,  line,  message)\~ {\b UnityAssertNumbersWithin}(({\b UNITY_UINT32})(delta), ({\b UNITY_INT})({\b UNITY_UINT})({\b UNITY_UINT32})(expected), ({\b UNITY_INT})({\b UNITY_UINT})({\b UNITY_UINT32})(actual), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_HEX32})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_CHAR_WITHIN}(delta,  expected,  actual,  line,  message)\~ {\b UnityAssertNumbersWithin}(({\b UNITY_UINT8} )(delta), ({\b UNITY_INT})({\b UNITY_INT8} )             (expected), ({\b UNITY_INT})({\b UNITY_INT8} )             (actual), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_CHAR})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_INT_ARRAY_WITHIN}(delta,  expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertNumbersArrayWithin}(              (delta), ({\b UNITY_INTERNAL_PTR})(expected), ({\b UNITY_INTERNAL_PTR})(actual), (({\b UNITY_UINT32})(num_elements)), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_INT}, {\b UNITY_ARRAY_TO_ARRAY})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_INT8_ARRAY_WITHIN}(delta,  expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertNumbersArrayWithin}(({\b UNITY_UINT8} )(delta), ({\b UNITY_INTERNAL_PTR})(expected), ({\b UNITY_INTERNAL_PTR})(actual), (({\b UNITY_UINT32})(num_elements)), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_INT8}, {\b UNITY_ARRAY_TO_ARRAY})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_INT16_ARRAY_WITHIN}(delta,  expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertNumbersArrayWithin}(({\b UNITY_UINT16})(delta), ({\b UNITY_INTERNAL_PTR})(expected), ({\b UNITY_INTERNAL_PTR})(actual), (({\b UNITY_UINT32})(num_elements)), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_INT16}, {\b UNITY_ARRAY_TO_ARRAY})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_INT32_ARRAY_WITHIN}(delta,  expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertNumbersArrayWithin}(({\b UNITY_UINT32})(delta), ({\b UNITY_INTERNAL_PTR})(expected), ({\b UNITY_INTERNAL_PTR})(actual), (({\b UNITY_UINT32})(num_elements)), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_INT32}, {\b UNITY_ARRAY_TO_ARRAY})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_UINT_ARRAY_WITHIN}(delta,  expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertNumbersArrayWithin}(              (delta), ({\b UNITY_INTERNAL_PTR})(expected), ({\b UNITY_INTERNAL_PTR})(actual), (({\b UNITY_UINT32})(num_elements)), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_UINT}, {\b UNITY_ARRAY_TO_ARRAY})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_UINT8_ARRAY_WITHIN}(delta,  expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertNumbersArrayWithin}(({\b UNITY_UINT8} )(delta), ({\b UNITY_INTERNAL_PTR})(expected), ({\b UNITY_INTERNAL_PTR})(actual), (({\b UNITY_UINT32})(num_elements)), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_UINT8}, {\b UNITY_ARRAY_TO_ARRAY})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_UINT16_ARRAY_WITHIN}(delta,  expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertNumbersArrayWithin}(({\b UNITY_UINT16})(delta), ({\b UNITY_INTERNAL_PTR})(expected), ({\b UNITY_INTERNAL_PTR})(actual), (({\b UNITY_UINT32})(num_elements)), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_UINT16}, {\b UNITY_ARRAY_TO_ARRAY})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_UINT32_ARRAY_WITHIN}(delta,  expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertNumbersArrayWithin}(({\b UNITY_UINT32})(delta), ({\b UNITY_INTERNAL_PTR})(expected), ({\b UNITY_INTERNAL_PTR})(actual), (({\b UNITY_UINT32})(num_elements)), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_UINT32}, {\b UNITY_ARRAY_TO_ARRAY})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_HEX8_ARRAY_WITHIN}(delta,  expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertNumbersArrayWithin}(({\b UNITY_UINT8} )(delta), ({\b UNITY_INTERNAL_PTR})(expected), ({\b UNITY_INTERNAL_PTR})(actual), (({\b UNITY_UINT32})(num_elements)), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_HEX8}, {\b UNITY_ARRAY_TO_ARRAY})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_HEX16_ARRAY_WITHIN}(delta,  expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertNumbersArrayWithin}(({\b UNITY_UINT16})(delta), ({\b UNITY_INTERNAL_PTR})(expected), ({\b UNITY_INTERNAL_PTR})(actual), (({\b UNITY_UINT32})(num_elements)), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_HEX16}, {\b UNITY_ARRAY_TO_ARRAY})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_HEX32_ARRAY_WITHIN}(delta,  expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertNumbersArrayWithin}(({\b UNITY_UINT32})(delta), ({\b UNITY_INTERNAL_PTR})(expected), ({\b UNITY_INTERNAL_PTR})(actual), (({\b UNITY_UINT32})(num_elements)), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_HEX32}, {\b UNITY_ARRAY_TO_ARRAY})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_CHAR_ARRAY_WITHIN}(delta,  expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertNumbersArrayWithin}(({\b UNITY_UINT8} )(delta), ({\b UNITY_INTERNAL_PTR})(expected), ({\b UNITY_INTERNAL_PTR})(actual), (({\b UNITY_UINT32})(num_elements)), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_CHAR}, {\b UNITY_ARRAY_TO_ARRAY})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_EQUAL_PTR}(expected,  actual,  line,  message)\~ {\b UnityAssertEqualNumber}(({\b UNITY_PTR_TO_INT})(expected), ({\b UNITY_PTR_TO_INT})(actual), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_POINTER})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_EQUAL_STRING}(expected,  actual,  line,  message)\~ {\b UnityAssertEqualString}((const char*)(expected), (const char*)(actual), (message), ({\b UNITY_LINE_TYPE})(line))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_EQUAL_STRING_LEN}(expected,  actual,  len,  line,  message)\~ {\b UnityAssertEqualStringLen}((const char*)(expected), (const char*)(actual), ({\b UNITY_UINT32})(len), (message), ({\b UNITY_LINE_TYPE})(line))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_EQUAL_MEMORY}(expected,  actual,  len,  line,  message)\~ {\b UnityAssertEqualMemory}(({\b UNITY_INTERNAL_PTR})(expected), ({\b UNITY_INTERNAL_PTR})(actual), ({\b UNITY_UINT32})(len), 1, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_ARRAY_TO_ARRAY})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_EQUAL_INT_ARRAY}(expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertEqualIntArray}(({\b UNITY_INTERNAL_PTR})(expected), ({\b UNITY_INTERNAL_PTR})(actual), ({\b UNITY_UINT32})(num_elements), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_INT},     {\b UNITY_ARRAY_TO_ARRAY})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_EQUAL_INT8_ARRAY}(expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertEqualIntArray}(({\b UNITY_INTERNAL_PTR})(expected), ({\b UNITY_INTERNAL_PTR})(actual), ({\b UNITY_UINT32})(num_elements), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_INT8},    {\b UNITY_ARRAY_TO_ARRAY})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_EQUAL_INT16_ARRAY}(expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertEqualIntArray}(({\b UNITY_INTERNAL_PTR})(expected), ({\b UNITY_INTERNAL_PTR})(actual), ({\b UNITY_UINT32})(num_elements), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_INT16},   {\b UNITY_ARRAY_TO_ARRAY})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_EQUAL_INT32_ARRAY}(expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertEqualIntArray}(({\b UNITY_INTERNAL_PTR})(expected), ({\b UNITY_INTERNAL_PTR})(actual), ({\b UNITY_UINT32})(num_elements), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_INT32},   {\b UNITY_ARRAY_TO_ARRAY})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_EQUAL_UINT_ARRAY}(expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertEqualIntArray}(({\b UNITY_INTERNAL_PTR})(expected), ({\b UNITY_INTERNAL_PTR})(actual), ({\b UNITY_UINT32})(num_elements), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_UINT},    {\b UNITY_ARRAY_TO_ARRAY})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_EQUAL_UINT8_ARRAY}(expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertEqualIntArray}(({\b UNITY_INTERNAL_PTR})(expected), ({\b UNITY_INTERNAL_PTR})(actual), ({\b UNITY_UINT32})(num_elements), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_UINT8},   {\b UNITY_ARRAY_TO_ARRAY})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_EQUAL_UINT16_ARRAY}(expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertEqualIntArray}(({\b UNITY_INTERNAL_PTR})(expected), ({\b UNITY_INTERNAL_PTR})(actual), ({\b UNITY_UINT32})(num_elements), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_UINT16},  {\b UNITY_ARRAY_TO_ARRAY})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_EQUAL_UINT32_ARRAY}(expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertEqualIntArray}(({\b UNITY_INTERNAL_PTR})(expected), ({\b UNITY_INTERNAL_PTR})(actual), ({\b UNITY_UINT32})(num_elements), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_UINT32},  {\b UNITY_ARRAY_TO_ARRAY})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY}(expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertEqualIntArray}(({\b UNITY_INTERNAL_PTR})(expected), ({\b UNITY_INTERNAL_PTR})(actual), ({\b UNITY_UINT32})(num_elements), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_HEX8},    {\b UNITY_ARRAY_TO_ARRAY})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_EQUAL_HEX16_ARRAY}(expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertEqualIntArray}(({\b UNITY_INTERNAL_PTR})(expected), ({\b UNITY_INTERNAL_PTR})(actual), ({\b UNITY_UINT32})(num_elements), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_HEX16},   {\b UNITY_ARRAY_TO_ARRAY})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_EQUAL_HEX32_ARRAY}(expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertEqualIntArray}(({\b UNITY_INTERNAL_PTR})(expected), ({\b UNITY_INTERNAL_PTR})(actual), ({\b UNITY_UINT32})(num_elements), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_HEX32},   {\b UNITY_ARRAY_TO_ARRAY})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_EQUAL_PTR_ARRAY}(expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertEqualIntArray}(({\b UNITY_INTERNAL_PTR})(expected), ({\b UNITY_INTERNAL_PTR})(actual), ({\b UNITY_UINT32})(num_elements), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_POINTER}, {\b UNITY_ARRAY_TO_ARRAY})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_EQUAL_STRING_ARRAY}(expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertEqualStringArray}(({\b UNITY_INTERNAL_PTR})(expected), (const char**)(actual), ({\b UNITY_UINT32})(num_elements), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_ARRAY_TO_ARRAY})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY}(expected,  actual,  len,  num_elements,  line,  message)\~ {\b UnityAssertEqualMemory}(({\b UNITY_INTERNAL_PTR})(expected), ({\b UNITY_INTERNAL_PTR})(actual), ({\b UNITY_UINT32})(len), ({\b UNITY_UINT32})(num_elements), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_ARRAY_TO_ARRAY})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_EQUAL_CHAR_ARRAY}(expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertEqualIntArray}(({\b UNITY_INTERNAL_PTR})(expected), ({\b UNITY_INTERNAL_PTR})(actual), ({\b UNITY_UINT32})(num_elements), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_CHAR},    {\b UNITY_ARRAY_TO_ARRAY})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_EACH_EQUAL_INT}(expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertEqualIntArray}({\b UnityNumToPtr}(({\b UNITY_INT})              (expected), ({\b UNITY_INT_WIDTH} / 8)),          ({\b UNITY_INTERNAL_PTR})(actual), ({\b UNITY_UINT32})(num_elements), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_INT},     {\b UNITY_ARRAY_TO_VAL})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_EACH_EQUAL_INT8}(expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertEqualIntArray}({\b UnityNumToPtr}(({\b UNITY_INT})({\b UNITY_INT8}  )(expected), 1),                              ({\b UNITY_INTERNAL_PTR})(actual), ({\b UNITY_UINT32})(num_elements), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_INT8},    {\b UNITY_ARRAY_TO_VAL})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_EACH_EQUAL_INT16}(expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertEqualIntArray}({\b UnityNumToPtr}(({\b UNITY_INT})({\b UNITY_INT16} )(expected), 2),                              ({\b UNITY_INTERNAL_PTR})(actual), ({\b UNITY_UINT32})(num_elements), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_INT16},   {\b UNITY_ARRAY_TO_VAL})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_EACH_EQUAL_INT32}(expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertEqualIntArray}({\b UnityNumToPtr}(({\b UNITY_INT})({\b UNITY_INT32} )(expected), 4),                              ({\b UNITY_INTERNAL_PTR})(actual), ({\b UNITY_UINT32})(num_elements), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_INT32},   {\b UNITY_ARRAY_TO_VAL})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_EACH_EQUAL_UINT}(expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertEqualIntArray}({\b UnityNumToPtr}(({\b UNITY_INT})              (expected), ({\b UNITY_INT_WIDTH} / 8)),          ({\b UNITY_INTERNAL_PTR})(actual), ({\b UNITY_UINT32})(num_elements), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_UINT},    {\b UNITY_ARRAY_TO_VAL})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_EACH_EQUAL_UINT8}(expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertEqualIntArray}({\b UnityNumToPtr}(({\b UNITY_INT})({\b UNITY_UINT8} )(expected), 1),                              ({\b UNITY_INTERNAL_PTR})(actual), ({\b UNITY_UINT32})(num_elements), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_UINT8},   {\b UNITY_ARRAY_TO_VAL})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_EACH_EQUAL_UINT16}(expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertEqualIntArray}({\b UnityNumToPtr}(({\b UNITY_INT})({\b UNITY_UINT16})(expected), 2),                              ({\b UNITY_INTERNAL_PTR})(actual), ({\b UNITY_UINT32})(num_elements), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_UINT16},  {\b UNITY_ARRAY_TO_VAL})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_EACH_EQUAL_UINT32}(expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertEqualIntArray}({\b UnityNumToPtr}(({\b UNITY_INT})({\b UNITY_UINT32})(expected), 4),                              ({\b UNITY_INTERNAL_PTR})(actual), ({\b UNITY_UINT32})(num_elements), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_UINT32},  {\b UNITY_ARRAY_TO_VAL})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_EACH_EQUAL_HEX8}(expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertEqualIntArray}({\b UnityNumToPtr}(({\b UNITY_INT})({\b UNITY_INT8}  )(expected), 1),                              ({\b UNITY_INTERNAL_PTR})(actual), ({\b UNITY_UINT32})(num_elements), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_HEX8},    {\b UNITY_ARRAY_TO_VAL})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_EACH_EQUAL_HEX16}(expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertEqualIntArray}({\b UnityNumToPtr}(({\b UNITY_INT})({\b UNITY_INT16} )(expected), 2),                              ({\b UNITY_INTERNAL_PTR})(actual), ({\b UNITY_UINT32})(num_elements), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_HEX16},   {\b UNITY_ARRAY_TO_VAL})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_EACH_EQUAL_HEX32}(expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertEqualIntArray}({\b UnityNumToPtr}(({\b UNITY_INT})({\b UNITY_INT32} )(expected), 4),                              ({\b UNITY_INTERNAL_PTR})(actual), ({\b UNITY_UINT32})(num_elements), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_HEX32},   {\b UNITY_ARRAY_TO_VAL})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_EACH_EQUAL_PTR}(expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertEqualIntArray}({\b UnityNumToPtr}(({\b UNITY_PTR_TO_INT})       (expected), ({\b UNITY_POINTER_WIDTH} / 8)),      ({\b UNITY_INTERNAL_PTR})(actual), ({\b UNITY_UINT32})(num_elements), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_POINTER}, {\b UNITY_ARRAY_TO_VAL})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_EACH_EQUAL_STRING}(expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertEqualStringArray}(({\b UNITY_INTERNAL_PTR})(expected), (const char**)(actual), ({\b UNITY_UINT32})(num_elements), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_ARRAY_TO_VAL})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_EACH_EQUAL_MEMORY}(expected,  actual,  len,  num_elements,  line,  message)\~ {\b UnityAssertEqualMemory}(({\b UNITY_INTERNAL_PTR})(expected), ({\b UNITY_INTERNAL_PTR})(actual), ({\b UNITY_UINT32})(len), ({\b UNITY_UINT32})(num_elements), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_ARRAY_TO_VAL})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_EACH_EQUAL_CHAR}(expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertEqualIntArray}({\b UnityNumToPtr}(({\b UNITY_INT})({\b UNITY_INT8}  )(expected), 1),                              ({\b UNITY_INTERNAL_PTR})(actual), ({\b UNITY_UINT32})(num_elements), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_CHAR},    {\b UNITY_ARRAY_TO_VAL})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_EQUAL_INT64}(expected,  actual,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErr64})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_EQUAL_UINT64}(expected,  actual,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErr64})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_EQUAL_HEX64}(expected,  actual,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErr64})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_EQUAL_INT64_ARRAY}(expected,  actual,  num_elements,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErr64})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_EQUAL_UINT64_ARRAY}(expected,  actual,  num_elements,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErr64})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_EQUAL_HEX64_ARRAY}(expected,  actual,  num_elements,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErr64})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_INT64_WITHIN}(delta,  expected,  actual,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErr64})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_UINT64_WITHIN}(delta,  expected,  actual,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErr64})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_HEX64_WITHIN}(delta,  expected,  actual,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErr64})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_GREATER_THAN_INT64}(threshold,  actual,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErr64})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_GREATER_THAN_UINT64}(threshold,  actual,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErr64})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_GREATER_THAN_HEX64}(threshold,  actual,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErr64})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_INT64}(threshold,  actual,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErr64})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_UINT64}(threshold,  actual,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErr64})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_HEX64}(threshold,  actual,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErr64})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_SMALLER_THAN_INT64}(threshold,  actual,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErr64})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_SMALLER_THAN_UINT64}(threshold,  actual,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErr64})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_SMALLER_THAN_HEX64}(threshold,  actual,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErr64})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_INT64}(threshold,  actual,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErr64})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_UINT64}(threshold,  actual,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErr64})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_HEX64}(threshold,  actual,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErr64})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_INT64_ARRAY_WITHIN}(delta,  expected,  actual,  num_elements,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErr64})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_UINT64_ARRAY_WITHIN}(delta,  expected,  actual,  num_elements,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErr64})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_HEX64_ARRAY_WITHIN}(delta,  expected,  actual,  num_elements,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErr64})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_FLOAT_WITHIN}(delta,  expected,  actual,  line,  message)\~ {\b UnityAssertFloatsWithin}(({\b UNITY_FLOAT})(delta), ({\b UNITY_FLOAT})(expected), ({\b UNITY_FLOAT})(actual), (message), ({\b UNITY_LINE_TYPE})(line))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_FLOAT_NOT_WITHIN}(delta,  expected,  actual,  line,  message)\~ {\b UnityAssertFloatsNotWithin}(({\b UNITY_FLOAT})(delta), ({\b UNITY_FLOAT})(expected), ({\b UNITY_FLOAT})(actual), (message), ({\b UNITY_LINE_TYPE})(line))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_EQUAL_FLOAT}(expected,  actual,  line,  message)\~ {\b UNITY_TEST_ASSERT_FLOAT_WITHIN}(({\b UNITY_FLOAT})(expected) * ({\b UNITY_FLOAT}){\b UNITY_FLOAT_PRECISION}, ({\b UNITY_FLOAT})(expected), ({\b UNITY_FLOAT})(actual), ({\b UNITY_LINE_TYPE})(line), (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_NOT_EQUAL_FLOAT}(expected,  actual,  line,  message)\~ {\b UNITY_TEST_ASSERT_FLOAT_NOT_WITHIN}(({\b UNITY_FLOAT})(expected) * ({\b UNITY_FLOAT}){\b UNITY_FLOAT_PRECISION}, ({\b UNITY_FLOAT})(expected), ({\b UNITY_FLOAT})(actual), ({\b UNITY_LINE_TYPE})(line), (message))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_FLOAT_ARRAY_WITHIN}(delta,  expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertWithinFloatArray}(({\b UNITY_FLOAT})(delta), (const {\b UNITY_FLOAT}*)(expected), (const {\b UNITY_FLOAT}*)(actual), ({\b UNITY_UINT32})(num_elements), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_ARRAY_TO_ARRAY})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_EQUAL_FLOAT_ARRAY}(expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertWithinFloatArray}(({\b UNITY_FLOAT})0, (const {\b UNITY_FLOAT}*)(expected), (const {\b UNITY_FLOAT}*)(actual), ({\b UNITY_UINT32})(num_elements), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_ARRAY_TO_ARRAY})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_EACH_EQUAL_FLOAT}(expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertWithinFloatArray}(({\b UNITY_FLOAT})0, {\b UnityFloatToPtr}(expected), (const {\b UNITY_FLOAT}*)(actual), ({\b UNITY_UINT32})(num_elements), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_ARRAY_TO_VAL})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_GREATER_THAN_FLOAT}(threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessFloat}(({\b UNITY_FLOAT})(threshold), ({\b UNITY_FLOAT})(actual), {\b UNITY_GREATER_THAN}, (message), ({\b UNITY_LINE_TYPE})(line))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_FLOAT}(threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessFloat}(({\b UNITY_FLOAT})(threshold), ({\b UNITY_FLOAT})(actual), {\b UNITY_GREATER_OR_EQUAL}, (message), ({\b UNITY_LINE_TYPE})(line))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_LESS_THAN_FLOAT}(threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessFloat}(({\b UNITY_FLOAT})(threshold), ({\b UNITY_FLOAT})(actual), {\b UNITY_SMALLER_THAN}, (message), ({\b UNITY_LINE_TYPE})(line))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_LESS_OR_EQUAL_FLOAT}(threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessFloat}(({\b UNITY_FLOAT})(threshold), ({\b UNITY_FLOAT})(actual), {\b UNITY_SMALLER_OR_EQUAL}, (message), ({\b UNITY_LINE_TYPE})(line))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_FLOAT_IS_INF}(actual,  line,  message)\~ {\b UnityAssertFloatSpecial}(({\b UNITY_FLOAT})(actual), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_FLOAT_IS_INF})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_FLOAT_IS_NEG_INF}(actual,  line,  message)\~ {\b UnityAssertFloatSpecial}(({\b UNITY_FLOAT})(actual), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_FLOAT_IS_NEG_INF})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_FLOAT_IS_NAN}(actual,  line,  message)\~ {\b UnityAssertFloatSpecial}(({\b UNITY_FLOAT})(actual), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_FLOAT_IS_NAN})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_FLOAT_IS_DETERMINATE}(actual,  line,  message)\~ {\b UnityAssertFloatSpecial}(({\b UNITY_FLOAT})(actual), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_FLOAT_IS_DET})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_FLOAT_IS_NOT_INF}(actual,  line,  message)\~ {\b UnityAssertFloatSpecial}(({\b UNITY_FLOAT})(actual), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_FLOAT_IS_NOT_INF})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_FLOAT_IS_NOT_NEG_INF}(actual,  line,  message)\~ {\b UnityAssertFloatSpecial}(({\b UNITY_FLOAT})(actual), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_FLOAT_IS_NOT_NEG_INF})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_FLOAT_IS_NOT_NAN}(actual,  line,  message)\~ {\b UnityAssertFloatSpecial}(({\b UNITY_FLOAT})(actual), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_FLOAT_IS_NOT_NAN})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_FLOAT_IS_NOT_DETERMINATE}(actual,  line,  message)\~ {\b UnityAssertFloatSpecial}(({\b UNITY_FLOAT})(actual), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_FLOAT_IS_NOT_DET})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_DOUBLE_WITHIN}(delta,  expected,  actual,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErrDouble})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_DOUBLE_NOT_WITHIN}(delta,  expected,  actual,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErrDouble})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_EQUAL_DOUBLE}(expected,  actual,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErrDouble})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_NOT_EQUAL_DOUBLE}(expected,  actual,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErrDouble})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_DOUBLE_ARRAY_WITHIN}(delta,  expected,  actual,  num_elements,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErrDouble})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_EQUAL_DOUBLE_ARRAY}(expected,  actual,  num_elements,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErrDouble})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_EACH_EQUAL_DOUBLE}(expected,  actual,  num_elements,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErrDouble})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_GREATER_THAN_DOUBLE}(threshold,  actual,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErrDouble})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_GREATER_OR_EQUAL_DOUBLE}(threshold,  actual,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErrDouble})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_LESS_THAN_DOUBLE}(threshold,  actual,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErrDouble})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_LESS_OR_EQUAL_DOUBLE}(threshold,  actual,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErrDouble})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_DOUBLE_IS_INF}(actual,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErrDouble})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_DOUBLE_IS_NEG_INF}(actual,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErrDouble})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_DOUBLE_IS_NAN}(actual,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErrDouble})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_DOUBLE_IS_DETERMINATE}(actual,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErrDouble})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_DOUBLE_IS_NOT_INF}(actual,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErrDouble})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_DOUBLE_IS_NOT_NEG_INF}(actual,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErrDouble})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_DOUBLE_IS_NOT_NAN}(actual,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErrDouble})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNITY_TEST_ASSERT_DOUBLE_IS_NOT_DETERMINATE}(actual,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErrDouble})\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef unsigned char {\b UNITY_UINT8}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef unsigned short {\b UNITY_UINT16}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef unsigned int {\b UNITY_UINT32}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef signed char {\b UNITY_INT8}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef signed short {\b UNITY_INT16}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef signed int {\b UNITY_INT32}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b UNITY_UINT32} {\b UNITY_UINT}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b UNITY_INT32} {\b UNITY_INT}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b UNITY_FLOAT_TYPE} {\b UNITY_FLOAT}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b UNITY_FLOAT} {\b UNITY_DOUBLE}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef void(* {\b UnityTestFunction}) (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef enum {\b UNITY_FLOAT_TRAIT} {\b UNITY_FLOAT_TRAIT_T}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b UNITY_DISPLAY_STYLE_T} \{ {\b UNITY_DISPLAY_STYLE_INT} = (UNITY_INT_WIDTH / 8) + UNITY_DISPLAY_RANGE_INT
, {\b UNITY_DISPLAY_STYLE_INT8} = 1 + UNITY_DISPLAY_RANGE_INT
, {\b UNITY_DISPLAY_STYLE_INT16} = 2 + UNITY_DISPLAY_RANGE_INT
, {\b UNITY_DISPLAY_STYLE_INT32} = 4 + UNITY_DISPLAY_RANGE_INT
, {\b UNITY_DISPLAY_STYLE_UINT} = (UNITY_INT_WIDTH / 8) + UNITY_DISPLAY_RANGE_UINT
, {\b UNITY_DISPLAY_STYLE_UINT8} = 1 + UNITY_DISPLAY_RANGE_UINT
, {\b UNITY_DISPLAY_STYLE_UINT16} = 2 + UNITY_DISPLAY_RANGE_UINT
, {\b UNITY_DISPLAY_STYLE_UINT32} = 4 + UNITY_DISPLAY_RANGE_UINT
, {\b UNITY_DISPLAY_STYLE_HEX8} = 1 + UNITY_DISPLAY_RANGE_HEX
, {\b UNITY_DISPLAY_STYLE_HEX16} = 2 + UNITY_DISPLAY_RANGE_HEX
, {\b UNITY_DISPLAY_STYLE_HEX32} = 4 + UNITY_DISPLAY_RANGE_HEX
, {\b UNITY_DISPLAY_STYLE_CHAR} = 1 + UNITY_DISPLAY_RANGE_CHAR + UNITY_DISPLAY_RANGE_INT
, {\b UNITY_DISPLAY_STYLE_UNKNOWN}
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b UNITY_COMPARISON_T} \{ {\b UNITY_WITHIN} = 0x0
, {\b UNITY_EQUAL_TO} = 0x1
, {\b UNITY_GREATER_THAN} = 0x2
, {\b UNITY_GREATER_OR_EQUAL} = 0x2 + UNITY_EQUAL_TO
, {\b UNITY_SMALLER_THAN} = 0x4
, {\b UNITY_SMALLER_OR_EQUAL} = 0x4 + UNITY_EQUAL_TO
, {\b UNITY_NOT_EQUAL} = 0x0
, {\b UNITY_UNKNOWN}
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b UNITY_FLOAT_TRAIT} \{ {\b UNITY_FLOAT_IS_NOT_INF} = 0
, {\b UNITY_FLOAT_IS_INF}
, {\b UNITY_FLOAT_IS_NOT_NEG_INF}
, {\b UNITY_FLOAT_IS_NEG_INF}
, {\b UNITY_FLOAT_IS_NOT_NAN}
, {\b UNITY_FLOAT_IS_NAN}
, {\b UNITY_FLOAT_IS_NOT_DET}
, {\b UNITY_FLOAT_IS_DET}
, {\b UNITY_FLOAT_INVALID_TRAIT}
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b UNITY_FLAGS_T} \{ {\b UNITY_ARRAY_TO_VAL} = 0
, {\b UNITY_ARRAY_TO_ARRAY}
, {\b UNITY_ARRAY_UNKNOWN}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UnityBegin} (const char *filename)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b UnityEnd} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UnitySetTestFile} (const char *filename)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UnityConcludeTest} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UnityDefaultTestRun} ({\b UnityTestFunction} Func, const char *FuncName, const int FuncLineNum)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UnityPrint} (const char *string)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UnityPrintLen} (const char *string, const {\b UNITY_UINT32} length)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UnityPrintMask} (const {\b UNITY_UINT} mask, const {\b UNITY_UINT} number)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UnityPrintNumberByStyle} (const {\b UNITY_INT} number, const {\b UNITY_DISPLAY_STYLE_T} style)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UnityPrintNumber} (const {\b UNITY_INT} number_to_print)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UnityPrintNumberUnsigned} (const {\b UNITY_UINT} number)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UnityPrintNumberHex} (const {\b UNITY_UINT} number, const char nibbles_to_print)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UnityPrintFloat} (const {\b UNITY_DOUBLE} input_number)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UnityAssertEqualNumber} (const {\b UNITY_INT} expected, const {\b UNITY_INT} actual, const char *msg, const {\b UNITY_LINE_TYPE} lineNumber, const {\b UNITY_DISPLAY_STYLE_T} style)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UnityAssertGreaterOrLessOrEqualNumber} (const {\b UNITY_INT} threshold, const {\b UNITY_INT} actual, const {\b UNITY_COMPARISON_T} compare, const char *msg, const {\b UNITY_LINE_TYPE} lineNumber, const {\b UNITY_DISPLAY_STYLE_T} style)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UnityAssertEqualIntArray} ({\b UNITY_INTERNAL_PTR} expected, {\b UNITY_INTERNAL_PTR} actual, const {\b UNITY_UINT32} num_elements, const char *msg, const {\b UNITY_LINE_TYPE} lineNumber, const {\b UNITY_DISPLAY_STYLE_T} style, const {\b UNITY_FLAGS_T} flags)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UnityAssertBits} (const {\b UNITY_INT} mask, const {\b UNITY_INT} expected, const {\b UNITY_INT} actual, const char *msg, const {\b UNITY_LINE_TYPE} lineNumber)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UnityAssertEqualString} (const char *expected, const char *actual, const char *msg, const {\b UNITY_LINE_TYPE} lineNumber)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UnityAssertEqualStringLen} (const char *expected, const char *actual, const {\b UNITY_UINT32} length, const char *msg, const {\b UNITY_LINE_TYPE} lineNumber)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UnityAssertEqualStringArray} ({\b UNITY_INTERNAL_PTR} expected, const char **actual, const {\b UNITY_UINT32} num_elements, const char *msg, const {\b UNITY_LINE_TYPE} lineNumber, const {\b UNITY_FLAGS_T} flags)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UnityAssertEqualMemory} ({\b UNITY_INTERNAL_PTR} expected, {\b UNITY_INTERNAL_PTR} actual, const {\b UNITY_UINT32} length, const {\b UNITY_UINT32} num_elements, const char *msg, const {\b UNITY_LINE_TYPE} lineNumber, const {\b UNITY_FLAGS_T} flags)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UnityAssertNumbersWithin} (const {\b UNITY_UINT} delta, const {\b UNITY_INT} expected, const {\b UNITY_INT} actual, const char *msg, const {\b UNITY_LINE_TYPE} lineNumber, const {\b UNITY_DISPLAY_STYLE_T} style)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UnityAssertNumbersArrayWithin} (const {\b UNITY_UINT} delta, {\b UNITY_INTERNAL_PTR} expected, {\b UNITY_INTERNAL_PTR} actual, const {\b UNITY_UINT32} num_elements, const char *msg, const {\b UNITY_LINE_TYPE} lineNumber, const {\b UNITY_DISPLAY_STYLE_T} style, const {\b UNITY_FLAGS_T} flags)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UNITY_NORETURN} void {\b UnityFail} (const char *message, const {\b UNITY_LINE_TYPE} line)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UNITY_NORETURN} void {\b UnityIgnore} (const char *message, const {\b UNITY_LINE_TYPE} line)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UnityMessage} (const char *message, const {\b UNITY_LINE_TYPE} line)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UnityAssertFloatsWithin} (const {\b UNITY_FLOAT} delta, const {\b UNITY_FLOAT} expected, const {\b UNITY_FLOAT} actual, const char *msg, const {\b UNITY_LINE_TYPE} lineNumber)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UnityAssertFloatsNotWithin} (const {\b UNITY_FLOAT} delta, const {\b UNITY_FLOAT} expected, const {\b UNITY_FLOAT} actual, const char *msg, const {\b UNITY_LINE_TYPE} lineNumber)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UnityAssertGreaterOrLessFloat} (const {\b UNITY_FLOAT} threshold, const {\b UNITY_FLOAT} actual, const {\b UNITY_COMPARISON_T} compare, const char *msg, const {\b UNITY_LINE_TYPE} linenumber)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UnityAssertWithinFloatArray} (const {\b UNITY_FLOAT} delta, {\b UNITY_PTR_ATTRIBUTE} const {\b UNITY_FLOAT} *expected, {\b UNITY_PTR_ATTRIBUTE} const {\b UNITY_FLOAT} *actual, const {\b UNITY_UINT32} num_elements, const char *msg, const {\b UNITY_LINE_TYPE} lineNumber, const {\b UNITY_FLAGS_T} flags)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UnityAssertFloatSpecial} (const {\b UNITY_FLOAT} actual, const char *msg, const {\b UNITY_LINE_TYPE} lineNumber, const {\b UNITY_FLOAT_TRAIT_T} style)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UNITY_INTERNAL_PTR} {\b UnityNumToPtr} (const {\b UNITY_INT} num, const {\b UNITY_UINT8} size)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UNITY_INTERNAL_PTR} {\b UnityFloatToPtr} (const float num)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b UNITY_STORAGE_T} {\b Unity}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b UnityStrOk} []\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b UnityStrPass} []\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b UnityStrFail} []\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b UnityStrIgnore} []\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b UnityStrErrFloat} []\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b UnityStrErrDouble} []\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b UnityStrErr64} []\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b UnityStrErrShorthand} []\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v RUN_TEST\:unity_internals.h}
{\xe \v unity_internals.h\:RUN_TEST}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define RUN_TEST( func)\~ {\b UnityDefaultTestRun}(func, #func, __LINE__)}}
\par
{\bkmkstart AAAAAAABAG}
{\bkmkend AAAAAAABAG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 842 of file unity_internals.h.}\par
}
{\xe \v TEST_ABORT\:unity_internals.h}
{\xe \v unity_internals.h\:TEST_ABORT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_ABORT()\~ longjmp(Unity.AbortFrame, 1)}}
\par
{\bkmkstart AAAAAAABAH}
{\bkmkend AAAAAAABAH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 799 of file unity_internals.h.}\par
}
{\xe \v TEST_IS_IGNORED\:unity_internals.h}
{\xe \v unity_internals.h\:TEST_IS_IGNORED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_IS_IGNORED\~ (Unity.CurrentTestIgnored)}}
\par
{\bkmkstart AAAAAAABAI}
{\bkmkend AAAAAAABAI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 847 of file unity_internals.h.}\par
}
{\xe \v TEST_LINE_NUM\:unity_internals.h}
{\xe \v unity_internals.h\:TEST_LINE_NUM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_LINE_NUM\~ (Unity.CurrentTestLineNumber)}}
\par
{\bkmkstart AAAAAAABAJ}
{\bkmkend AAAAAAABAJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 846 of file unity_internals.h.}\par
}
{\xe \v TEST_PROTECT\:unity_internals.h}
{\xe \v unity_internals.h\:TEST_PROTECT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_PROTECT()\~ (setjmp(Unity.AbortFrame) == 0)}}
\par
{\bkmkstart AAAAAAABAK}
{\bkmkend AAAAAAABAK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 789 of file unity_internals.h.}\par
}
{\xe \v UNITY_BEGIN\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_BEGIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_BEGIN()\~ {\b UnityBegin}(__FILE__)}}
\par
{\bkmkstart AAAAAAABAL}
{\bkmkend AAAAAAABAL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 854 of file unity_internals.h.}\par
}
{\xe \v UNITY_CLR_DETAILS\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_CLR_DETAILS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_CLR_DETAILS()\~ do \{ Unity.CurrentDetail1 = 0;     Unity.CurrentDetail2 = 0;    \} while (0)}}
\par
{\bkmkstart AAAAAAABAM}
{\bkmkend AAAAAAABAM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 564 of file unity_internals.h.}\par
}
{\xe \v UNITY_COUNTER_TYPE\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_COUNTER_TYPE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_COUNTER_TYPE\~ {\b UNITY_UINT}}}
\par
{\bkmkstart AAAAAAABAN}
{\bkmkend AAAAAAABAN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 437 of file unity_internals.h.}\par
}
{\xe \v UNITY_DETAIL1_NAME\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_DETAIL1_NAME}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_DETAIL1_NAME\~ "Function"}}
\par
{\bkmkstart AAAAAAABAO}
{\bkmkend AAAAAAABAO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 569 of file unity_internals.h.}\par
}
{\xe \v UNITY_DETAIL2_NAME\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_DETAIL2_NAME}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_DETAIL2_NAME\~ "Argument"}}
\par
{\bkmkstart AAAAAAABAP}
{\bkmkend AAAAAAABAP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 573 of file unity_internals.h.}\par
}
{\xe \v UNITY_DISPLAY_RANGE_CHAR\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_DISPLAY_RANGE_CHAR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_DISPLAY_RANGE_CHAR\~ (0x80)}}
\par
{\bkmkstart AAAAAAABAQ}
{\bkmkend AAAAAAABAQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 449 of file unity_internals.h.}\par
}
{\xe \v UNITY_DISPLAY_RANGE_HEX\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_DISPLAY_RANGE_HEX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_DISPLAY_RANGE_HEX\~ (0x40)}}
\par
{\bkmkstart AAAAAAABAR}
{\bkmkend AAAAAAABAR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 448 of file unity_internals.h.}\par
}
{\xe \v UNITY_DISPLAY_RANGE_INT\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_DISPLAY_RANGE_INT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_DISPLAY_RANGE_INT\~ (0x10)}}
\par
{\bkmkstart AAAAAAABAS}
{\bkmkend AAAAAAABAS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 446 of file unity_internals.h.}\par
}
{\xe \v UNITY_DISPLAY_RANGE_UINT\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_DISPLAY_RANGE_UINT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_DISPLAY_RANGE_UINT\~ (0x20)}}
\par
{\bkmkstart AAAAAAABAT}
{\bkmkend AAAAAAABAT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 447 of file unity_internals.h.}\par
}
{\xe \v UNITY_DISPLAY_STYLE_POINTER\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_DISPLAY_STYLE_POINTER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_DISPLAY_STYLE_POINTER\~ {\b UNITY_DISPLAY_STYLE_HEX32}}}
\par
{\bkmkstart AAAAAAABAU}
{\bkmkend AAAAAAABAU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 212 of file unity_internals.h.}\par
}
{\xe \v UNITY_DOUBLE_TYPE\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_DOUBLE_TYPE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_DOUBLE_TYPE\~ double}}
\par
{\bkmkstart AAAAAAABAV}
{\bkmkend AAAAAAABAV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 297 of file unity_internals.h.}\par
}
{\xe \v UNITY_END\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_END}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_END()\~ {\b UnityEnd}()}}
\par
{\bkmkstart AAAAAAABAW}
{\bkmkend AAAAAAABAW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 858 of file unity_internals.h.}\par
}
{\xe \v UNITY_EXCLUDE_DOUBLE\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_EXCLUDE_DOUBLE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_EXCLUDE_DOUBLE}}
\par
{\bkmkstart AAAAAAABAX}
{\bkmkend AAAAAAABAX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 290 of file unity_internals.h.}\par
}
{\xe \v UNITY_EXEC_TIME_START\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_EXEC_TIME_START}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_EXEC_TIME_START()\~ do \{ /* nothing*/ \} while (0)}}
\par
{\bkmkstart AAAAAAABAY}
{\bkmkend AAAAAAABAY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 413 of file unity_internals.h.}\par
}
{\xe \v UNITY_EXEC_TIME_STOP\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_EXEC_TIME_STOP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_EXEC_TIME_STOP()\~ do \{ /* nothing*/ \} while (0)}}
\par
{\bkmkstart AAAAAAABAZ}
{\bkmkend AAAAAAABAZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 417 of file unity_internals.h.}\par
}
{\xe \v UNITY_FLOAT_PRECISION\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_FLOAT_PRECISION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_FLOAT_PRECISION\~ (0.00001{\b f})}}
\par
{\bkmkstart AAAAAAABBA}
{\bkmkend AAAAAAABBA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 251 of file unity_internals.h.}\par
}
{\xe \v UNITY_FLOAT_TYPE\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_FLOAT_TYPE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_FLOAT_TYPE\~ float}}
\par
{\bkmkstart AAAAAAABBB}
{\bkmkend AAAAAAABBB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 254 of file unity_internals.h.}\par
}
{\xe \v UNITY_FLUSH_CALL\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_FLUSH_CALL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_FLUSH_CALL()\~ {\b UNITY_OUTPUT_FLUSH}()}}
\par
{\bkmkstart AAAAAAABBC}
{\bkmkend AAAAAAABBC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 350 of file unity_internals.h.}\par
}
{\xe \v UNITY_FUNCTION_ATTR\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_FUNCTION_ATTR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_FUNCTION_ATTR( a)\~ /* ignore */}}
\par
{\bkmkstart AAAAAAABBD}
{\bkmkend AAAAAAABBD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 47 of file unity_internals.h.}\par
}
{\xe \v UNITY_INT_WIDTH\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_INT_WIDTH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_INT_WIDTH\~ (32)}}
\par
{\bkmkstart AAAAAAABBE}
{\bkmkend AAAAAAABBE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 117 of file unity_internals.h.}\par
}
{\xe \v UNITY_INTERNAL_PTR\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_INTERNAL_PTR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_INTERNAL_PTR\~ {\b UNITY_PTR_ATTRIBUTE} const void*}}
\par
{\bkmkstart AAAAAAABBF}
{\bkmkend AAAAAAABBF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 228 of file unity_internals.h.}\par
}
{\xe \v UNITY_IS_INF\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_IS_INF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_IS_INF( n)\~ ({\b UNITY_IS_NAN}((n) - (n)) && !{\b UNITY_IS_NAN}(n))}}
\par
{\bkmkstart AAAAAAABBG}
{\bkmkend AAAAAAABBG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 273 of file unity_internals.h.}\par
}
{\xe \v UNITY_IS_NAN\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_IS_NAN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_IS_NAN( n)\~ ((n != n) ? 1 : 0)}}
\par
{\bkmkstart AAAAAAABBH}
{\bkmkend AAAAAAABBH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 263 of file unity_internals.h.}\par
}
{\xe \v UNITY_LINE_TYPE\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_LINE_TYPE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_LINE_TYPE\~ {\b UNITY_UINT}}}
\par
{\bkmkstart AAAAAAABBI}
{\bkmkend AAAAAAABBI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 433 of file unity_internals.h.}\par
}
{\xe \v UNITY_LONG_WIDTH\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_LONG_WIDTH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_LONG_WIDTH\~ (32)}}
\par
{\bkmkstart AAAAAAABBJ}
{\bkmkend AAAAAAABBJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 132 of file unity_internals.h.}\par
}
{\xe \v UNITY_MAX_NIBBLES\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_MAX_NIBBLES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_MAX_NIBBLES\~ (8)  /* Maximum number of nibbles in a UNITY_(U)INT */}}
\par
{\bkmkstart AAAAAAABBK}
{\bkmkend AAAAAAABBK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 189 of file unity_internals.h.}\par
}
{\xe \v UNITY_NEW_TEST\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_NEW_TEST}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_NEW_TEST( a)}}
\par
{\bkmkstart AAAAAAABBL}
{\bkmkend AAAAAAABBL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     Unity.CurrentTestName = (a); \\\par
    Unity.CurrentTestLineNumber = (UNITY_LINE_TYPE)(__LINE__); \\\par
    Unity.NumberOfTests++;\par
}
{
Definition at line 848 of file unity_internals.h.}\par
}
{\xe \v UNITY_NORETURN\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_NORETURN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_NORETURN\~ {\b UNITY_FUNCTION_ATTR}(__noreturn__)}}
\par
{\bkmkstart AAAAAAABBM}
{\bkmkend AAAAAAABBM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 93 of file unity_internals.h.}\par
}
{\xe \v UNITY_OUTPUT_CHAR\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_OUTPUT_CHAR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_OUTPUT_CHAR( a)\~ (void)putchar(a)}}
\par
{\bkmkstart AAAAAAABBN}
{\bkmkend AAAAAAABBN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 323 of file unity_internals.h.}\par
}
{\xe \v UNITY_OUTPUT_COMPLETE\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_OUTPUT_COMPLETE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_OUTPUT_COMPLETE()}}
\par
{\bkmkstart AAAAAAABBO}
{\bkmkend AAAAAAABBO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 362 of file unity_internals.h.}\par
}
{\xe \v UNITY_OUTPUT_FLUSH\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_OUTPUT_FLUSH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_OUTPUT_FLUSH()\~ (void)0}}
\par
{\bkmkstart AAAAAAABBP}
{\bkmkend AAAAAAABBP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 338 of file unity_internals.h.}\par
}
{\xe \v UNITY_OUTPUT_START\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_OUTPUT_START}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_OUTPUT_START()}}
\par
{\bkmkstart AAAAAAABBQ}
{\bkmkend AAAAAAABBQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 358 of file unity_internals.h.}\par
}
{\xe \v UNITY_POINTER_WIDTH\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_POINTER_WIDTH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_POINTER_WIDTH\~ {\b UNITY_LONG_WIDTH}}}
\par
{\bkmkstart AAAAAAABBR}
{\bkmkend AAAAAAABBR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 147 of file unity_internals.h.}\par
}
{\xe \v UNITY_PRINT_EOL\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_PRINT_EOL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_PRINT_EOL()\~ {\b UNITY_OUTPUT_CHAR}('\\n')}}
\par
{\bkmkstart AAAAAAABBS}
{\bkmkend AAAAAAABBS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 354 of file unity_internals.h.}\par
}
{\xe \v UNITY_PRINT_EXEC_TIME\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_PRINT_EXEC_TIME}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_PRINT_EXEC_TIME()\~ do \{ /* nothing*/ \} while (0)}}
\par
{\bkmkstart AAAAAAABBT}
{\bkmkend AAAAAAABBT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 425 of file unity_internals.h.}\par
}
{\xe \v UNITY_PTR_ATTRIBUTE\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_PTR_ATTRIBUTE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_PTR_ATTRIBUTE}}
\par
{\bkmkstart AAAAAAABBU}
{\bkmkend AAAAAAABBU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 224 of file unity_internals.h.}\par
}
{\xe \v UNITY_PTR_TO_INT\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_PTR_TO_INT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_PTR_TO_INT\~ {\b UNITY_INT32}}}
\par
{\bkmkstart AAAAAAABBV}
{\bkmkend AAAAAAABBV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 211 of file unity_internals.h.}\par
}
{\xe \v UNITY_SET_DETAIL\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_SET_DETAIL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_SET_DETAIL( d1)\~ do \{ Unity.CurrentDetail1 = (d1);  Unity.CurrentDetail2 = 0;    \} while (0)}}
\par
{\bkmkstart AAAAAAABBW}
{\bkmkend AAAAAAABBW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 565 of file unity_internals.h.}\par
}
{\xe \v UNITY_SET_DETAILS\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_SET_DETAILS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_SET_DETAILS( d1,  d2)\~ do \{ Unity.CurrentDetail1 = (d1);  Unity.CurrentDetail2 = (d2); \} while (0)}}
\par
{\bkmkstart AAAAAAABBX}
{\bkmkend AAAAAAABBX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 566 of file unity_internals.h.}\par
}
{\xe \v UNITY_SHORTHAND_AS_OLD\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_SHORTHAND_AS_OLD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_SHORTHAND_AS_OLD}}
\par
{\bkmkstart AAAAAAABBY}
{\bkmkend AAAAAAABBY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 865 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT( condition,  line,  message)\~ do \{ if (condition) \{ /* nothing*/ \} else \{ {\b UNITY_TEST_FAIL}((line), (message)); \} \} while (0)}}
\par
{\bkmkstart AAAAAAABBZ}
{\bkmkend AAAAAAABBZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 891 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_BITS\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_BITS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_BITS( mask,  expected,  actual,  line,  message)\~ {\b UnityAssertBits}(({\b UNITY_INT})(mask), ({\b UNITY_INT})(expected), ({\b UNITY_INT})(actual), (message), ({\b UNITY_LINE_TYPE})(line))}}
\par
{\bkmkstart AAAAAAABCA}
{\bkmkend AAAAAAABCA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 909 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_CHAR_ARRAY_WITHIN\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_CHAR_ARRAY_WITHIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_CHAR_ARRAY_WITHIN( delta,  expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertNumbersArrayWithin}(({\b UNITY_UINT8} )(delta), ({\b UNITY_INTERNAL_PTR})(expected), ({\b UNITY_INTERNAL_PTR})(actual), (({\b UNITY_UINT32})(num_elements)), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_CHAR}, {\b UNITY_ARRAY_TO_ARRAY})}}
\par
{\bkmkstart AAAAAAABCB}
{\bkmkend AAAAAAABCB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1000 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_CHAR_WITHIN\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_CHAR_WITHIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_CHAR_WITHIN( delta,  expected,  actual,  line,  message)\~ {\b UnityAssertNumbersWithin}(({\b UNITY_UINT8} )(delta), ({\b UNITY_INT})({\b UNITY_INT8} )             (expected), ({\b UNITY_INT})({\b UNITY_INT8} )             (actual), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_CHAR})}}
\par
{\bkmkstart AAAAAAABCC}
{\bkmkend AAAAAAABCC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 987 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_DOUBLE_ARRAY_WITHIN\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_DOUBLE_ARRAY_WITHIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_DOUBLE_ARRAY_WITHIN( delta,  expected,  actual,  num_elements,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErrDouble})}}
\par
{\bkmkstart AAAAAAABCD}
{\bkmkend AAAAAAABCD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1145 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_DOUBLE_IS_DETERMINATE\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_DOUBLE_IS_DETERMINATE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_DOUBLE_IS_DETERMINATE( actual,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErrDouble})}}
\par
{\bkmkstart AAAAAAABCE}
{\bkmkend AAAAAAABCE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1155 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_DOUBLE_IS_INF\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_DOUBLE_IS_INF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_DOUBLE_IS_INF( actual,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErrDouble})}}
\par
{\bkmkstart AAAAAAABCF}
{\bkmkend AAAAAAABCF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1152 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_DOUBLE_IS_NAN\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_DOUBLE_IS_NAN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_DOUBLE_IS_NAN( actual,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErrDouble})}}
\par
{\bkmkstart AAAAAAABCG}
{\bkmkend AAAAAAABCG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1154 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_DOUBLE_IS_NEG_INF\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_DOUBLE_IS_NEG_INF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_DOUBLE_IS_NEG_INF( actual,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErrDouble})}}
\par
{\bkmkstart AAAAAAABCH}
{\bkmkend AAAAAAABCH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1153 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_DOUBLE_IS_NOT_DETERMINATE\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_DOUBLE_IS_NOT_DETERMINATE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_DOUBLE_IS_NOT_DETERMINATE( actual,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErrDouble})}}
\par
{\bkmkstart AAAAAAABCI}
{\bkmkend AAAAAAABCI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1159 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_DOUBLE_IS_NOT_INF\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_DOUBLE_IS_NOT_INF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_DOUBLE_IS_NOT_INF( actual,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErrDouble})}}
\par
{\bkmkstart AAAAAAABCJ}
{\bkmkend AAAAAAABCJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1156 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_DOUBLE_IS_NOT_NAN\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_DOUBLE_IS_NOT_NAN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_DOUBLE_IS_NOT_NAN( actual,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErrDouble})}}
\par
{\bkmkstart AAAAAAABCK}
{\bkmkend AAAAAAABCK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1158 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_DOUBLE_IS_NOT_NEG_INF\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_DOUBLE_IS_NOT_NEG_INF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_DOUBLE_IS_NOT_NEG_INF( actual,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErrDouble})}}
\par
{\bkmkstart AAAAAAABCL}
{\bkmkend AAAAAAABCL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1157 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_DOUBLE_NOT_WITHIN\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_DOUBLE_NOT_WITHIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_DOUBLE_NOT_WITHIN( delta,  expected,  actual,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErrDouble})}}
\par
{\bkmkstart AAAAAAABCM}
{\bkmkend AAAAAAABCM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1142 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_DOUBLE_WITHIN\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_DOUBLE_WITHIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_DOUBLE_WITHIN( delta,  expected,  actual,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErrDouble})}}
\par
{\bkmkstart AAAAAAABCN}
{\bkmkend AAAAAAABCN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1141 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_EACH_EQUAL_CHAR\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_EACH_EQUAL_CHAR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_EACH_EQUAL_CHAR( expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertEqualIntArray}({\b UnityNumToPtr}(({\b UNITY_INT})({\b UNITY_INT8}  )(expected), 1),                              ({\b UNITY_INTERNAL_PTR})(actual), ({\b UNITY_UINT32})(num_elements), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_CHAR},    {\b UNITY_ARRAY_TO_VAL})}}
\par
{\bkmkstart AAAAAAABCO}
{\bkmkend AAAAAAABCO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1038 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_EACH_EQUAL_DOUBLE\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_EACH_EQUAL_DOUBLE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_EACH_EQUAL_DOUBLE( expected,  actual,  num_elements,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErrDouble})}}
\par
{\bkmkstart AAAAAAABCP}
{\bkmkend AAAAAAABCP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1147 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_EACH_EQUAL_FLOAT\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_EACH_EQUAL_FLOAT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_EACH_EQUAL_FLOAT( expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertWithinFloatArray}(({\b UNITY_FLOAT})0, {\b UnityFloatToPtr}(expected), (const {\b UNITY_FLOAT}*)(actual), ({\b UNITY_UINT32})(num_elements), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_ARRAY_TO_VAL})}}
\par
{\bkmkstart AAAAAAABCQ}
{\bkmkend AAAAAAABCQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1125 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_EACH_EQUAL_HEX16\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_EACH_EQUAL_HEX16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_EACH_EQUAL_HEX16( expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertEqualIntArray}({\b UnityNumToPtr}(({\b UNITY_INT})({\b UNITY_INT16} )(expected), 2),                              ({\b UNITY_INTERNAL_PTR})(actual), ({\b UNITY_UINT32})(num_elements), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_HEX16},   {\b UNITY_ARRAY_TO_VAL})}}
\par
{\bkmkstart AAAAAAABCR}
{\bkmkend AAAAAAABCR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1033 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_EACH_EQUAL_HEX32\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_EACH_EQUAL_HEX32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_EACH_EQUAL_HEX32( expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertEqualIntArray}({\b UnityNumToPtr}(({\b UNITY_INT})({\b UNITY_INT32} )(expected), 4),                              ({\b UNITY_INTERNAL_PTR})(actual), ({\b UNITY_UINT32})(num_elements), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_HEX32},   {\b UNITY_ARRAY_TO_VAL})}}
\par
{\bkmkstart AAAAAAABCS}
{\bkmkend AAAAAAABCS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1034 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_EACH_EQUAL_HEX8\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_EACH_EQUAL_HEX8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_EACH_EQUAL_HEX8( expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertEqualIntArray}({\b UnityNumToPtr}(({\b UNITY_INT})({\b UNITY_INT8}  )(expected), 1),                              ({\b UNITY_INTERNAL_PTR})(actual), ({\b UNITY_UINT32})(num_elements), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_HEX8},    {\b UNITY_ARRAY_TO_VAL})}}
\par
{\bkmkstart AAAAAAABCT}
{\bkmkend AAAAAAABCT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1032 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_EACH_EQUAL_INT\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_EACH_EQUAL_INT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_EACH_EQUAL_INT( expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertEqualIntArray}({\b UnityNumToPtr}(({\b UNITY_INT})              (expected), ({\b UNITY_INT_WIDTH} / 8)),          ({\b UNITY_INTERNAL_PTR})(actual), ({\b UNITY_UINT32})(num_elements), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_INT},     {\b UNITY_ARRAY_TO_VAL})}}
\par
{\bkmkstart AAAAAAABCU}
{\bkmkend AAAAAAABCU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1024 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_EACH_EQUAL_INT16\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_EACH_EQUAL_INT16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_EACH_EQUAL_INT16( expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertEqualIntArray}({\b UnityNumToPtr}(({\b UNITY_INT})({\b UNITY_INT16} )(expected), 2),                              ({\b UNITY_INTERNAL_PTR})(actual), ({\b UNITY_UINT32})(num_elements), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_INT16},   {\b UNITY_ARRAY_TO_VAL})}}
\par
{\bkmkstart AAAAAAABCV}
{\bkmkend AAAAAAABCV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1026 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_EACH_EQUAL_INT32\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_EACH_EQUAL_INT32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_EACH_EQUAL_INT32( expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertEqualIntArray}({\b UnityNumToPtr}(({\b UNITY_INT})({\b UNITY_INT32} )(expected), 4),                              ({\b UNITY_INTERNAL_PTR})(actual), ({\b UNITY_UINT32})(num_elements), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_INT32},   {\b UNITY_ARRAY_TO_VAL})}}
\par
{\bkmkstart AAAAAAABCW}
{\bkmkend AAAAAAABCW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1027 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_EACH_EQUAL_INT8\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_EACH_EQUAL_INT8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_EACH_EQUAL_INT8( expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertEqualIntArray}({\b UnityNumToPtr}(({\b UNITY_INT})({\b UNITY_INT8}  )(expected), 1),                              ({\b UNITY_INTERNAL_PTR})(actual), ({\b UNITY_UINT32})(num_elements), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_INT8},    {\b UNITY_ARRAY_TO_VAL})}}
\par
{\bkmkstart AAAAAAABCX}
{\bkmkend AAAAAAABCX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1025 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_EACH_EQUAL_MEMORY\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_EACH_EQUAL_MEMORY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_EACH_EQUAL_MEMORY( expected,  actual,  len,  num_elements,  line,  message)\~ {\b UnityAssertEqualMemory}(({\b UNITY_INTERNAL_PTR})(expected), ({\b UNITY_INTERNAL_PTR})(actual), ({\b UNITY_UINT32})(len), ({\b UNITY_UINT32})(num_elements), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_ARRAY_TO_VAL})}}
\par
{\bkmkstart AAAAAAABCY}
{\bkmkend AAAAAAABCY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1037 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_EACH_EQUAL_PTR\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_EACH_EQUAL_PTR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_EACH_EQUAL_PTR( expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertEqualIntArray}({\b UnityNumToPtr}(({\b UNITY_PTR_TO_INT})       (expected), ({\b UNITY_POINTER_WIDTH} / 8)),      ({\b UNITY_INTERNAL_PTR})(actual), ({\b UNITY_UINT32})(num_elements), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_POINTER}, {\b UNITY_ARRAY_TO_VAL})}}
\par
{\bkmkstart AAAAAAABCZ}
{\bkmkend AAAAAAABCZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1035 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_EACH_EQUAL_STRING\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_EACH_EQUAL_STRING}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_EACH_EQUAL_STRING( expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertEqualStringArray}(({\b UNITY_INTERNAL_PTR})(expected), (const char**)(actual), ({\b UNITY_UINT32})(num_elements), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_ARRAY_TO_VAL})}}
\par
{\bkmkstart AAAAAAABDA}
{\bkmkend AAAAAAABDA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1036 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_EACH_EQUAL_UINT\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_EACH_EQUAL_UINT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_EACH_EQUAL_UINT( expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertEqualIntArray}({\b UnityNumToPtr}(({\b UNITY_INT})              (expected), ({\b UNITY_INT_WIDTH} / 8)),          ({\b UNITY_INTERNAL_PTR})(actual), ({\b UNITY_UINT32})(num_elements), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_UINT},    {\b UNITY_ARRAY_TO_VAL})}}
\par
{\bkmkstart AAAAAAABDB}
{\bkmkend AAAAAAABDB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1028 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_EACH_EQUAL_UINT16\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_EACH_EQUAL_UINT16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_EACH_EQUAL_UINT16( expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertEqualIntArray}({\b UnityNumToPtr}(({\b UNITY_INT})({\b UNITY_UINT16})(expected), 2),                              ({\b UNITY_INTERNAL_PTR})(actual), ({\b UNITY_UINT32})(num_elements), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_UINT16},  {\b UNITY_ARRAY_TO_VAL})}}
\par
{\bkmkstart AAAAAAABDC}
{\bkmkend AAAAAAABDC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1030 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_EACH_EQUAL_UINT32\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_EACH_EQUAL_UINT32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_EACH_EQUAL_UINT32( expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertEqualIntArray}({\b UnityNumToPtr}(({\b UNITY_INT})({\b UNITY_UINT32})(expected), 4),                              ({\b UNITY_INTERNAL_PTR})(actual), ({\b UNITY_UINT32})(num_elements), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_UINT32},  {\b UNITY_ARRAY_TO_VAL})}}
\par
{\bkmkstart AAAAAAABDD}
{\bkmkend AAAAAAABDD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1031 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_EACH_EQUAL_UINT8\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_EACH_EQUAL_UINT8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_EACH_EQUAL_UINT8( expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertEqualIntArray}({\b UnityNumToPtr}(({\b UNITY_INT})({\b UNITY_UINT8} )(expected), 1),                              ({\b UNITY_INTERNAL_PTR})(actual), ({\b UNITY_UINT32})(num_elements), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_UINT8},   {\b UNITY_ARRAY_TO_VAL})}}
\par
{\bkmkstart AAAAAAABDE}
{\bkmkend AAAAAAABDE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1029 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_EMPTY\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_EMPTY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_EMPTY( pointer,  line,  message)\~ {\b UNITY_TEST_ASSERT}(((pointer[0]) == 0),  (line), (message))}}
\par
{\bkmkstart AAAAAAABDF}
{\bkmkend AAAAAAABDF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 894 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_EQUAL_CHAR\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_EQUAL_CHAR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_EQUAL_CHAR( expected,  actual,  line,  message)\~ {\b UnityAssertEqualNumber}(({\b UNITY_INT})({\b UNITY_INT8} )(expected), ({\b UNITY_INT})({\b UNITY_INT8} )(actual), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_CHAR})}}
\par
{\bkmkstart AAAAAAABDG}
{\bkmkend AAAAAAABDG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 908 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_EQUAL_CHAR_ARRAY\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_EQUAL_CHAR_ARRAY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_EQUAL_CHAR_ARRAY( expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertEqualIntArray}(({\b UNITY_INTERNAL_PTR})(expected), ({\b UNITY_INTERNAL_PTR})(actual), ({\b UNITY_UINT32})(num_elements), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_CHAR},    {\b UNITY_ARRAY_TO_ARRAY})}}
\par
{\bkmkstart AAAAAAABDH}
{\bkmkend AAAAAAABDH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1022 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_EQUAL_DOUBLE\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_EQUAL_DOUBLE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_EQUAL_DOUBLE( expected,  actual,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErrDouble})}}
\par
{\bkmkstart AAAAAAABDI}
{\bkmkend AAAAAAABDI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1143 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_EQUAL_DOUBLE_ARRAY\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_EQUAL_DOUBLE_ARRAY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_EQUAL_DOUBLE_ARRAY( expected,  actual,  num_elements,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErrDouble})}}
\par
{\bkmkstart AAAAAAABDJ}
{\bkmkend AAAAAAABDJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1146 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_EQUAL_FLOAT\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_EQUAL_FLOAT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_EQUAL_FLOAT( expected,  actual,  line,  message)\~ {\b UNITY_TEST_ASSERT_FLOAT_WITHIN}(({\b UNITY_FLOAT})(expected) * ({\b UNITY_FLOAT}){\b UNITY_FLOAT_PRECISION}, ({\b UNITY_FLOAT})(expected), ({\b UNITY_FLOAT})(actual), ({\b UNITY_LINE_TYPE})(line), (message))}}
\par
{\bkmkstart AAAAAAABDK}
{\bkmkend AAAAAAABDK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1121 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_EQUAL_FLOAT_ARRAY\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_EQUAL_FLOAT_ARRAY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_EQUAL_FLOAT_ARRAY( expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertWithinFloatArray}(({\b UNITY_FLOAT})0, (const {\b UNITY_FLOAT}*)(expected), (const {\b UNITY_FLOAT}*)(actual), ({\b UNITY_UINT32})(num_elements), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_ARRAY_TO_ARRAY})}}
\par
{\bkmkstart AAAAAAABDL}
{\bkmkend AAAAAAABDL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1124 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_EQUAL_HEX16\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_EQUAL_HEX16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_EQUAL_HEX16( expected,  actual,  line,  message)\~ {\b UnityAssertEqualNumber}(({\b UNITY_INT})({\b UNITY_INT16})(expected), ({\b UNITY_INT})({\b UNITY_INT16})(actual), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_HEX16})}}
\par
{\bkmkstart AAAAAAABDM}
{\bkmkend AAAAAAABDM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 906 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_EQUAL_HEX16_ARRAY\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_EQUAL_HEX16_ARRAY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_EQUAL_HEX16_ARRAY( expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertEqualIntArray}(({\b UNITY_INTERNAL_PTR})(expected), ({\b UNITY_INTERNAL_PTR})(actual), ({\b UNITY_UINT32})(num_elements), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_HEX16},   {\b UNITY_ARRAY_TO_ARRAY})}}
\par
{\bkmkstart AAAAAAABDN}
{\bkmkend AAAAAAABDN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1017 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_EQUAL_HEX32\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_EQUAL_HEX32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_EQUAL_HEX32( expected,  actual,  line,  message)\~ {\b UnityAssertEqualNumber}(({\b UNITY_INT})({\b UNITY_INT32})(expected), ({\b UNITY_INT})({\b UNITY_INT32})(actual), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_HEX32})}}
\par
{\bkmkstart AAAAAAABDO}
{\bkmkend AAAAAAABDO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 907 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_EQUAL_HEX32_ARRAY\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_EQUAL_HEX32_ARRAY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_EQUAL_HEX32_ARRAY( expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertEqualIntArray}(({\b UNITY_INTERNAL_PTR})(expected), ({\b UNITY_INTERNAL_PTR})(actual), ({\b UNITY_UINT32})(num_elements), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_HEX32},   {\b UNITY_ARRAY_TO_ARRAY})}}
\par
{\bkmkstart AAAAAAABDP}
{\bkmkend AAAAAAABDP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1018 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_EQUAL_HEX64\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_EQUAL_HEX64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_EQUAL_HEX64( expected,  actual,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErr64})}}
\par
{\bkmkstart AAAAAAABDQ}
{\bkmkend AAAAAAABDQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1074 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_EQUAL_HEX64_ARRAY\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_EQUAL_HEX64_ARRAY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_EQUAL_HEX64_ARRAY( expected,  actual,  num_elements,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErr64})}}
\par
{\bkmkstart AAAAAAABDR}
{\bkmkend AAAAAAABDR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1077 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_EQUAL_HEX8\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_EQUAL_HEX8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_EQUAL_HEX8( expected,  actual,  line,  message)\~ {\b UnityAssertEqualNumber}(({\b UNITY_INT})({\b UNITY_INT8} )(expected), ({\b UNITY_INT})({\b UNITY_INT8} )(actual), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_HEX8})}}
\par
{\bkmkstart AAAAAAABDS}
{\bkmkend AAAAAAABDS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 905 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY( expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertEqualIntArray}(({\b UNITY_INTERNAL_PTR})(expected), ({\b UNITY_INTERNAL_PTR})(actual), ({\b UNITY_UINT32})(num_elements), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_HEX8},    {\b UNITY_ARRAY_TO_ARRAY})}}
\par
{\bkmkstart AAAAAAABDT}
{\bkmkend AAAAAAABDT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1016 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_EQUAL_INT\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_EQUAL_INT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_EQUAL_INT( expected,  actual,  line,  message)\~ {\b UnityAssertEqualNumber}(({\b UNITY_INT})(expected), ({\b UNITY_INT})(actual), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_INT})}}
\par
{\bkmkstart AAAAAAABDU}
{\bkmkend AAAAAAABDU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 897 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_EQUAL_INT16\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_EQUAL_INT16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_EQUAL_INT16( expected,  actual,  line,  message)\~ {\b UnityAssertEqualNumber}(({\b UNITY_INT})({\b UNITY_INT16})(expected), ({\b UNITY_INT})({\b UNITY_INT16})(actual), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_INT16})}}
\par
{\bkmkstart AAAAAAABDV}
{\bkmkend AAAAAAABDV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 899 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_EQUAL_INT16_ARRAY\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_EQUAL_INT16_ARRAY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_EQUAL_INT16_ARRAY( expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertEqualIntArray}(({\b UNITY_INTERNAL_PTR})(expected), ({\b UNITY_INTERNAL_PTR})(actual), ({\b UNITY_UINT32})(num_elements), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_INT16},   {\b UNITY_ARRAY_TO_ARRAY})}}
\par
{\bkmkstart AAAAAAABDW}
{\bkmkend AAAAAAABDW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1010 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_EQUAL_INT32\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_EQUAL_INT32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_EQUAL_INT32( expected,  actual,  line,  message)\~ {\b UnityAssertEqualNumber}(({\b UNITY_INT})({\b UNITY_INT32})(expected), ({\b UNITY_INT})({\b UNITY_INT32})(actual), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_INT32})}}
\par
{\bkmkstart AAAAAAABDX}
{\bkmkend AAAAAAABDX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 900 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_EQUAL_INT32_ARRAY\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_EQUAL_INT32_ARRAY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_EQUAL_INT32_ARRAY( expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertEqualIntArray}(({\b UNITY_INTERNAL_PTR})(expected), ({\b UNITY_INTERNAL_PTR})(actual), ({\b UNITY_UINT32})(num_elements), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_INT32},   {\b UNITY_ARRAY_TO_ARRAY})}}
\par
{\bkmkstart AAAAAAABDY}
{\bkmkend AAAAAAABDY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1011 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_EQUAL_INT64\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_EQUAL_INT64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_EQUAL_INT64( expected,  actual,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErr64})}}
\par
{\bkmkstart AAAAAAABDZ}
{\bkmkend AAAAAAABDZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1072 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_EQUAL_INT64_ARRAY\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_EQUAL_INT64_ARRAY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_EQUAL_INT64_ARRAY( expected,  actual,  num_elements,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErr64})}}
\par
{\bkmkstart AAAAAAABEA}
{\bkmkend AAAAAAABEA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1075 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_EQUAL_INT8\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_EQUAL_INT8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_EQUAL_INT8( expected,  actual,  line,  message)\~ {\b UnityAssertEqualNumber}(({\b UNITY_INT})({\b UNITY_INT8} )(expected), ({\b UNITY_INT})({\b UNITY_INT8} )(actual), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_INT8})}}
\par
{\bkmkstart AAAAAAABEB}
{\bkmkend AAAAAAABEB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 898 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_EQUAL_INT8_ARRAY\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_EQUAL_INT8_ARRAY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_EQUAL_INT8_ARRAY( expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertEqualIntArray}(({\b UNITY_INTERNAL_PTR})(expected), ({\b UNITY_INTERNAL_PTR})(actual), ({\b UNITY_UINT32})(num_elements), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_INT8},    {\b UNITY_ARRAY_TO_ARRAY})}}
\par
{\bkmkstart AAAAAAABEC}
{\bkmkend AAAAAAABEC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1009 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_EQUAL_INT_ARRAY\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_EQUAL_INT_ARRAY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_EQUAL_INT_ARRAY( expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertEqualIntArray}(({\b UNITY_INTERNAL_PTR})(expected), ({\b UNITY_INTERNAL_PTR})(actual), ({\b UNITY_UINT32})(num_elements), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_INT},     {\b UNITY_ARRAY_TO_ARRAY})}}
\par
{\bkmkstart AAAAAAABED}
{\bkmkend AAAAAAABED}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1008 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_EQUAL_MEMORY\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_EQUAL_MEMORY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_EQUAL_MEMORY( expected,  actual,  len,  line,  message)\~ {\b UnityAssertEqualMemory}(({\b UNITY_INTERNAL_PTR})(expected), ({\b UNITY_INTERNAL_PTR})(actual), ({\b UNITY_UINT32})(len), 1, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_ARRAY_TO_ARRAY})}}
\par
{\bkmkstart AAAAAAABEE}
{\bkmkend AAAAAAABEE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1006 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY( expected,  actual,  len,  num_elements,  line,  message)\~ {\b UnityAssertEqualMemory}(({\b UNITY_INTERNAL_PTR})(expected), ({\b UNITY_INTERNAL_PTR})(actual), ({\b UNITY_UINT32})(len), ({\b UNITY_UINT32})(num_elements), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_ARRAY_TO_ARRAY})}}
\par
{\bkmkstart AAAAAAABEF}
{\bkmkend AAAAAAABEF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1021 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_EQUAL_PTR\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_EQUAL_PTR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_EQUAL_PTR( expected,  actual,  line,  message)\~ {\b UnityAssertEqualNumber}(({\b UNITY_PTR_TO_INT})(expected), ({\b UNITY_PTR_TO_INT})(actual), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_POINTER})}}
\par
{\bkmkstart AAAAAAABEG}
{\bkmkend AAAAAAABEG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1003 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_EQUAL_PTR_ARRAY\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_EQUAL_PTR_ARRAY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_EQUAL_PTR_ARRAY( expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertEqualIntArray}(({\b UNITY_INTERNAL_PTR})(expected), ({\b UNITY_INTERNAL_PTR})(actual), ({\b UNITY_UINT32})(num_elements), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_POINTER}, {\b UNITY_ARRAY_TO_ARRAY})}}
\par
{\bkmkstart AAAAAAABEH}
{\bkmkend AAAAAAABEH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1019 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_EQUAL_STRING\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_EQUAL_STRING}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_EQUAL_STRING( expected,  actual,  line,  message)\~ {\b UnityAssertEqualString}((const char*)(expected), (const char*)(actual), (message), ({\b UNITY_LINE_TYPE})(line))}}
\par
{\bkmkstart AAAAAAABEI}
{\bkmkend AAAAAAABEI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1004 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_EQUAL_STRING_ARRAY\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_EQUAL_STRING_ARRAY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_EQUAL_STRING_ARRAY( expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertEqualStringArray}(({\b UNITY_INTERNAL_PTR})(expected), (const char**)(actual), ({\b UNITY_UINT32})(num_elements), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_ARRAY_TO_ARRAY})}}
\par
{\bkmkstart AAAAAAABEJ}
{\bkmkend AAAAAAABEJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1020 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_EQUAL_STRING_LEN\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_EQUAL_STRING_LEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_EQUAL_STRING_LEN( expected,  actual,  len,  line,  message)\~ {\b UnityAssertEqualStringLen}((const char*)(expected), (const char*)(actual), ({\b UNITY_UINT32})(len), (message), ({\b UNITY_LINE_TYPE})(line))}}
\par
{\bkmkstart AAAAAAABEK}
{\bkmkend AAAAAAABEK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1005 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_EQUAL_UINT\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_EQUAL_UINT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_EQUAL_UINT( expected,  actual,  line,  message)\~ {\b UnityAssertEqualNumber}(({\b UNITY_INT})(expected), ({\b UNITY_INT})(actual), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_UINT})}}
\par
{\bkmkstart AAAAAAABEL}
{\bkmkend AAAAAAABEL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 901 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_EQUAL_UINT16\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_EQUAL_UINT16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_EQUAL_UINT16( expected,  actual,  line,  message)\~ {\b UnityAssertEqualNumber}(({\b UNITY_INT})({\b UNITY_UINT16})(expected), ({\b UNITY_INT})({\b UNITY_UINT16})(actual), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_UINT16})}}
\par
{\bkmkstart AAAAAAABEM}
{\bkmkend AAAAAAABEM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 903 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_EQUAL_UINT16_ARRAY\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_EQUAL_UINT16_ARRAY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_EQUAL_UINT16_ARRAY( expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertEqualIntArray}(({\b UNITY_INTERNAL_PTR})(expected), ({\b UNITY_INTERNAL_PTR})(actual), ({\b UNITY_UINT32})(num_elements), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_UINT16},  {\b UNITY_ARRAY_TO_ARRAY})}}
\par
{\bkmkstart AAAAAAABEN}
{\bkmkend AAAAAAABEN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1014 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_EQUAL_UINT32\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_EQUAL_UINT32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_EQUAL_UINT32( expected,  actual,  line,  message)\~ {\b UnityAssertEqualNumber}(({\b UNITY_INT})({\b UNITY_UINT32})(expected), ({\b UNITY_INT})({\b UNITY_UINT32})(actual), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_UINT32})}}
\par
{\bkmkstart AAAAAAABEO}
{\bkmkend AAAAAAABEO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 904 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_EQUAL_UINT32_ARRAY\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_EQUAL_UINT32_ARRAY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_EQUAL_UINT32_ARRAY( expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertEqualIntArray}(({\b UNITY_INTERNAL_PTR})(expected), ({\b UNITY_INTERNAL_PTR})(actual), ({\b UNITY_UINT32})(num_elements), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_UINT32},  {\b UNITY_ARRAY_TO_ARRAY})}}
\par
{\bkmkstart AAAAAAABEP}
{\bkmkend AAAAAAABEP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1015 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_EQUAL_UINT64\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_EQUAL_UINT64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_EQUAL_UINT64( expected,  actual,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErr64})}}
\par
{\bkmkstart AAAAAAABEQ}
{\bkmkend AAAAAAABEQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1073 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_EQUAL_UINT64_ARRAY\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_EQUAL_UINT64_ARRAY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_EQUAL_UINT64_ARRAY( expected,  actual,  num_elements,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErr64})}}
\par
{\bkmkstart AAAAAAABER}
{\bkmkend AAAAAAABER}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1076 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_EQUAL_UINT8\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_EQUAL_UINT8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_EQUAL_UINT8( expected,  actual,  line,  message)\~ {\b UnityAssertEqualNumber}(({\b UNITY_INT})({\b UNITY_UINT8} )(expected), ({\b UNITY_INT})({\b UNITY_UINT8} )(actual), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_UINT8})}}
\par
{\bkmkstart AAAAAAABES}
{\bkmkend AAAAAAABES}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 902 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_EQUAL_UINT8_ARRAY\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_EQUAL_UINT8_ARRAY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_EQUAL_UINT8_ARRAY( expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertEqualIntArray}(({\b UNITY_INTERNAL_PTR})(expected), ({\b UNITY_INTERNAL_PTR})(actual), ({\b UNITY_UINT32})(num_elements), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_UINT8},   {\b UNITY_ARRAY_TO_ARRAY})}}
\par
{\bkmkstart AAAAAAABET}
{\bkmkend AAAAAAABET}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1013 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_EQUAL_UINT_ARRAY\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_EQUAL_UINT_ARRAY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_EQUAL_UINT_ARRAY( expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertEqualIntArray}(({\b UNITY_INTERNAL_PTR})(expected), ({\b UNITY_INTERNAL_PTR})(actual), ({\b UNITY_UINT32})(num_elements), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_UINT},    {\b UNITY_ARRAY_TO_ARRAY})}}
\par
{\bkmkstart AAAAAAABEU}
{\bkmkend AAAAAAABEU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1012 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_FLOAT_ARRAY_WITHIN\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_FLOAT_ARRAY_WITHIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_FLOAT_ARRAY_WITHIN( delta,  expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertWithinFloatArray}(({\b UNITY_FLOAT})(delta), (const {\b UNITY_FLOAT}*)(expected), (const {\b UNITY_FLOAT}*)(actual), ({\b UNITY_UINT32})(num_elements), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_ARRAY_TO_ARRAY})}}
\par
{\bkmkstart AAAAAAABEV}
{\bkmkend AAAAAAABEV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1123 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_FLOAT_IS_DETERMINATE\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_FLOAT_IS_DETERMINATE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_FLOAT_IS_DETERMINATE( actual,  line,  message)\~ {\b UnityAssertFloatSpecial}(({\b UNITY_FLOAT})(actual), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_FLOAT_IS_DET})}}
\par
{\bkmkstart AAAAAAABEW}
{\bkmkend AAAAAAABEW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1133 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_FLOAT_IS_INF\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_FLOAT_IS_INF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_FLOAT_IS_INF( actual,  line,  message)\~ {\b UnityAssertFloatSpecial}(({\b UNITY_FLOAT})(actual), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_FLOAT_IS_INF})}}
\par
{\bkmkstart AAAAAAABEX}
{\bkmkend AAAAAAABEX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1130 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_FLOAT_IS_NAN\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_FLOAT_IS_NAN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_FLOAT_IS_NAN( actual,  line,  message)\~ {\b UnityAssertFloatSpecial}(({\b UNITY_FLOAT})(actual), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_FLOAT_IS_NAN})}}
\par
{\bkmkstart AAAAAAABEY}
{\bkmkend AAAAAAABEY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1132 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_FLOAT_IS_NEG_INF\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_FLOAT_IS_NEG_INF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_FLOAT_IS_NEG_INF( actual,  line,  message)\~ {\b UnityAssertFloatSpecial}(({\b UNITY_FLOAT})(actual), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_FLOAT_IS_NEG_INF})}}
\par
{\bkmkstart AAAAAAABEZ}
{\bkmkend AAAAAAABEZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1131 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_FLOAT_IS_NOT_DETERMINATE\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_FLOAT_IS_NOT_DETERMINATE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_FLOAT_IS_NOT_DETERMINATE( actual,  line,  message)\~ {\b UnityAssertFloatSpecial}(({\b UNITY_FLOAT})(actual), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_FLOAT_IS_NOT_DET})}}
\par
{\bkmkstart AAAAAAABFA}
{\bkmkend AAAAAAABFA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1137 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_FLOAT_IS_NOT_INF\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_FLOAT_IS_NOT_INF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_FLOAT_IS_NOT_INF( actual,  line,  message)\~ {\b UnityAssertFloatSpecial}(({\b UNITY_FLOAT})(actual), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_FLOAT_IS_NOT_INF})}}
\par
{\bkmkstart AAAAAAABFB}
{\bkmkend AAAAAAABFB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1134 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_FLOAT_IS_NOT_NAN\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_FLOAT_IS_NOT_NAN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_FLOAT_IS_NOT_NAN( actual,  line,  message)\~ {\b UnityAssertFloatSpecial}(({\b UNITY_FLOAT})(actual), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_FLOAT_IS_NOT_NAN})}}
\par
{\bkmkstart AAAAAAABFC}
{\bkmkend AAAAAAABFC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1136 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_FLOAT_IS_NOT_NEG_INF\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_FLOAT_IS_NOT_NEG_INF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_FLOAT_IS_NOT_NEG_INF( actual,  line,  message)\~ {\b UnityAssertFloatSpecial}(({\b UNITY_FLOAT})(actual), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_FLOAT_IS_NOT_NEG_INF})}}
\par
{\bkmkstart AAAAAAABFD}
{\bkmkend AAAAAAABFD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1135 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_FLOAT_NOT_WITHIN\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_FLOAT_NOT_WITHIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_FLOAT_NOT_WITHIN( delta,  expected,  actual,  line,  message)\~ {\b UnityAssertFloatsNotWithin}(({\b UNITY_FLOAT})(delta), ({\b UNITY_FLOAT})(expected), ({\b UNITY_FLOAT})(actual), (message), ({\b UNITY_LINE_TYPE})(line))}}
\par
{\bkmkstart AAAAAAABFE}
{\bkmkend AAAAAAABFE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1120 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_FLOAT_WITHIN\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_FLOAT_WITHIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_FLOAT_WITHIN( delta,  expected,  actual,  line,  message)\~ {\b UnityAssertFloatsWithin}(({\b UNITY_FLOAT})(delta), ({\b UNITY_FLOAT})(expected), ({\b UNITY_FLOAT})(actual), (message), ({\b UNITY_LINE_TYPE})(line))}}
\par
{\bkmkstart AAAAAAABFF}
{\bkmkend AAAAAAABFF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1119 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_GREATER_OR_EQUAL_CHAR\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_GREATER_OR_EQUAL_CHAR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_GREATER_OR_EQUAL_CHAR( threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_INT8} ) (threshold), ({\b UNITY_INT})({\b UNITY_INT8} ) (actual), {\b UNITY_GREATER_OR_EQUAL}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_CHAR})}}
\par
{\bkmkstart AAAAAAABFG}
{\bkmkend AAAAAAABFG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 961 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_GREATER_OR_EQUAL_DOUBLE\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_GREATER_OR_EQUAL_DOUBLE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_GREATER_OR_EQUAL_DOUBLE( threshold,  actual,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErrDouble})}}
\par
{\bkmkstart AAAAAAABFH}
{\bkmkend AAAAAAABFH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1149 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_GREATER_OR_EQUAL_FLOAT\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_GREATER_OR_EQUAL_FLOAT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_GREATER_OR_EQUAL_FLOAT( threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessFloat}(({\b UNITY_FLOAT})(threshold), ({\b UNITY_FLOAT})(actual), {\b UNITY_GREATER_OR_EQUAL}, (message), ({\b UNITY_LINE_TYPE})(line))}}
\par
{\bkmkstart AAAAAAABFI}
{\bkmkend AAAAAAABFI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1127 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_GREATER_OR_EQUAL_HEX16\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_GREATER_OR_EQUAL_HEX16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_GREATER_OR_EQUAL_HEX16( threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_UINT16})(threshold), ({\b UNITY_INT})({\b UNITY_UINT16})(actual), {\b UNITY_GREATER_OR_EQUAL}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_HEX16})}}
\par
{\bkmkstart AAAAAAABFJ}
{\bkmkend AAAAAAABFJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 959 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_GREATER_OR_EQUAL_HEX32\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_GREATER_OR_EQUAL_HEX32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_GREATER_OR_EQUAL_HEX32( threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_UINT32})(threshold), ({\b UNITY_INT})({\b UNITY_UINT32})(actual), {\b UNITY_GREATER_OR_EQUAL}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_HEX32})}}
\par
{\bkmkstart AAAAAAABFK}
{\bkmkend AAAAAAABFK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 960 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_GREATER_OR_EQUAL_HEX64\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_GREATER_OR_EQUAL_HEX64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_GREATER_OR_EQUAL_HEX64( threshold,  actual,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErr64})}}
\par
{\bkmkstart AAAAAAABFL}
{\bkmkend AAAAAAABFL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1086 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_GREATER_OR_EQUAL_HEX8\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_GREATER_OR_EQUAL_HEX8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_GREATER_OR_EQUAL_HEX8( threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_UINT8} )(threshold), ({\b UNITY_INT})({\b UNITY_UINT8} )(actual), {\b UNITY_GREATER_OR_EQUAL}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_HEX8})}}
\par
{\bkmkstart AAAAAAABFM}
{\bkmkend AAAAAAABFM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 958 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_GREATER_OR_EQUAL_INT\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_GREATER_OR_EQUAL_INT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_GREATER_OR_EQUAL_INT( threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})              (threshold), ({\b UNITY_INT})              (actual), {\b UNITY_GREATER_OR_EQUAL}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_INT})}}
\par
{\bkmkstart AAAAAAABFN}
{\bkmkend AAAAAAABFN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 950 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_GREATER_OR_EQUAL_INT16\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_GREATER_OR_EQUAL_INT16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_GREATER_OR_EQUAL_INT16( threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_INT16}) (threshold), ({\b UNITY_INT})({\b UNITY_INT16}) (actual), {\b UNITY_GREATER_OR_EQUAL}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_INT16})}}
\par
{\bkmkstart AAAAAAABFO}
{\bkmkend AAAAAAABFO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 952 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_GREATER_OR_EQUAL_INT32\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_GREATER_OR_EQUAL_INT32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_GREATER_OR_EQUAL_INT32( threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_INT32}) (threshold), ({\b UNITY_INT})({\b UNITY_INT32}) (actual), {\b UNITY_GREATER_OR_EQUAL}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_INT32})}}
\par
{\bkmkstart AAAAAAABFP}
{\bkmkend AAAAAAABFP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 953 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_GREATER_OR_EQUAL_INT64\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_GREATER_OR_EQUAL_INT64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_GREATER_OR_EQUAL_INT64( threshold,  actual,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErr64})}}
\par
{\bkmkstart AAAAAAABFQ}
{\bkmkend AAAAAAABFQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1084 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_GREATER_OR_EQUAL_INT8\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_GREATER_OR_EQUAL_INT8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_GREATER_OR_EQUAL_INT8( threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_INT8} ) (threshold), ({\b UNITY_INT})({\b UNITY_INT8} ) (actual), {\b UNITY_GREATER_OR_EQUAL}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_INT8})}}
\par
{\bkmkstart AAAAAAABFR}
{\bkmkend AAAAAAABFR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 951 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_GREATER_OR_EQUAL_UINT\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_GREATER_OR_EQUAL_UINT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_GREATER_OR_EQUAL_UINT( threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})              (threshold), ({\b UNITY_INT})              (actual), {\b UNITY_GREATER_OR_EQUAL}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_UINT})}}
\par
{\bkmkstart AAAAAAABFS}
{\bkmkend AAAAAAABFS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 954 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_GREATER_OR_EQUAL_UINT16\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_GREATER_OR_EQUAL_UINT16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_GREATER_OR_EQUAL_UINT16( threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_UINT16})(threshold), ({\b UNITY_INT})({\b UNITY_UINT16})(actual), {\b UNITY_GREATER_OR_EQUAL}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_UINT16})}}
\par
{\bkmkstart AAAAAAABFT}
{\bkmkend AAAAAAABFT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 956 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_GREATER_OR_EQUAL_UINT32\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_GREATER_OR_EQUAL_UINT32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_GREATER_OR_EQUAL_UINT32( threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_UINT32})(threshold), ({\b UNITY_INT})({\b UNITY_UINT32})(actual), {\b UNITY_GREATER_OR_EQUAL}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_UINT32})}}
\par
{\bkmkstart AAAAAAABFU}
{\bkmkend AAAAAAABFU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 957 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_GREATER_OR_EQUAL_UINT64\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_GREATER_OR_EQUAL_UINT64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_GREATER_OR_EQUAL_UINT64( threshold,  actual,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErr64})}}
\par
{\bkmkstart AAAAAAABFV}
{\bkmkend AAAAAAABFV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1085 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_GREATER_OR_EQUAL_UINT8\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_GREATER_OR_EQUAL_UINT8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_GREATER_OR_EQUAL_UINT8( threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_UINT8} )(threshold), ({\b UNITY_INT})({\b UNITY_UINT8} )(actual), {\b UNITY_GREATER_OR_EQUAL}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_UINT8})}}
\par
{\bkmkstart AAAAAAABFW}
{\bkmkend AAAAAAABFW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 955 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_GREATER_THAN_CHAR\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_GREATER_THAN_CHAR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_GREATER_THAN_CHAR( threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_INT8} )(threshold), ({\b UNITY_INT})({\b UNITY_INT8} )(actual), {\b UNITY_GREATER_THAN}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_CHAR})}}
\par
{\bkmkstart AAAAAAABFX}
{\bkmkend AAAAAAABFX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 935 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_GREATER_THAN_DOUBLE\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_GREATER_THAN_DOUBLE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_GREATER_THAN_DOUBLE( threshold,  actual,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErrDouble})}}
\par
{\bkmkstart AAAAAAABFY}
{\bkmkend AAAAAAABFY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1148 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_GREATER_THAN_FLOAT\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_GREATER_THAN_FLOAT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_GREATER_THAN_FLOAT( threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessFloat}(({\b UNITY_FLOAT})(threshold), ({\b UNITY_FLOAT})(actual), {\b UNITY_GREATER_THAN}, (message), ({\b UNITY_LINE_TYPE})(line))}}
\par
{\bkmkstart AAAAAAABFZ}
{\bkmkend AAAAAAABFZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1126 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_GREATER_THAN_HEX16\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_GREATER_THAN_HEX16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_GREATER_THAN_HEX16( threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_UINT16})(threshold), ({\b UNITY_INT})({\b UNITY_UINT16})(actual), {\b UNITY_GREATER_THAN}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_HEX16})}}
\par
{\bkmkstart AAAAAAABGA}
{\bkmkend AAAAAAABGA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 933 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_GREATER_THAN_HEX32\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_GREATER_THAN_HEX32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_GREATER_THAN_HEX32( threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_UINT32})(threshold), ({\b UNITY_INT})({\b UNITY_UINT32})(actual), {\b UNITY_GREATER_THAN}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_HEX32})}}
\par
{\bkmkstart AAAAAAABGB}
{\bkmkend AAAAAAABGB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 934 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_GREATER_THAN_HEX64\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_GREATER_THAN_HEX64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_GREATER_THAN_HEX64( threshold,  actual,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErr64})}}
\par
{\bkmkstart AAAAAAABGC}
{\bkmkend AAAAAAABGC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1083 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_GREATER_THAN_HEX8\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_GREATER_THAN_HEX8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_GREATER_THAN_HEX8( threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_UINT8} )(threshold), ({\b UNITY_INT})({\b UNITY_UINT8} )(actual), {\b UNITY_GREATER_THAN}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_HEX8})}}
\par
{\bkmkstart AAAAAAABGD}
{\bkmkend AAAAAAABGD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 932 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_GREATER_THAN_INT\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_GREATER_THAN_INT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_GREATER_THAN_INT( threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})(threshold),              ({\b UNITY_INT})(actual),              {\b UNITY_GREATER_THAN}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_INT})}}
\par
{\bkmkstart AAAAAAABGE}
{\bkmkend AAAAAAABGE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 924 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_GREATER_THAN_INT16\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_GREATER_THAN_INT16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_GREATER_THAN_INT16( threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_INT16})(threshold), ({\b UNITY_INT})({\b UNITY_INT16})(actual), {\b UNITY_GREATER_THAN}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_INT16})}}
\par
{\bkmkstart AAAAAAABGF}
{\bkmkend AAAAAAABGF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 926 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_GREATER_THAN_INT32\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_GREATER_THAN_INT32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_GREATER_THAN_INT32( threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_INT32})(threshold), ({\b UNITY_INT})({\b UNITY_INT32})(actual), {\b UNITY_GREATER_THAN}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_INT32})}}
\par
{\bkmkstart AAAAAAABGG}
{\bkmkend AAAAAAABGG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 927 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_GREATER_THAN_INT64\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_GREATER_THAN_INT64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_GREATER_THAN_INT64( threshold,  actual,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErr64})}}
\par
{\bkmkstart AAAAAAABGH}
{\bkmkend AAAAAAABGH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1081 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_GREATER_THAN_INT8\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_GREATER_THAN_INT8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_GREATER_THAN_INT8( threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_INT8} )(threshold), ({\b UNITY_INT})({\b UNITY_INT8} )(actual), {\b UNITY_GREATER_THAN}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_INT8})}}
\par
{\bkmkstart AAAAAAABGI}
{\bkmkend AAAAAAABGI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 925 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_GREATER_THAN_UINT\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_GREATER_THAN_UINT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_GREATER_THAN_UINT( threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})(threshold),              ({\b UNITY_INT})(actual),              {\b UNITY_GREATER_THAN}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_UINT})}}
\par
{\bkmkstart AAAAAAABGJ}
{\bkmkend AAAAAAABGJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 928 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_GREATER_THAN_UINT16\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_GREATER_THAN_UINT16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_GREATER_THAN_UINT16( threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_UINT16})(threshold), ({\b UNITY_INT})({\b UNITY_UINT16})(actual), {\b UNITY_GREATER_THAN}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_UINT16})}}
\par
{\bkmkstart AAAAAAABGK}
{\bkmkend AAAAAAABGK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 930 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_GREATER_THAN_UINT32\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_GREATER_THAN_UINT32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_GREATER_THAN_UINT32( threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_UINT32})(threshold), ({\b UNITY_INT})({\b UNITY_UINT32})(actual), {\b UNITY_GREATER_THAN}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_UINT32})}}
\par
{\bkmkstart AAAAAAABGL}
{\bkmkend AAAAAAABGL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 931 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_GREATER_THAN_UINT64\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_GREATER_THAN_UINT64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_GREATER_THAN_UINT64( threshold,  actual,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErr64})}}
\par
{\bkmkstart AAAAAAABGM}
{\bkmkend AAAAAAABGM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1082 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_GREATER_THAN_UINT8\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_GREATER_THAN_UINT8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_GREATER_THAN_UINT8( threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_UINT8} )(threshold), ({\b UNITY_INT})({\b UNITY_UINT8} )(actual), {\b UNITY_GREATER_THAN}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_UINT8})}}
\par
{\bkmkstart AAAAAAABGN}
{\bkmkend AAAAAAABGN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 929 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_HEX16_ARRAY_WITHIN\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_HEX16_ARRAY_WITHIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_HEX16_ARRAY_WITHIN( delta,  expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertNumbersArrayWithin}(({\b UNITY_UINT16})(delta), ({\b UNITY_INTERNAL_PTR})(expected), ({\b UNITY_INTERNAL_PTR})(actual), (({\b UNITY_UINT32})(num_elements)), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_HEX16}, {\b UNITY_ARRAY_TO_ARRAY})}}
\par
{\bkmkstart AAAAAAABGO}
{\bkmkend AAAAAAABGO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 998 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_HEX16_WITHIN\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_HEX16_WITHIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_HEX16_WITHIN( delta,  expected,  actual,  line,  message)\~ {\b UnityAssertNumbersWithin}(({\b UNITY_UINT16})(delta), ({\b UNITY_INT})({\b UNITY_UINT})({\b UNITY_UINT16})(expected), ({\b UNITY_INT})({\b UNITY_UINT})({\b UNITY_UINT16})(actual), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_HEX16})}}
\par
{\bkmkstart AAAAAAABGP}
{\bkmkend AAAAAAABGP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 985 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_HEX32_ARRAY_WITHIN\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_HEX32_ARRAY_WITHIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_HEX32_ARRAY_WITHIN( delta,  expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertNumbersArrayWithin}(({\b UNITY_UINT32})(delta), ({\b UNITY_INTERNAL_PTR})(expected), ({\b UNITY_INTERNAL_PTR})(actual), (({\b UNITY_UINT32})(num_elements)), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_HEX32}, {\b UNITY_ARRAY_TO_ARRAY})}}
\par
{\bkmkstart AAAAAAABGQ}
{\bkmkend AAAAAAABGQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 999 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_HEX32_WITHIN\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_HEX32_WITHIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_HEX32_WITHIN( delta,  expected,  actual,  line,  message)\~ {\b UnityAssertNumbersWithin}(({\b UNITY_UINT32})(delta), ({\b UNITY_INT})({\b UNITY_UINT})({\b UNITY_UINT32})(expected), ({\b UNITY_INT})({\b UNITY_UINT})({\b UNITY_UINT32})(actual), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_HEX32})}}
\par
{\bkmkstart AAAAAAABGR}
{\bkmkend AAAAAAABGR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 986 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_HEX64_ARRAY_WITHIN\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_HEX64_ARRAY_WITHIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_HEX64_ARRAY_WITHIN( delta,  expected,  actual,  num_elements,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErr64})}}
\par
{\bkmkstart AAAAAAABGS}
{\bkmkend AAAAAAABGS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1095 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_HEX64_WITHIN\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_HEX64_WITHIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_HEX64_WITHIN( delta,  expected,  actual,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErr64})}}
\par
{\bkmkstart AAAAAAABGT}
{\bkmkend AAAAAAABGT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1080 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_HEX8_ARRAY_WITHIN\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_HEX8_ARRAY_WITHIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_HEX8_ARRAY_WITHIN( delta,  expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertNumbersArrayWithin}(({\b UNITY_UINT8} )(delta), ({\b UNITY_INTERNAL_PTR})(expected), ({\b UNITY_INTERNAL_PTR})(actual), (({\b UNITY_UINT32})(num_elements)), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_HEX8}, {\b UNITY_ARRAY_TO_ARRAY})}}
\par
{\bkmkstart AAAAAAABGU}
{\bkmkend AAAAAAABGU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 997 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_HEX8_WITHIN\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_HEX8_WITHIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_HEX8_WITHIN( delta,  expected,  actual,  line,  message)\~ {\b UnityAssertNumbersWithin}(({\b UNITY_UINT8} )(delta), ({\b UNITY_INT})({\b UNITY_UINT})({\b UNITY_UINT8} )(expected), ({\b UNITY_INT})({\b UNITY_UINT})({\b UNITY_UINT8} )(actual), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_HEX8})}}
\par
{\bkmkstart AAAAAAABGV}
{\bkmkend AAAAAAABGV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 984 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_INT16_ARRAY_WITHIN\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_INT16_ARRAY_WITHIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_INT16_ARRAY_WITHIN( delta,  expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertNumbersArrayWithin}(({\b UNITY_UINT16})(delta), ({\b UNITY_INTERNAL_PTR})(expected), ({\b UNITY_INTERNAL_PTR})(actual), (({\b UNITY_UINT32})(num_elements)), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_INT16}, {\b UNITY_ARRAY_TO_ARRAY})}}
\par
{\bkmkstart AAAAAAABGW}
{\bkmkend AAAAAAABGW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 991 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_INT16_WITHIN\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_INT16_WITHIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_INT16_WITHIN( delta,  expected,  actual,  line,  message)\~ {\b UnityAssertNumbersWithin}(({\b UNITY_UINT16})(delta), ({\b UNITY_INT})({\b UNITY_INT16})             (expected), ({\b UNITY_INT})({\b UNITY_INT16})             (actual), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_INT16})}}
\par
{\bkmkstart AAAAAAABGX}
{\bkmkend AAAAAAABGX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 978 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_INT32_ARRAY_WITHIN\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_INT32_ARRAY_WITHIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_INT32_ARRAY_WITHIN( delta,  expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertNumbersArrayWithin}(({\b UNITY_UINT32})(delta), ({\b UNITY_INTERNAL_PTR})(expected), ({\b UNITY_INTERNAL_PTR})(actual), (({\b UNITY_UINT32})(num_elements)), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_INT32}, {\b UNITY_ARRAY_TO_ARRAY})}}
\par
{\bkmkstart AAAAAAABGY}
{\bkmkend AAAAAAABGY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 992 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_INT32_WITHIN\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_INT32_WITHIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_INT32_WITHIN( delta,  expected,  actual,  line,  message)\~ {\b UnityAssertNumbersWithin}(({\b UNITY_UINT32})(delta), ({\b UNITY_INT})({\b UNITY_INT32})             (expected), ({\b UNITY_INT})({\b UNITY_INT32})             (actual), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_INT32})}}
\par
{\bkmkstart AAAAAAABGZ}
{\bkmkend AAAAAAABGZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 979 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_INT64_ARRAY_WITHIN\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_INT64_ARRAY_WITHIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_INT64_ARRAY_WITHIN( delta,  expected,  actual,  num_elements,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErr64})}}
\par
{\bkmkstart AAAAAAABHA}
{\bkmkend AAAAAAABHA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1093 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_INT64_WITHIN\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_INT64_WITHIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_INT64_WITHIN( delta,  expected,  actual,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErr64})}}
\par
{\bkmkstart AAAAAAABHB}
{\bkmkend AAAAAAABHB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1078 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_INT8_ARRAY_WITHIN\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_INT8_ARRAY_WITHIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_INT8_ARRAY_WITHIN( delta,  expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertNumbersArrayWithin}(({\b UNITY_UINT8} )(delta), ({\b UNITY_INTERNAL_PTR})(expected), ({\b UNITY_INTERNAL_PTR})(actual), (({\b UNITY_UINT32})(num_elements)), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_INT8}, {\b UNITY_ARRAY_TO_ARRAY})}}
\par
{\bkmkstart AAAAAAABHC}
{\bkmkend AAAAAAABHC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 990 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_INT8_WITHIN\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_INT8_WITHIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_INT8_WITHIN( delta,  expected,  actual,  line,  message)\~ {\b UnityAssertNumbersWithin}(({\b UNITY_UINT8} )(delta), ({\b UNITY_INT})({\b UNITY_INT8} )             (expected), ({\b UNITY_INT})({\b UNITY_INT8} )             (actual), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_INT8})}}
\par
{\bkmkstart AAAAAAABHD}
{\bkmkend AAAAAAABHD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 977 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_INT_ARRAY_WITHIN\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_INT_ARRAY_WITHIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_INT_ARRAY_WITHIN( delta,  expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertNumbersArrayWithin}(              (delta), ({\b UNITY_INTERNAL_PTR})(expected), ({\b UNITY_INTERNAL_PTR})(actual), (({\b UNITY_UINT32})(num_elements)), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_INT}, {\b UNITY_ARRAY_TO_ARRAY})}}
\par
{\bkmkstart AAAAAAABHE}
{\bkmkend AAAAAAABHE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 989 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_INT_WITHIN\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_INT_WITHIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_INT_WITHIN( delta,  expected,  actual,  line,  message)\~ {\b UnityAssertNumbersWithin}(              (delta), ({\b UNITY_INT})                          (expected), ({\b UNITY_INT})                          (actual), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_INT})}}
\par
{\bkmkstart AAAAAAABHF}
{\bkmkend AAAAAAABHF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 976 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_LESS_OR_EQUAL_DOUBLE\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_LESS_OR_EQUAL_DOUBLE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_LESS_OR_EQUAL_DOUBLE( threshold,  actual,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErrDouble})}}
\par
{\bkmkstart AAAAAAABHG}
{\bkmkend AAAAAAABHG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1151 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_LESS_OR_EQUAL_FLOAT\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_LESS_OR_EQUAL_FLOAT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_LESS_OR_EQUAL_FLOAT( threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessFloat}(({\b UNITY_FLOAT})(threshold), ({\b UNITY_FLOAT})(actual), {\b UNITY_SMALLER_OR_EQUAL}, (message), ({\b UNITY_LINE_TYPE})(line))}}
\par
{\bkmkstart AAAAAAABHH}
{\bkmkend AAAAAAABHH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1129 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_LESS_THAN_DOUBLE\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_LESS_THAN_DOUBLE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_LESS_THAN_DOUBLE( threshold,  actual,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErrDouble})}}
\par
{\bkmkstart AAAAAAABHI}
{\bkmkend AAAAAAABHI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1150 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_LESS_THAN_FLOAT\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_LESS_THAN_FLOAT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_LESS_THAN_FLOAT( threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessFloat}(({\b UNITY_FLOAT})(threshold), ({\b UNITY_FLOAT})(actual), {\b UNITY_SMALLER_THAN}, (message), ({\b UNITY_LINE_TYPE})(line))}}
\par
{\bkmkstart AAAAAAABHJ}
{\bkmkend AAAAAAABHJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1128 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_NOT_EMPTY\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_NOT_EMPTY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_NOT_EMPTY( pointer,  line,  message)\~ {\b UNITY_TEST_ASSERT}(((pointer[0]) != 0),  (line), (message))}}
\par
{\bkmkstart AAAAAAABHK}
{\bkmkend AAAAAAABHK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 895 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_NOT_EQUAL_CHAR\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_NOT_EQUAL_CHAR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_NOT_EQUAL_CHAR( threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_INT8} )(threshold),  ({\b UNITY_INT})({\b UNITY_INT8} )(actual),  {\b UNITY_NOT_EQUAL}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_CHAR})}}
\par
{\bkmkstart AAAAAAABHL}
{\bkmkend AAAAAAABHL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 922 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_NOT_EQUAL_DOUBLE\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_NOT_EQUAL_DOUBLE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_NOT_EQUAL_DOUBLE( expected,  actual,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErrDouble})}}
\par
{\bkmkstart AAAAAAABHM}
{\bkmkend AAAAAAABHM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1144 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_NOT_EQUAL_FLOAT\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_NOT_EQUAL_FLOAT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_NOT_EQUAL_FLOAT( expected,  actual,  line,  message)\~ {\b UNITY_TEST_ASSERT_FLOAT_NOT_WITHIN}(({\b UNITY_FLOAT})(expected) * ({\b UNITY_FLOAT}){\b UNITY_FLOAT_PRECISION}, ({\b UNITY_FLOAT})(expected), ({\b UNITY_FLOAT})(actual), ({\b UNITY_LINE_TYPE})(line), (message))}}
\par
{\bkmkstart AAAAAAABHN}
{\bkmkend AAAAAAABHN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1122 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_NOT_EQUAL_HEX16\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_NOT_EQUAL_HEX16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_NOT_EQUAL_HEX16( threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_UINT16})(threshold), ({\b UNITY_INT})({\b UNITY_UINT16})(actual), {\b UNITY_NOT_EQUAL}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_HEX16})}}
\par
{\bkmkstart AAAAAAABHO}
{\bkmkend AAAAAAABHO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 920 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_NOT_EQUAL_HEX32\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_NOT_EQUAL_HEX32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_NOT_EQUAL_HEX32( threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_UINT32})(threshold), ({\b UNITY_INT})({\b UNITY_UINT32})(actual), {\b UNITY_NOT_EQUAL}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_HEX32})}}
\par
{\bkmkstart AAAAAAABHP}
{\bkmkend AAAAAAABHP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 921 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_NOT_EQUAL_HEX8\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_NOT_EQUAL_HEX8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_NOT_EQUAL_HEX8( threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_UINT8} )(threshold), ({\b UNITY_INT})({\b UNITY_UINT8} )(actual), {\b UNITY_NOT_EQUAL}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_HEX8})}}
\par
{\bkmkstart AAAAAAABHQ}
{\bkmkend AAAAAAABHQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 919 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_NOT_EQUAL_INT\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_NOT_EQUAL_INT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_NOT_EQUAL_INT( threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})(threshold),               ({\b UNITY_INT})(actual),               {\b UNITY_NOT_EQUAL}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_INT})}}
\par
{\bkmkstart AAAAAAABHR}
{\bkmkend AAAAAAABHR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 911 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_NOT_EQUAL_INT16\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_NOT_EQUAL_INT16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_NOT_EQUAL_INT16( threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_INT16})(threshold),  ({\b UNITY_INT})({\b UNITY_INT16})(actual),  {\b UNITY_NOT_EQUAL}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_INT16})}}
\par
{\bkmkstart AAAAAAABHS}
{\bkmkend AAAAAAABHS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 913 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_NOT_EQUAL_INT32\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_NOT_EQUAL_INT32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_NOT_EQUAL_INT32( threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_INT32})(threshold),  ({\b UNITY_INT})({\b UNITY_INT32})(actual),  {\b UNITY_NOT_EQUAL}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_INT32})}}
\par
{\bkmkstart AAAAAAABHT}
{\bkmkend AAAAAAABHT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 914 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_NOT_EQUAL_INT8\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_NOT_EQUAL_INT8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_NOT_EQUAL_INT8( threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_INT8} )(threshold),  ({\b UNITY_INT})({\b UNITY_INT8} )(actual),  {\b UNITY_NOT_EQUAL}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_INT8})}}
\par
{\bkmkstart AAAAAAABHU}
{\bkmkend AAAAAAABHU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 912 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_NOT_EQUAL_UINT\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_NOT_EQUAL_UINT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_NOT_EQUAL_UINT( threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})(threshold),               ({\b UNITY_INT})(actual),               {\b UNITY_NOT_EQUAL}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_UINT})}}
\par
{\bkmkstart AAAAAAABHV}
{\bkmkend AAAAAAABHV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 915 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_NOT_EQUAL_UINT16\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_NOT_EQUAL_UINT16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_NOT_EQUAL_UINT16( threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_UINT16})(threshold), ({\b UNITY_INT})({\b UNITY_UINT16})(actual), {\b UNITY_NOT_EQUAL}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_UINT16})}}
\par
{\bkmkstart AAAAAAABHW}
{\bkmkend AAAAAAABHW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 917 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_NOT_EQUAL_UINT32\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_NOT_EQUAL_UINT32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_NOT_EQUAL_UINT32( threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_UINT32})(threshold), ({\b UNITY_INT})({\b UNITY_UINT32})(actual), {\b UNITY_NOT_EQUAL}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_UINT32})}}
\par
{\bkmkstart AAAAAAABHX}
{\bkmkend AAAAAAABHX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 918 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_NOT_EQUAL_UINT8\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_NOT_EQUAL_UINT8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_NOT_EQUAL_UINT8( threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_UINT8} )(threshold), ({\b UNITY_INT})({\b UNITY_UINT8} )(actual), {\b UNITY_NOT_EQUAL}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_UINT8})}}
\par
{\bkmkstart AAAAAAABHY}
{\bkmkend AAAAAAABHY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 916 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_NOT_NULL\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_NOT_NULL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_NOT_NULL( pointer,  line,  message)\~ {\b UNITY_TEST_ASSERT}(((pointer) != NULL),  (line), (message))}}
\par
{\bkmkstart AAAAAAABHZ}
{\bkmkend AAAAAAABHZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 893 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_NULL\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_NULL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_NULL( pointer,  line,  message)\~ {\b UNITY_TEST_ASSERT}(((pointer) == NULL),  (line), (message))}}
\par
{\bkmkstart AAAAAAABIA}
{\bkmkend AAAAAAABIA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 892 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_CHAR\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_CHAR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_CHAR( threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_INT8} )(threshold),  ({\b UNITY_INT})({\b UNITY_INT8} ) (actual), {\b UNITY_SMALLER_OR_EQUAL}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_CHAR})}}
\par
{\bkmkstart AAAAAAABIB}
{\bkmkend AAAAAAABIB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 974 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_HEX16\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_HEX16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_HEX16( threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_UINT16})(threshold), ({\b UNITY_INT})({\b UNITY_UINT16})(actual), {\b UNITY_SMALLER_OR_EQUAL}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_HEX16})}}
\par
{\bkmkstart AAAAAAABIC}
{\bkmkend AAAAAAABIC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 972 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_HEX32\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_HEX32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_HEX32( threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_UINT32})(threshold), ({\b UNITY_INT})({\b UNITY_UINT32})(actual), {\b UNITY_SMALLER_OR_EQUAL}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_HEX32})}}
\par
{\bkmkstart AAAAAAABID}
{\bkmkend AAAAAAABID}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 973 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_HEX64\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_HEX64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_HEX64( threshold,  actual,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErr64})}}
\par
{\bkmkstart AAAAAAABIE}
{\bkmkend AAAAAAABIE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1092 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_HEX8\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_HEX8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_HEX8( threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_UINT8} )(threshold), ({\b UNITY_INT})({\b UNITY_UINT8} )(actual), {\b UNITY_SMALLER_OR_EQUAL}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_HEX8})}}
\par
{\bkmkstart AAAAAAABIF}
{\bkmkend AAAAAAABIF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 971 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_INT\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_INT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_INT( threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})             (threshold),  ({\b UNITY_INT})              (actual), {\b UNITY_SMALLER_OR_EQUAL}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_INT})}}
\par
{\bkmkstart AAAAAAABIG}
{\bkmkend AAAAAAABIG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 963 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_INT16\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_INT16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_INT16( threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_INT16})(threshold),  ({\b UNITY_INT})({\b UNITY_INT16}) (actual), {\b UNITY_SMALLER_OR_EQUAL}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_INT16})}}
\par
{\bkmkstart AAAAAAABIH}
{\bkmkend AAAAAAABIH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 965 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_INT32\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_INT32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_INT32( threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_INT32})(threshold),  ({\b UNITY_INT})({\b UNITY_INT32}) (actual), {\b UNITY_SMALLER_OR_EQUAL}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_INT32})}}
\par
{\bkmkstart AAAAAAABII}
{\bkmkend AAAAAAABII}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 966 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_INT64\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_INT64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_INT64( threshold,  actual,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErr64})}}
\par
{\bkmkstart AAAAAAABIJ}
{\bkmkend AAAAAAABIJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1090 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_INT8\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_INT8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_INT8( threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_INT8} )(threshold),  ({\b UNITY_INT})({\b UNITY_INT8} ) (actual), {\b UNITY_SMALLER_OR_EQUAL}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_INT8})}}
\par
{\bkmkstart AAAAAAABIK}
{\bkmkend AAAAAAABIK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 964 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_UINT\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_UINT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_UINT( threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})             (threshold),  ({\b UNITY_INT})              (actual), {\b UNITY_SMALLER_OR_EQUAL}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_UINT})}}
\par
{\bkmkstart AAAAAAABIL}
{\bkmkend AAAAAAABIL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 967 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_UINT16\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_UINT16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_UINT16( threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_UINT16})(threshold), ({\b UNITY_INT})({\b UNITY_UINT16})(actual), {\b UNITY_SMALLER_OR_EQUAL}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_UINT16})}}
\par
{\bkmkstart AAAAAAABIM}
{\bkmkend AAAAAAABIM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 969 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_UINT32\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_UINT32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_UINT32( threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_UINT32})(threshold), ({\b UNITY_INT})({\b UNITY_UINT32})(actual), {\b UNITY_SMALLER_OR_EQUAL}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_UINT32})}}
\par
{\bkmkstart AAAAAAABIN}
{\bkmkend AAAAAAABIN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 970 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_UINT64\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_UINT64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_UINT64( threshold,  actual,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErr64})}}
\par
{\bkmkstart AAAAAAABIO}
{\bkmkend AAAAAAABIO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1091 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_UINT8\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_UINT8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_UINT8( threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_UINT8} )(threshold), ({\b UNITY_INT})({\b UNITY_UINT8} )(actual), {\b UNITY_SMALLER_OR_EQUAL}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_UINT8})}}
\par
{\bkmkstart AAAAAAABIP}
{\bkmkend AAAAAAABIP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 968 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_SMALLER_THAN_CHAR\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_SMALLER_THAN_CHAR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_SMALLER_THAN_CHAR( threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_INT8} )(threshold), ({\b UNITY_INT})({\b UNITY_INT8} )(actual), {\b UNITY_SMALLER_THAN}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_CHAR})}}
\par
{\bkmkstart AAAAAAABIQ}
{\bkmkend AAAAAAABIQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 948 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_SMALLER_THAN_HEX16\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_SMALLER_THAN_HEX16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_SMALLER_THAN_HEX16( threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_UINT16})(threshold), ({\b UNITY_INT})({\b UNITY_UINT16})(actual), {\b UNITY_SMALLER_THAN}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_HEX16})}}
\par
{\bkmkstart AAAAAAABIR}
{\bkmkend AAAAAAABIR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 946 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_SMALLER_THAN_HEX32\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_SMALLER_THAN_HEX32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_SMALLER_THAN_HEX32( threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_UINT32})(threshold), ({\b UNITY_INT})({\b UNITY_UINT32})(actual), {\b UNITY_SMALLER_THAN}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_HEX32})}}
\par
{\bkmkstart AAAAAAABIS}
{\bkmkend AAAAAAABIS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 947 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_SMALLER_THAN_HEX64\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_SMALLER_THAN_HEX64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_SMALLER_THAN_HEX64( threshold,  actual,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErr64})}}
\par
{\bkmkstart AAAAAAABIT}
{\bkmkend AAAAAAABIT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1089 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_SMALLER_THAN_HEX8\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_SMALLER_THAN_HEX8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_SMALLER_THAN_HEX8( threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_UINT8} )(threshold), ({\b UNITY_INT})({\b UNITY_UINT8} )(actual), {\b UNITY_SMALLER_THAN}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_HEX8})}}
\par
{\bkmkstart AAAAAAABIU}
{\bkmkend AAAAAAABIU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 945 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_SMALLER_THAN_INT\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_SMALLER_THAN_INT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_SMALLER_THAN_INT( threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})(threshold),              ({\b UNITY_INT})(actual),              {\b UNITY_SMALLER_THAN}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_INT})}}
\par
{\bkmkstart AAAAAAABIV}
{\bkmkend AAAAAAABIV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 937 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_SMALLER_THAN_INT16\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_SMALLER_THAN_INT16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_SMALLER_THAN_INT16( threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_INT16})(threshold), ({\b UNITY_INT})({\b UNITY_INT16})(actual), {\b UNITY_SMALLER_THAN}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_INT16})}}
\par
{\bkmkstart AAAAAAABIW}
{\bkmkend AAAAAAABIW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 939 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_SMALLER_THAN_INT32\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_SMALLER_THAN_INT32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_SMALLER_THAN_INT32( threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_INT32})(threshold), ({\b UNITY_INT})({\b UNITY_INT32})(actual), {\b UNITY_SMALLER_THAN}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_INT32})}}
\par
{\bkmkstart AAAAAAABIX}
{\bkmkend AAAAAAABIX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 940 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_SMALLER_THAN_INT64\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_SMALLER_THAN_INT64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_SMALLER_THAN_INT64( threshold,  actual,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErr64})}}
\par
{\bkmkstart AAAAAAABIY}
{\bkmkend AAAAAAABIY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1087 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_SMALLER_THAN_INT8\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_SMALLER_THAN_INT8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_SMALLER_THAN_INT8( threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_INT8} )(threshold), ({\b UNITY_INT})({\b UNITY_INT8} )(actual), {\b UNITY_SMALLER_THAN}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_INT8})}}
\par
{\bkmkstart AAAAAAABIZ}
{\bkmkend AAAAAAABIZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 938 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_SMALLER_THAN_UINT\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_SMALLER_THAN_UINT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_SMALLER_THAN_UINT( threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})(threshold),              ({\b UNITY_INT})(actual),              {\b UNITY_SMALLER_THAN}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_UINT})}}
\par
{\bkmkstart AAAAAAABJA}
{\bkmkend AAAAAAABJA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 941 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_SMALLER_THAN_UINT16\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_SMALLER_THAN_UINT16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_SMALLER_THAN_UINT16( threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_UINT16})(threshold), ({\b UNITY_INT})({\b UNITY_UINT16})(actual), {\b UNITY_SMALLER_THAN}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_UINT16})}}
\par
{\bkmkstart AAAAAAABJB}
{\bkmkend AAAAAAABJB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 943 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_SMALLER_THAN_UINT32\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_SMALLER_THAN_UINT32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_SMALLER_THAN_UINT32( threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_UINT32})(threshold), ({\b UNITY_INT})({\b UNITY_UINT32})(actual), {\b UNITY_SMALLER_THAN}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_UINT32})}}
\par
{\bkmkstart AAAAAAABJC}
{\bkmkend AAAAAAABJC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 944 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_SMALLER_THAN_UINT64\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_SMALLER_THAN_UINT64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_SMALLER_THAN_UINT64( threshold,  actual,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErr64})}}
\par
{\bkmkstart AAAAAAABJD}
{\bkmkend AAAAAAABJD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1088 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_SMALLER_THAN_UINT8\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_SMALLER_THAN_UINT8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_SMALLER_THAN_UINT8( threshold,  actual,  line,  message)\~ {\b UnityAssertGreaterOrLessOrEqualNumber}(({\b UNITY_INT})({\b UNITY_UINT8} )(threshold), ({\b UNITY_INT})({\b UNITY_UINT8} )(actual), {\b UNITY_SMALLER_THAN}, (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_UINT8})}}
\par
{\bkmkstart AAAAAAABJE}
{\bkmkend AAAAAAABJE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 942 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_UINT16_ARRAY_WITHIN\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_UINT16_ARRAY_WITHIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_UINT16_ARRAY_WITHIN( delta,  expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertNumbersArrayWithin}(({\b UNITY_UINT16})(delta), ({\b UNITY_INTERNAL_PTR})(expected), ({\b UNITY_INTERNAL_PTR})(actual), (({\b UNITY_UINT32})(num_elements)), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_UINT16}, {\b UNITY_ARRAY_TO_ARRAY})}}
\par
{\bkmkstart AAAAAAABJF}
{\bkmkend AAAAAAABJF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 995 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_UINT16_WITHIN\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_UINT16_WITHIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_UINT16_WITHIN( delta,  expected,  actual,  line,  message)\~ {\b UnityAssertNumbersWithin}(({\b UNITY_UINT16})(delta), ({\b UNITY_INT})({\b UNITY_UINT})({\b UNITY_UINT16})(expected), ({\b UNITY_INT})({\b UNITY_UINT})({\b UNITY_UINT16})(actual), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_UINT16})}}
\par
{\bkmkstart AAAAAAABJG}
{\bkmkend AAAAAAABJG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 982 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_UINT32_ARRAY_WITHIN\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_UINT32_ARRAY_WITHIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_UINT32_ARRAY_WITHIN( delta,  expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertNumbersArrayWithin}(({\b UNITY_UINT32})(delta), ({\b UNITY_INTERNAL_PTR})(expected), ({\b UNITY_INTERNAL_PTR})(actual), (({\b UNITY_UINT32})(num_elements)), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_UINT32}, {\b UNITY_ARRAY_TO_ARRAY})}}
\par
{\bkmkstart AAAAAAABJH}
{\bkmkend AAAAAAABJH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 996 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_UINT32_WITHIN\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_UINT32_WITHIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_UINT32_WITHIN( delta,  expected,  actual,  line,  message)\~ {\b UnityAssertNumbersWithin}(({\b UNITY_UINT32})(delta), ({\b UNITY_INT})({\b UNITY_UINT})({\b UNITY_UINT32})(expected), ({\b UNITY_INT})({\b UNITY_UINT})({\b UNITY_UINT32})(actual), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_UINT32})}}
\par
{\bkmkstart AAAAAAABJI}
{\bkmkend AAAAAAABJI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 983 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_UINT64_ARRAY_WITHIN\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_UINT64_ARRAY_WITHIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_UINT64_ARRAY_WITHIN( delta,  expected,  actual,  num_elements,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErr64})}}
\par
{\bkmkstart AAAAAAABJJ}
{\bkmkend AAAAAAABJJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1094 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_UINT64_WITHIN\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_UINT64_WITHIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_UINT64_WITHIN( delta,  expected,  actual,  line,  message)\~ {\b UNITY_TEST_FAIL}(({\b UNITY_LINE_TYPE})(line), {\b UnityStrErr64})}}
\par
{\bkmkstart AAAAAAABJK}
{\bkmkend AAAAAAABJK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1079 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_UINT8_ARRAY_WITHIN\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_UINT8_ARRAY_WITHIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_UINT8_ARRAY_WITHIN( delta,  expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertNumbersArrayWithin}(({\b UNITY_UINT8} )(delta), ({\b UNITY_INTERNAL_PTR})(expected), ({\b UNITY_INTERNAL_PTR})(actual), (({\b UNITY_UINT32})(num_elements)), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_UINT8}, {\b UNITY_ARRAY_TO_ARRAY})}}
\par
{\bkmkstart AAAAAAABJL}
{\bkmkend AAAAAAABJL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 994 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_UINT8_WITHIN\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_UINT8_WITHIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_UINT8_WITHIN( delta,  expected,  actual,  line,  message)\~ {\b UnityAssertNumbersWithin}(({\b UNITY_UINT8} )(delta), ({\b UNITY_INT})({\b UNITY_UINT})({\b UNITY_UINT8} )(expected), ({\b UNITY_INT})({\b UNITY_UINT})({\b UNITY_UINT8} )(actual), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_UINT8})}}
\par
{\bkmkstart AAAAAAABJM}
{\bkmkend AAAAAAABJM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 981 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_UINT_ARRAY_WITHIN\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_UINT_ARRAY_WITHIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_UINT_ARRAY_WITHIN( delta,  expected,  actual,  num_elements,  line,  message)\~ {\b UnityAssertNumbersArrayWithin}(              (delta), ({\b UNITY_INTERNAL_PTR})(expected), ({\b UNITY_INTERNAL_PTR})(actual), (({\b UNITY_UINT32})(num_elements)), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_UINT}, {\b UNITY_ARRAY_TO_ARRAY})}}
\par
{\bkmkstart AAAAAAABJN}
{\bkmkend AAAAAAABJN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 993 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_ASSERT_UINT_WITHIN\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_ASSERT_UINT_WITHIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_ASSERT_UINT_WITHIN( delta,  expected,  actual,  line,  message)\~ {\b UnityAssertNumbersWithin}(              (delta), ({\b UNITY_INT})                          (expected), ({\b UNITY_INT})                          (actual), (message), ({\b UNITY_LINE_TYPE})(line), {\b UNITY_DISPLAY_STYLE_UINT})}}
\par
{\bkmkstart AAAAAAABJO}
{\bkmkend AAAAAAABJO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 980 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_FAIL\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_FAIL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_FAIL( line,  message)\~ {\b UnityFail}(   (message), ({\b UNITY_LINE_TYPE})(line))}}
\par
{\bkmkstart AAAAAAABJP}
{\bkmkend AAAAAAABJP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 884 of file unity_internals.h.}\par
}
{\xe \v UNITY_TEST_IGNORE\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TEST_IGNORE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TEST_IGNORE( line,  message)\~ {\b UnityIgnore}( (message), ({\b UNITY_LINE_TYPE})(line))}}
\par
{\bkmkstart AAAAAAABJQ}
{\bkmkend AAAAAAABJQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 885 of file unity_internals.h.}\par
}
{\xe \v UNITY_TIME_TYPE\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_TIME_TYPE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNITY_TIME_TYPE\~ {\b UNITY_UINT}}}
\par
{\bkmkstart AAAAAAABJR}
{\bkmkend AAAAAAABJR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 421 of file unity_internals.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v UNITY_DOUBLE\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_DOUBLE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b UNITY_FLOAT} {\b UNITY_DOUBLE}}}
\par
{\bkmkstart AAAAAAABJS}
{\bkmkend AAAAAAABJS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 299 of file unity_internals.h.}\par
}
{\xe \v UNITY_FLOAT\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_FLOAT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b UNITY_FLOAT_TYPE} {\b UNITY_FLOAT}}}
\par
{\bkmkstart AAAAAAABJT}
{\bkmkend AAAAAAABJT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 256 of file unity_internals.h.}\par
}
{\xe \v UNITY_FLOAT_TRAIT_T\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_FLOAT_TRAIT_T}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef enum {\b UNITY_FLOAT_TRAIT} {\b UNITY_FLOAT_TRAIT_T}}}
\par
{\bkmkstart AAAAAAABJU}
{\bkmkend AAAAAAABJU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v UNITY_INT\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_INT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b UNITY_INT32} {\b UNITY_INT}}}
\par
{\bkmkstart AAAAAAABJV}
{\bkmkend AAAAAAABJV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 188 of file unity_internals.h.}\par
}
{\xe \v UNITY_INT16\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_INT16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef signed short {\b UNITY_INT16}}}
\par
{\bkmkstart AAAAAAABJW}
{\bkmkend AAAAAAABJW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 160 of file unity_internals.h.}\par
}
{\xe \v UNITY_INT32\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_INT32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef signed int {\b UNITY_INT32}}}
\par
{\bkmkstart AAAAAAABJX}
{\bkmkend AAAAAAABJX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 161 of file unity_internals.h.}\par
}
{\xe \v UNITY_INT8\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_INT8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef signed char {\b UNITY_INT8}}}
\par
{\bkmkstart AAAAAAABJY}
{\bkmkend AAAAAAABJY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 159 of file unity_internals.h.}\par
}
{\xe \v UNITY_UINT\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_UINT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b UNITY_UINT32} {\b UNITY_UINT}}}
\par
{\bkmkstart AAAAAAABJZ}
{\bkmkend AAAAAAABJZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 187 of file unity_internals.h.}\par
}
{\xe \v UNITY_UINT16\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_UINT16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef unsigned short {\b UNITY_UINT16}}}
\par
{\bkmkstart AAAAAAABKA}
{\bkmkend AAAAAAABKA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 157 of file unity_internals.h.}\par
}
{\xe \v UNITY_UINT32\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_UINT32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef unsigned int {\b UNITY_UINT32}}}
\par
{\bkmkstart AAAAAAABKB}
{\bkmkend AAAAAAABKB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 158 of file unity_internals.h.}\par
}
{\xe \v UNITY_UINT8\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_UINT8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef unsigned char {\b UNITY_UINT8}}}
\par
{\bkmkstart AAAAAAABKC}
{\bkmkend AAAAAAABKC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 156 of file unity_internals.h.}\par
}
{\xe \v UnityTestFunction\:unity_internals.h}
{\xe \v unity_internals.h\:UnityTestFunction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef void(* UnityTestFunction) (void)}}
\par
{\bkmkstart AAAAAAABKD}
{\bkmkend AAAAAAABKD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 444 of file unity_internals.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeration Type Documentation\par
\pard\plain 
{\xe \v UNITY_COMPARISON_T\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_COMPARISON_T}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b UNITY_COMPARISON_T}}}
\par
{\bkmkstart AAAAAAABKE}
{\bkmkend AAAAAAABKE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v UNITY_WITHIN\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_WITHIN}
{\qr UNITY_WITHIN{\bkmkstart AAAAAAABKF}
{\bkmkend AAAAAAABKF}
\cell }{\cell }{\row }
{\xe \v UNITY_EQUAL_TO\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_EQUAL_TO}
{\qr UNITY_EQUAL_TO{\bkmkstart AAAAAAABKG}
{\bkmkend AAAAAAABKG}
\cell }{\cell }{\row }
{\xe \v UNITY_GREATER_THAN\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_GREATER_THAN}
{\qr UNITY_GREATER_THAN{\bkmkstart AAAAAAABKH}
{\bkmkend AAAAAAABKH}
\cell }{\cell }{\row }
{\xe \v UNITY_GREATER_OR_EQUAL\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_GREATER_OR_EQUAL}
{\qr UNITY_GREATER_OR_EQUAL{\bkmkstart AAAAAAABKI}
{\bkmkend AAAAAAABKI}
\cell }{\cell }{\row }
{\xe \v UNITY_SMALLER_THAN\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_SMALLER_THAN}
{\qr UNITY_SMALLER_THAN{\bkmkstart AAAAAAABKJ}
{\bkmkend AAAAAAABKJ}
\cell }{\cell }{\row }
{\xe \v UNITY_SMALLER_OR_EQUAL\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_SMALLER_OR_EQUAL}
{\qr UNITY_SMALLER_OR_EQUAL{\bkmkstart AAAAAAABKK}
{\bkmkend AAAAAAABKK}
\cell }{\cell }{\row }
{\xe \v UNITY_NOT_EQUAL\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_NOT_EQUAL}
{\qr UNITY_NOT_EQUAL{\bkmkstart AAAAAAABKL}
{\bkmkend AAAAAAABKL}
\cell }{\cell }{\row }
{\xe \v UNITY_UNKNOWN\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_UNKNOWN}
{\qr UNITY_UNKNOWN{\bkmkstart AAAAAAABKM}
{\bkmkend AAAAAAABKM}
\cell }{\cell }{\row }
}
\par
{
Definition at line 481 of file unity_internals.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 482 \{\par
483     UNITY_WITHIN           = 0x0,\par
484     UNITY_EQUAL_TO         = 0x1,\par
485     UNITY_GREATER_THAN     = 0x2,\par
486     UNITY_GREATER_OR_EQUAL = 0x2 + UNITY_EQUAL_TO,\par
487     UNITY_SMALLER_THAN     = 0x4,\par
488     UNITY_SMALLER_OR_EQUAL = 0x4 + UNITY_EQUAL_TO,\par
489     UNITY_NOT_EQUAL        = 0x0,\par
490     UNITY_UNKNOWN\par
491 \} UNITY_COMPARISON_T;\par
}
}
{\xe \v UNITY_DISPLAY_STYLE_T\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_DISPLAY_STYLE_T}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b UNITY_DISPLAY_STYLE_T}}}
\par
{\bkmkstart AAAAAAABKN}
{\bkmkend AAAAAAABKN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v UNITY_DISPLAY_STYLE_INT\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_DISPLAY_STYLE_INT}
{\qr UNITY_DISPLAY_STYLE_INT{\bkmkstart AAAAAAABKO}
{\bkmkend AAAAAAABKO}
\cell }{\cell }{\row }
{\xe \v UNITY_DISPLAY_STYLE_INT8\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_DISPLAY_STYLE_INT8}
{\qr UNITY_DISPLAY_STYLE_INT8{\bkmkstart AAAAAAABKP}
{\bkmkend AAAAAAABKP}
\cell }{\cell }{\row }
{\xe \v UNITY_DISPLAY_STYLE_INT16\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_DISPLAY_STYLE_INT16}
{\qr UNITY_DISPLAY_STYLE_INT16{\bkmkstart AAAAAAABKQ}
{\bkmkend AAAAAAABKQ}
\cell }{\cell }{\row }
{\xe \v UNITY_DISPLAY_STYLE_INT32\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_DISPLAY_STYLE_INT32}
{\qr UNITY_DISPLAY_STYLE_INT32{\bkmkstart AAAAAAABKR}
{\bkmkend AAAAAAABKR}
\cell }{\cell }{\row }
{\xe \v UNITY_DISPLAY_STYLE_UINT\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_DISPLAY_STYLE_UINT}
{\qr UNITY_DISPLAY_STYLE_UINT{\bkmkstart AAAAAAABKS}
{\bkmkend AAAAAAABKS}
\cell }{\cell }{\row }
{\xe \v UNITY_DISPLAY_STYLE_UINT8\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_DISPLAY_STYLE_UINT8}
{\qr UNITY_DISPLAY_STYLE_UINT8{\bkmkstart AAAAAAABKT}
{\bkmkend AAAAAAABKT}
\cell }{\cell }{\row }
{\xe \v UNITY_DISPLAY_STYLE_UINT16\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_DISPLAY_STYLE_UINT16}
{\qr UNITY_DISPLAY_STYLE_UINT16{\bkmkstart AAAAAAABKU}
{\bkmkend AAAAAAABKU}
\cell }{\cell }{\row }
{\xe \v UNITY_DISPLAY_STYLE_UINT32\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_DISPLAY_STYLE_UINT32}
{\qr UNITY_DISPLAY_STYLE_UINT32{\bkmkstart AAAAAAABKV}
{\bkmkend AAAAAAABKV}
\cell }{\cell }{\row }
{\xe \v UNITY_DISPLAY_STYLE_HEX8\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_DISPLAY_STYLE_HEX8}
{\qr UNITY_DISPLAY_STYLE_HEX8{\bkmkstart AAAAAAABKW}
{\bkmkend AAAAAAABKW}
\cell }{\cell }{\row }
{\xe \v UNITY_DISPLAY_STYLE_HEX16\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_DISPLAY_STYLE_HEX16}
{\qr UNITY_DISPLAY_STYLE_HEX16{\bkmkstart AAAAAAABKX}
{\bkmkend AAAAAAABKX}
\cell }{\cell }{\row }
{\xe \v UNITY_DISPLAY_STYLE_HEX32\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_DISPLAY_STYLE_HEX32}
{\qr UNITY_DISPLAY_STYLE_HEX32{\bkmkstart AAAAAAABKY}
{\bkmkend AAAAAAABKY}
\cell }{\cell }{\row }
{\xe \v UNITY_DISPLAY_STYLE_CHAR\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_DISPLAY_STYLE_CHAR}
{\qr UNITY_DISPLAY_STYLE_CHAR{\bkmkstart AAAAAAABKZ}
{\bkmkend AAAAAAABKZ}
\cell }{\cell }{\row }
{\xe \v UNITY_DISPLAY_STYLE_UNKNOWN\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_DISPLAY_STYLE_UNKNOWN}
{\qr UNITY_DISPLAY_STYLE_UNKNOWN{\bkmkstart AAAAAAABLA}
{\bkmkend AAAAAAABLA}
\cell }{\cell }{\row }
}
\par
{
Definition at line 451 of file unity_internals.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 452 \{\par
453     UNITY_DISPLAY_STYLE_INT      = (UNITY_INT_WIDTH / 8) + UNITY_DISPLAY_RANGE_INT,\par
454     UNITY_DISPLAY_STYLE_INT8     = 1 + UNITY_DISPLAY_RANGE_INT,\par
455     UNITY_DISPLAY_STYLE_INT16    = 2 + UNITY_DISPLAY_RANGE_INT,\par
456     UNITY_DISPLAY_STYLE_INT32    = 4 + UNITY_DISPLAY_RANGE_INT,\par
457 #ifdef UNITY_SUPPORT_64\par
458     UNITY_DISPLAY_STYLE_INT64    = 8 + UNITY_DISPLAY_RANGE_INT,\par
459 #endif\par
460 \par
461     UNITY_DISPLAY_STYLE_UINT     = (UNITY_INT_WIDTH / 8) + UNITY_DISPLAY_RANGE_UINT,\par
462     UNITY_DISPLAY_STYLE_UINT8    = 1 + UNITY_DISPLAY_RANGE_UINT,\par
463     UNITY_DISPLAY_STYLE_UINT16   = 2 + UNITY_DISPLAY_RANGE_UINT,\par
464     UNITY_DISPLAY_STYLE_UINT32   = 4 + UNITY_DISPLAY_RANGE_UINT,\par
465 {\cf21 #ifdef UNITY_SUPPORT_64}\par
466     UNITY_DISPLAY_STYLE_UINT64   = 8 + UNITY_DISPLAY_RANGE_UINT,\par
467 {\cf21 #endif}\par
468 \par
469     UNITY_DISPLAY_STYLE_HEX8     = 1 + UNITY_DISPLAY_RANGE_HEX,\par
470     UNITY_DISPLAY_STYLE_HEX16    = 2 + UNITY_DISPLAY_RANGE_HEX,\par
471     UNITY_DISPLAY_STYLE_HEX32    = 4 + UNITY_DISPLAY_RANGE_HEX,\par
472 {\cf21 #ifdef UNITY_SUPPORT_64}\par
473     UNITY_DISPLAY_STYLE_HEX64    = 8 + UNITY_DISPLAY_RANGE_HEX,\par
474 {\cf21 #endif}\par
475 \par
476     UNITY_DISPLAY_STYLE_CHAR     = 1 + UNITY_DISPLAY_RANGE_CHAR + UNITY_DISPLAY_RANGE_INT,\par
477 \par
478     UNITY_DISPLAY_STYLE_UNKNOWN\par
479 \} UNITY_DISPLAY_STYLE_T;\par
}
}
{\xe \v UNITY_FLAGS_T\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_FLAGS_T}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b UNITY_FLAGS_T}}}
\par
{\bkmkstart AAAAAAABLB}
{\bkmkend AAAAAAABLB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v UNITY_ARRAY_TO_VAL\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_ARRAY_TO_VAL}
{\qr UNITY_ARRAY_TO_VAL{\bkmkstart AAAAAAABLC}
{\bkmkend AAAAAAABLC}
\cell }{\cell }{\row }
{\xe \v UNITY_ARRAY_TO_ARRAY\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_ARRAY_TO_ARRAY}
{\qr UNITY_ARRAY_TO_ARRAY{\bkmkstart AAAAAAABLD}
{\bkmkend AAAAAAABLD}
\cell }{\cell }{\row }
{\xe \v UNITY_ARRAY_UNKNOWN\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_ARRAY_UNKNOWN}
{\qr UNITY_ARRAY_UNKNOWN{\bkmkstart AAAAAAABLE}
{\bkmkend AAAAAAABLE}
\cell }{\cell }{\row }
}
\par
{
Definition at line 508 of file unity_internals.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 509 \{\par
510     UNITY_ARRAY_TO_VAL = 0,\par
511     UNITY_ARRAY_TO_ARRAY,\par
512     UNITY_ARRAY_UNKNOWN\par
513 \} UNITY_FLAGS_T;\par
}
}
{\xe \v UNITY_FLOAT_TRAIT\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_FLOAT_TRAIT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b UNITY_FLOAT_TRAIT}}}
\par
{\bkmkstart AAAAAAABLF}
{\bkmkend AAAAAAABLF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v UNITY_FLOAT_IS_NOT_INF\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_FLOAT_IS_NOT_INF}
{\qr UNITY_FLOAT_IS_NOT_INF{\bkmkstart AAAAAAABLG}
{\bkmkend AAAAAAABLG}
\cell }{\cell }{\row }
{\xe \v UNITY_FLOAT_IS_INF\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_FLOAT_IS_INF}
{\qr UNITY_FLOAT_IS_INF{\bkmkstart AAAAAAABLH}
{\bkmkend AAAAAAABLH}
\cell }{\cell }{\row }
{\xe \v UNITY_FLOAT_IS_NOT_NEG_INF\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_FLOAT_IS_NOT_NEG_INF}
{\qr UNITY_FLOAT_IS_NOT_NEG_INF{\bkmkstart AAAAAAABLI}
{\bkmkend AAAAAAABLI}
\cell }{\cell }{\row }
{\xe \v UNITY_FLOAT_IS_NEG_INF\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_FLOAT_IS_NEG_INF}
{\qr UNITY_FLOAT_IS_NEG_INF{\bkmkstart AAAAAAABLJ}
{\bkmkend AAAAAAABLJ}
\cell }{\cell }{\row }
{\xe \v UNITY_FLOAT_IS_NOT_NAN\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_FLOAT_IS_NOT_NAN}
{\qr UNITY_FLOAT_IS_NOT_NAN{\bkmkstart AAAAAAABLK}
{\bkmkend AAAAAAABLK}
\cell }{\cell }{\row }
{\xe \v UNITY_FLOAT_IS_NAN\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_FLOAT_IS_NAN}
{\qr UNITY_FLOAT_IS_NAN{\bkmkstart AAAAAAABLL}
{\bkmkend AAAAAAABLL}
\cell }{\cell }{\row }
{\xe \v UNITY_FLOAT_IS_NOT_DET\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_FLOAT_IS_NOT_DET}
{\qr UNITY_FLOAT_IS_NOT_DET{\bkmkstart AAAAAAABLM}
{\bkmkend AAAAAAABLM}
\cell }{\cell }{\row }
{\xe \v UNITY_FLOAT_IS_DET\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_FLOAT_IS_DET}
{\qr UNITY_FLOAT_IS_DET{\bkmkstart AAAAAAABLN}
{\bkmkend AAAAAAABLN}
\cell }{\cell }{\row }
{\xe \v UNITY_FLOAT_INVALID_TRAIT\:unity_internals.h}
{\xe \v unity_internals.h\:UNITY_FLOAT_INVALID_TRAIT}
{\qr UNITY_FLOAT_INVALID_TRAIT{\bkmkstart AAAAAAABLO}
{\bkmkend AAAAAAABLO}
\cell }{\cell }{\row }
}
\par
{
Definition at line 494 of file unity_internals.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 495 \{\par
496     UNITY_FLOAT_IS_NOT_INF       = 0,\par
497     UNITY_FLOAT_IS_INF,\par
498     UNITY_FLOAT_IS_NOT_NEG_INF,\par
499     UNITY_FLOAT_IS_NEG_INF,\par
500     UNITY_FLOAT_IS_NOT_NAN,\par
501     UNITY_FLOAT_IS_NAN,\par
502     UNITY_FLOAT_IS_NOT_DET,\par
503     UNITY_FLOAT_IS_DET,\par
504     UNITY_FLOAT_INVALID_TRAIT\par
505 \} UNITY_FLOAT_TRAIT_T;\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v UnityAssertBits\:unity_internals.h}
{\xe \v unity_internals.h\:UnityAssertBits}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void UnityAssertBits (const {\b UNITY_INT}  {\i mask}, const {\b UNITY_INT}  {\i expected}, const {\b UNITY_INT}  {\i actual}, const char *  {\i msg}, const {\b UNITY_LINE_TYPE}  {\i lineNumber})}}
\par
{\bkmkstart AAAAAAABLP}
{\bkmkend AAAAAAABLP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 691 of file unity.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 696 \{\par
697     RETURN_IF_FAIL_OR_IGNORE;\par
698 \par
699     {\cf19 if} ((mask & expected) != (mask & actual))\par
700     \{\par
701         UnityTestResultsFailBegin(lineNumber);\par
702         UnityPrint(UnityStrExpected);\par
703         UnityPrintMask((UNITY_UINT)mask, (UNITY_UINT)expected);\par
704         UnityPrint(UnityStrWas);\par
705         UnityPrintMask((UNITY_UINT)mask, (UNITY_UINT)actual);\par
706         UnityAddMsgIfSpecified(msg);\par
707         UNITY_FAIL_AND_BAIL;\par
708     \}\par
709 \}\par
}
}
{\xe \v UnityAssertEqualIntArray\:unity_internals.h}
{\xe \v unity_internals.h\:UnityAssertEqualIntArray}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void UnityAssertEqualIntArray ({\b UNITY_INTERNAL_PTR}  {\i expected}, {\b UNITY_INTERNAL_PTR}  {\i actual}, const {\b UNITY_UINT32}  {\i num_elements}, const char *  {\i msg}, const {\b UNITY_LINE_TYPE}  {\i lineNumber}, const {\b UNITY_DISPLAY_STYLE_T}  {\i style}, const {\b UNITY_FLAGS_T}  {\i flags})}}
\par
{\bkmkstart AAAAAAABLQ}
{\bkmkend AAAAAAABLQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 781 of file unity.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 788 \{\par
789     UNITY_UINT32 elements  = num_elements;\par
790     {\cf18 unsigned} {\cf18 int} length    = style & 0xF;\par
791     {\cf18 unsigned} {\cf18 int} increment = 0;\par
792 \par
793     RETURN_IF_FAIL_OR_IGNORE;\par
794 \par
795     {\cf19 if} (num_elements == 0)\par
796     \{\par
797 {\cf21 #ifdef UNITY_COMPARE_PTRS_ON_ZERO_ARRAY}\par
798         UNITY_TEST_ASSERT_EQUAL_PTR(expected, actual, lineNumber, msg);\par
799 {\cf21 #else}\par
800         UnityPrintPointlessAndBail();\par
801 {\cf21 #endif}\par
802     \}\par
803 \par
804     {\cf19 if} (expected == actual)\par
805     \{\par
806         {\cf19 return}; {\cf20 /* Both are NULL or same pointer */}\par
807     \}\par
808 \par
809     {\cf19 if} (UnityIsOneArrayNull(expected, actual, lineNumber, msg))\par
810     \{\par
811         UNITY_FAIL_AND_BAIL;\par
812     \}\par
813 \par
814     {\cf19 while} ((elements > 0) && (elements--))\par
815     \{\par
816         UNITY_INT expect_val;\par
817         UNITY_INT actual_val;\par
818 \par
819         {\cf19 switch} (length)\par
820         \{\par
821             {\cf19 case} 1:\par
822                 expect_val = *(UNITY_PTR_ATTRIBUTE {\cf17 const} UNITY_INT8*)expected;\par
823                 actual_val = *(UNITY_PTR_ATTRIBUTE {\cf17 const} UNITY_INT8*)actual;\par
824                 {\cf19 if} (style & (UNITY_DISPLAY_RANGE_UINT | UNITY_DISPLAY_RANGE_HEX))\par
825                 \{\par
826                     expect_val &= 0x000000FF;\par
827                     actual_val &= 0x000000FF;\par
828                 \}\par
829                 increment  = {\cf17 sizeof}(UNITY_INT8);\par
830                 {\cf19 break};\par
831 \par
832             {\cf19 case} 2:\par
833                 expect_val = *(UNITY_PTR_ATTRIBUTE {\cf17 const} UNITY_INT16*)expected;\par
834                 actual_val = *(UNITY_PTR_ATTRIBUTE {\cf17 const} UNITY_INT16*)actual;\par
835                 {\cf19 if} (style & (UNITY_DISPLAY_RANGE_UINT | UNITY_DISPLAY_RANGE_HEX))\par
836                 \{\par
837                     expect_val &= 0x0000FFFF;\par
838                     actual_val &= 0x0000FFFF;\par
839                 \}\par
840                 increment  = {\cf17 sizeof}(UNITY_INT16);\par
841                 {\cf19 break};\par
842 \par
843 {\cf21 #ifdef UNITY_SUPPORT_64}\par
844             {\cf19 case} 8:\par
845                 expect_val = *(UNITY_PTR_ATTRIBUTE {\cf17 const} UNITY_INT64*)expected;\par
846                 actual_val = *(UNITY_PTR_ATTRIBUTE {\cf17 const} UNITY_INT64*)actual;\par
847                 increment  = {\cf17 sizeof}(UNITY_INT64);\par
848                 {\cf19 break};\par
849 {\cf21 #endif}\par
850 \par
851             {\cf19 default}: {\cf20 /* default is length 4 bytes */}\par
852             {\cf19 case} 4:\par
853                 expect_val = *(UNITY_PTR_ATTRIBUTE {\cf17 const} UNITY_INT32*)expected;\par
854                 actual_val = *(UNITY_PTR_ATTRIBUTE {\cf17 const} UNITY_INT32*)actual;\par
855 {\cf21 #ifdef UNITY_SUPPORT_64}\par
856                 {\cf19 if} (style & (UNITY_DISPLAY_RANGE_UINT | UNITY_DISPLAY_RANGE_HEX))\par
857                 \{\par
858                     expect_val &= 0x00000000FFFFFFFF;\par
859                     actual_val &= 0x00000000FFFFFFFF;\par
860                 \}\par
861 {\cf21 #endif}\par
862                 increment  = {\cf17 sizeof}(UNITY_INT32);\par
863                 length = 4;\par
864                 {\cf19 break};\par
865         \}\par
866 \par
867         {\cf19 if} (expect_val != actual_val)\par
868         \{\par
869             {\cf19 if} ((style & UNITY_DISPLAY_RANGE_UINT) && (length < (UNITY_INT_WIDTH / 8)))\par
870             \{   {\cf20 /* For UINT, remove sign extension (padding 1's) from signed type casts above */}\par
871                 UNITY_INT mask = 1;\par
872                 mask = (mask << 8 * length) - 1;\par
873                 expect_val &= mask;\par
874                 actual_val &= mask;\par
875             \}\par
876             UnityTestResultsFailBegin(lineNumber);\par
877             UnityPrint(UnityStrElement);\par
878             UnityPrintNumberUnsigned(num_elements - elements - 1);\par
879             UnityPrint(UnityStrExpected);\par
880             UnityPrintNumberByStyle(expect_val, style);\par
881             UnityPrint(UnityStrWas);\par
882             UnityPrintNumberByStyle(actual_val, style);\par
883             UnityAddMsgIfSpecified(msg);\par
884             UNITY_FAIL_AND_BAIL;\par
885         \}\par
886         {\cf20 /* Walk through array by incrementing the pointers */}\par
887         {\cf19 if} (flags == UNITY_ARRAY_TO_ARRAY)\par
888         \{\par
889             expected = (UNITY_INTERNAL_PTR)(({\cf17 const} {\cf18 char}*)expected + increment);\par
890         \}\par
891         actual = (UNITY_INTERNAL_PTR)(({\cf17 const} {\cf18 char}*)actual + increment);\par
892     \}\par
893 \}\par
}
}
{\xe \v UnityAssertEqualMemory\:unity_internals.h}
{\xe \v unity_internals.h\:UnityAssertEqualMemory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void UnityAssertEqualMemory ({\b UNITY_INTERNAL_PTR}  {\i expected}, {\b UNITY_INTERNAL_PTR}  {\i actual}, const {\b UNITY_UINT32}  {\i length}, const {\b UNITY_UINT32}  {\i num_elements}, const char *  {\i msg}, const {\b UNITY_LINE_TYPE}  {\i lineNumber}, const {\b UNITY_FLAGS_T}  {\i flags})}}
\par
{\bkmkstart AAAAAAABLR}
{\bkmkend AAAAAAABLR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1753 of file unity.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1760 \{\par
1761     UNITY_PTR_ATTRIBUTE {\cf17 const} {\cf18 unsigned} {\cf18 char}* ptr_exp = (UNITY_PTR_ATTRIBUTE {\cf17 const} {\cf18 unsigned} {\cf18 char}*)expected;\par
1762     UNITY_PTR_ATTRIBUTE {\cf17 const} {\cf18 unsigned} {\cf18 char}* ptr_act = (UNITY_PTR_ATTRIBUTE {\cf17 const} {\cf18 unsigned} {\cf18 char}*)actual;\par
1763     UNITY_UINT32 elements = num_elements;\par
1764     UNITY_UINT32 bytes;\par
1765 \par
1766     RETURN_IF_FAIL_OR_IGNORE;\par
1767 \par
1768     {\cf19 if} (elements == 0)\par
1769     \{\par
1770 {\cf21 #ifdef UNITY_COMPARE_PTRS_ON_ZERO_ARRAY}\par
1771         UNITY_TEST_ASSERT_EQUAL_PTR(expected, actual, lineNumber, msg);\par
1772 {\cf21 #else}\par
1773         UnityPrintPointlessAndBail();\par
1774 {\cf21 #endif}\par
1775     \}\par
1776     {\cf19 if} (length == 0)\par
1777     \{\par
1778         UnityPrintPointlessAndBail();\par
1779     \}\par
1780 \par
1781     {\cf19 if} (expected == actual)\par
1782     \{\par
1783         {\cf19 return}; {\cf20 /* Both are NULL or same pointer */}\par
1784     \}\par
1785 \par
1786     {\cf19 if} (UnityIsOneArrayNull(expected, actual, lineNumber, msg))\par
1787     \{\par
1788         UNITY_FAIL_AND_BAIL;\par
1789     \}\par
1790 \par
1791     {\cf19 while} (elements--)\par
1792     \{\par
1793         bytes = length;\par
1794         {\cf19 while} (bytes--)\par
1795         \{\par
1796             {\cf19 if} (*ptr_exp != *ptr_act)\par
1797             \{\par
1798                 UnityTestResultsFailBegin(lineNumber);\par
1799                 UnityPrint(UnityStrMemory);\par
1800                 {\cf19 if} (num_elements > 1)\par
1801                 \{\par
1802                     UnityPrint(UnityStrElement);\par
1803                     UnityPrintNumberUnsigned(num_elements - elements - 1);\par
1804                 \}\par
1805                 UnityPrint(UnityStrByte);\par
1806                 UnityPrintNumberUnsigned(length - bytes - 1);\par
1807                 UnityPrint(UnityStrExpected);\par
1808                 UnityPrintNumberByStyle(*ptr_exp, UNITY_DISPLAY_STYLE_HEX8);\par
1809                 UnityPrint(UnityStrWas);\par
1810                 UnityPrintNumberByStyle(*ptr_act, UNITY_DISPLAY_STYLE_HEX8);\par
1811                 UnityAddMsgIfSpecified(msg);\par
1812                 UNITY_FAIL_AND_BAIL;\par
1813             \}\par
1814             ptr_exp++;\par
1815             ptr_act++;\par
1816         \}\par
1817         {\cf19 if} (flags == UNITY_ARRAY_TO_VAL)\par
1818         \{\par
1819             ptr_exp = (UNITY_PTR_ATTRIBUTE {\cf17 const} {\cf18 unsigned} {\cf18 char}*)expected;\par
1820         \}\par
1821     \}\par
1822 \}\par
}
}
{\xe \v UnityAssertEqualNumber\:unity_internals.h}
{\xe \v unity_internals.h\:UnityAssertEqualNumber}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void UnityAssertEqualNumber (const {\b UNITY_INT}  {\i expected}, const {\b UNITY_INT}  {\i actual}, const char *  {\i msg}, const {\b UNITY_LINE_TYPE}  {\i lineNumber}, const {\b UNITY_DISPLAY_STYLE_T}  {\i style})}}
\par
{\bkmkstart AAAAAAABLS}
{\bkmkend AAAAAAABLS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 712 of file unity.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 717 \{\par
718     RETURN_IF_FAIL_OR_IGNORE;\par
719 \par
720     {\cf19 if} (expected != actual)\par
721     \{\par
722         UnityTestResultsFailBegin(lineNumber);\par
723         UnityPrint(UnityStrExpected);\par
724         UnityPrintNumberByStyle(expected, style);\par
725         UnityPrint(UnityStrWas);\par
726         UnityPrintNumberByStyle(actual, style);\par
727         UnityAddMsgIfSpecified(msg);\par
728         UNITY_FAIL_AND_BAIL;\par
729     \}\par
730 \}\par
}
}
{\xe \v UnityAssertEqualString\:unity_internals.h}
{\xe \v unity_internals.h\:UnityAssertEqualString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void UnityAssertEqualString (const char *  {\i expected}, const char *  {\i actual}, const char *  {\i msg}, const {\b UNITY_LINE_TYPE}  {\i lineNumber})}}
\par
{\bkmkstart AAAAAAABLT}
{\bkmkend AAAAAAABLT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1591 of file unity.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1595 \{\par
1596     UNITY_UINT32 i;\par
1597 \par
1598     RETURN_IF_FAIL_OR_IGNORE;\par
1599 \par
1600     {\cf20 /* if both pointers not null compare the strings */}\par
1601     {\cf19 if} (expected && actual)\par
1602     \{\par
1603         {\cf19 for} (i = 0; expected[i] || actual[i]; i++)\par
1604         \{\par
1605             {\cf19 if} (expected[i] != actual[i])\par
1606             \{\par
1607                 Unity.CurrentTestFailed = 1;\par
1608                 {\cf19 break};\par
1609             \}\par
1610         \}\par
1611     \}\par
1612     {\cf19 else}\par
1613     \{ {\cf20 /* fail if either null but not if both */}\par
1614         {\cf19 if} (expected || actual)\par
1615         \{\par
1616             Unity.CurrentTestFailed = 1;\par
1617         \}\par
1618     \}\par
1619 \par
1620     {\cf19 if} (Unity.CurrentTestFailed)\par
1621     \{\par
1622         UnityTestResultsFailBegin(lineNumber);\par
1623         UnityPrintExpectedAndActualStrings(expected, actual);\par
1624         UnityAddMsgIfSpecified(msg);\par
1625         UNITY_FAIL_AND_BAIL;\par
1626     \}\par
1627 \}\par
}
}
{\xe \v UnityAssertEqualStringArray\:unity_internals.h}
{\xe \v unity_internals.h\:UnityAssertEqualStringArray}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void UnityAssertEqualStringArray ({\b UNITY_INTERNAL_PTR}  {\i expected}, const char **  {\i actual}, const {\b UNITY_UINT32}  {\i num_elements}, const char *  {\i msg}, const {\b UNITY_LINE_TYPE}  {\i lineNumber}, const {\b UNITY_FLAGS_T}  {\i flags})}}
\par
{\bkmkstart AAAAAAABLU}
{\bkmkend AAAAAAABLU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1670 of file unity.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1676 \{\par
1677     UNITY_UINT32 i = 0;\par
1678     UNITY_UINT32 j = 0;\par
1679     {\cf17 const} {\cf18 char}* expd = NULL;\par
1680     {\cf17 const} {\cf18 char}* act = NULL;\par
1681 \par
1682     RETURN_IF_FAIL_OR_IGNORE;\par
1683 \par
1684     {\cf20 /* if no elements, it's an error */}\par
1685     {\cf19 if} (num_elements == 0)\par
1686     \{\par
1687 {\cf21 #ifdef UNITY_COMPARE_PTRS_ON_ZERO_ARRAY}\par
1688         UNITY_TEST_ASSERT_EQUAL_PTR(expected, actual, lineNumber, msg);\par
1689 {\cf21 #else}\par
1690         UnityPrintPointlessAndBail();\par
1691 {\cf21 #endif}\par
1692     \}\par
1693 \par
1694     {\cf19 if} (({\cf17 const} {\cf18 void}*)expected == ({\cf17 const} {\cf18 void}*)actual)\par
1695     \{\par
1696         {\cf19 return}; {\cf20 /* Both are NULL or same pointer */}\par
1697     \}\par
1698 \par
1699     {\cf19 if} (UnityIsOneArrayNull((UNITY_INTERNAL_PTR)expected, (UNITY_INTERNAL_PTR)actual, lineNumber, msg))\par
1700     \{\par
1701         UNITY_FAIL_AND_BAIL;\par
1702     \}\par
1703 \par
1704     {\cf19 if} (flags != UNITY_ARRAY_TO_ARRAY)\par
1705     \{\par
1706         expd = ({\cf17 const} {\cf18 char}*)expected;\par
1707     \}\par
1708 \par
1709     {\cf19 do}\par
1710     \{\par
1711         act = actual[j];\par
1712         {\cf19 if} (flags == UNITY_ARRAY_TO_ARRAY)\par
1713         \{\par
1714             expd = (({\cf17 const} {\cf18 char}* {\cf17 const}*)expected)[j];\par
1715         \}\par
1716 \par
1717         {\cf20 /* if both pointers not null compare the strings */}\par
1718         {\cf19 if} (expd && act)\par
1719         \{\par
1720             {\cf19 for} (i = 0; expd[i] || act[i]; i++)\par
1721             \{\par
1722                 {\cf19 if} (expd[i] != act[i])\par
1723                 \{\par
1724                     Unity.CurrentTestFailed = 1;\par
1725                     {\cf19 break};\par
1726                 \}\par
1727             \}\par
1728         \}\par
1729         {\cf19 else}\par
1730         \{ {\cf20 /* handle case of one pointers being null (if both null, test should pass) */}\par
1731             {\cf19 if} (expd != act)\par
1732             \{\par
1733                 Unity.CurrentTestFailed = 1;\par
1734             \}\par
1735         \}\par
1736 \par
1737         {\cf19 if} (Unity.CurrentTestFailed)\par
1738         \{\par
1739             UnityTestResultsFailBegin(lineNumber);\par
1740             {\cf19 if} (num_elements > 1)\par
1741             \{\par
1742                 UnityPrint(UnityStrElement);\par
1743                 UnityPrintNumberUnsigned(j);\par
1744             \}\par
1745             UnityPrintExpectedAndActualStrings(expd, act);\par
1746             UnityAddMsgIfSpecified(msg);\par
1747             UNITY_FAIL_AND_BAIL;\par
1748         \}\par
1749     \} {\cf19 while} (++j < num_elements);\par
1750 \}\par
}
}
{\xe \v UnityAssertEqualStringLen\:unity_internals.h}
{\xe \v unity_internals.h\:UnityAssertEqualStringLen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void UnityAssertEqualStringLen (const char *  {\i expected}, const char *  {\i actual}, const {\b UNITY_UINT32}  {\i length}, const char *  {\i msg}, const {\b UNITY_LINE_TYPE}  {\i lineNumber})}}
\par
{\bkmkstart AAAAAAABLV}
{\bkmkend AAAAAAABLV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1630 of file unity.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1635 \{\par
1636     UNITY_UINT32 i;\par
1637 \par
1638     RETURN_IF_FAIL_OR_IGNORE;\par
1639 \par
1640     {\cf20 /* if both pointers not null compare the strings */}\par
1641     {\cf19 if} (expected && actual)\par
1642     \{\par
1643         {\cf19 for} (i = 0; (i < length) && (expected[i] || actual[i]); i++)\par
1644         \{\par
1645             {\cf19 if} (expected[i] != actual[i])\par
1646             \{\par
1647                 Unity.CurrentTestFailed = 1;\par
1648                 {\cf19 break};\par
1649             \}\par
1650         \}\par
1651     \}\par
1652     {\cf19 else}\par
1653     \{ {\cf20 /* fail if either null but not if both */}\par
1654         {\cf19 if} (expected || actual)\par
1655         \{\par
1656             Unity.CurrentTestFailed = 1;\par
1657         \}\par
1658     \}\par
1659 \par
1660     {\cf19 if} (Unity.CurrentTestFailed)\par
1661     \{\par
1662         UnityTestResultsFailBegin(lineNumber);\par
1663         UnityPrintExpectedAndActualStringsLen(expected, actual, length);\par
1664         UnityAddMsgIfSpecified(msg);\par
1665         UNITY_FAIL_AND_BAIL;\par
1666     \}\par
1667 \}\par
}
}
{\xe \v UnityAssertFloatsNotWithin\:unity_internals.h}
{\xe \v unity_internals.h\:UnityAssertFloatsNotWithin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void UnityAssertFloatsNotWithin (const {\b UNITY_FLOAT}  {\i delta}, const {\b UNITY_FLOAT}  {\i expected}, const {\b UNITY_FLOAT}  {\i actual}, const char *  {\i msg}, const {\b UNITY_LINE_TYPE}  {\i lineNumber})}}
\par
{\bkmkstart AAAAAAABLW}
{\bkmkend AAAAAAABLW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1032 of file unity.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1037 \{\par
1038     RETURN_IF_FAIL_OR_IGNORE;\par
1039 \par
1040     {\cf19 if} (UnityFloatsWithin(delta, expected, actual))\par
1041     \{\par
1042         UnityTestResultsFailBegin(lineNumber);\par
1043         UnityPrint(UnityStrExpected);\par
1044         UnityPrintFloat((UNITY_DOUBLE)expected);\par
1045         UnityPrint(UnityStrNotEqual);\par
1046         UnityPrintFloat((UNITY_DOUBLE)actual);\par
1047         UnityAddMsgIfSpecified(msg);\par
1048         UNITY_FAIL_AND_BAIL;\par
1049     \}\par
1050 \}\par
}
}
{\xe \v UnityAssertFloatSpecial\:unity_internals.h}
{\xe \v unity_internals.h\:UnityAssertFloatSpecial}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void UnityAssertFloatSpecial (const {\b UNITY_FLOAT}  {\i actual}, const char *  {\i msg}, const {\b UNITY_LINE_TYPE}  {\i lineNumber}, const {\b UNITY_FLOAT_TRAIT_T}  {\i style})}}
\par
{\bkmkstart AAAAAAABLX}
{\bkmkend AAAAAAABLX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1086 of file unity.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1090 \{\par
1091     {\cf17 const} {\cf18 char}* trait_names[] = \{UnityStrInf, UnityStrNegInf, UnityStrNaN, UnityStrDet\};\par
1092     UNITY_INT should_be_trait = ((UNITY_INT)style & 1);\par
1093     UNITY_INT is_trait        = !should_be_trait;\par
1094     UNITY_INT trait_index     = (UNITY_INT)(style >> 1);\par
1095 \par
1096     RETURN_IF_FAIL_OR_IGNORE;\par
1097 \par
1098     {\cf19 switch} (style)\par
1099     \{\par
1100         {\cf19 case} UNITY_FLOAT_IS_INF:\par
1101         {\cf19 case} UNITY_FLOAT_IS_NOT_INF:\par
1102             is_trait = UNITY_IS_INF(actual) && (actual > 0);\par
1103             {\cf19 break};\par
1104         {\cf19 case} UNITY_FLOAT_IS_NEG_INF:\par
1105         {\cf19 case} UNITY_FLOAT_IS_NOT_NEG_INF:\par
1106             is_trait = UNITY_IS_INF(actual) && (actual < 0);\par
1107             {\cf19 break};\par
1108 \par
1109         {\cf19 case} UNITY_FLOAT_IS_NAN:\par
1110         {\cf19 case} UNITY_FLOAT_IS_NOT_NAN:\par
1111             is_trait = UNITY_IS_NAN(actual) ? 1 : 0;\par
1112             {\cf19 break};\par
1113 \par
1114         {\cf19 case} UNITY_FLOAT_IS_DET: {\cf20 /* A determinate number is non infinite and not NaN. */}\par
1115         {\cf19 case} UNITY_FLOAT_IS_NOT_DET:\par
1116             is_trait = !UNITY_IS_INF(actual) && !UNITY_IS_NAN(actual);\par
1117             {\cf19 break};\par
1118 \par
1119         {\cf19 case} UNITY_FLOAT_INVALID_TRAIT:  {\cf20 /* Supress warning */}\par
1120         {\cf19 default}: {\cf20 /* including UNITY_FLOAT_INVALID_TRAIT */}\par
1121             trait_index = 0;\par
1122             trait_names[0] = UnityStrInvalidFloatTrait;\par
1123             {\cf19 break};\par
1124     \}\par
1125 \par
1126     {\cf19 if} (is_trait != should_be_trait)\par
1127     \{\par
1128         UnityTestResultsFailBegin(lineNumber);\par
1129         UnityPrint(UnityStrExpected);\par
1130         {\cf19 if} (!should_be_trait)\par
1131         \{\par
1132             UnityPrint(UnityStrNot);\par
1133         \}\par
1134         UnityPrint(trait_names[trait_index]);\par
1135         UnityPrint(UnityStrWas);\par
1136 {\cf21 #ifndef UNITY_EXCLUDE_FLOAT_PRINT}\par
1137         UnityPrintFloat((UNITY_DOUBLE)actual);\par
1138 {\cf21 #else}\par
1139         {\cf19 if} (should_be_trait)\par
1140         \{\par
1141             UnityPrint(UnityStrNot);\par
1142         \}\par
1143         UnityPrint(trait_names[trait_index]);\par
1144 {\cf21 #endif}\par
1145         UnityAddMsgIfSpecified(msg);\par
1146         UNITY_FAIL_AND_BAIL;\par
1147     \}\par
1148 \}\par
}
}
{\xe \v UnityAssertFloatsWithin\:unity_internals.h}
{\xe \v unity_internals.h\:UnityAssertFloatsWithin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void UnityAssertFloatsWithin (const {\b UNITY_FLOAT}  {\i delta}, const {\b UNITY_FLOAT}  {\i expected}, const {\b UNITY_FLOAT}  {\i actual}, const char *  {\i msg}, const {\b UNITY_LINE_TYPE}  {\i lineNumber})}}
\par
{\bkmkstart AAAAAAABLY}
{\bkmkend AAAAAAABLY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1013 of file unity.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1018 \{\par
1019     RETURN_IF_FAIL_OR_IGNORE;\par
1020 \par
1021 \par
1022     {\cf19 if} (!UnityFloatsWithin(delta, expected, actual))\par
1023     \{\par
1024         UnityTestResultsFailBegin(lineNumber);\par
1025         UNITY_PRINT_EXPECTED_AND_ACTUAL_FLOAT((UNITY_DOUBLE)expected, (UNITY_DOUBLE)actual);\par
1026         UnityAddMsgIfSpecified(msg);\par
1027         UNITY_FAIL_AND_BAIL;\par
1028     \}\par
1029 \}\par
}
}
{\xe \v UnityAssertGreaterOrLessFloat\:unity_internals.h}
{\xe \v unity_internals.h\:UnityAssertGreaterOrLessFloat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void UnityAssertGreaterOrLessFloat (const {\b UNITY_FLOAT}  {\i threshold}, const {\b UNITY_FLOAT}  {\i actual}, const {\b UNITY_COMPARISON_T}  {\i compare}, const char *  {\i msg}, const {\b UNITY_LINE_TYPE}  {\i linenumber})}}
\par
{\bkmkstart AAAAAAABLZ}
{\bkmkend AAAAAAABLZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1053 of file unity.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1058 \{\par
1059     {\cf18 int} failed;\par
1060 \par
1061     RETURN_IF_FAIL_OR_IGNORE;\par
1062 \par
1063     failed = 0;\par
1064 \par
1065     {\cf20 /* Checking for "not success" rather than failure to get the right result for NaN */}\par
1066     {\cf19 if} (!(actual < threshold) && (compare & UNITY_SMALLER_THAN)) \{ failed = 1; \}\par
1067     {\cf19 if} (!(actual > threshold) && (compare & UNITY_GREATER_THAN)) \{ failed = 1; \}\par
1068 \par
1069     {\cf19 if} ((compare & UNITY_EQUAL_TO) && UnityFloatsWithin(threshold * UNITY_FLOAT_PRECISION, threshold, actual)) \{ failed = 0; \}\par
1070 \par
1071     {\cf19 if} (failed)\par
1072     \{\par
1073         UnityTestResultsFailBegin(lineNumber);\par
1074         UnityPrint(UnityStrExpected);\par
1075         UnityPrintFloat(actual);\par
1076         {\cf19 if} (compare & UNITY_GREATER_THAN) \{ UnityPrint(UnityStrGt); \}\par
1077         {\cf19 if} (compare & UNITY_SMALLER_THAN) \{ UnityPrint(UnityStrLt); \}\par
1078         {\cf19 if} (compare & UNITY_EQUAL_TO)     \{ UnityPrint(UnityStrOrEqual);  \}\par
1079         UnityPrintFloat(threshold);\par
1080         UnityAddMsgIfSpecified(msg);\par
1081         UNITY_FAIL_AND_BAIL;\par
1082     \}\par
1083 \}\par
}
}
{\xe \v UnityAssertGreaterOrLessOrEqualNumber\:unity_internals.h}
{\xe \v unity_internals.h\:UnityAssertGreaterOrLessOrEqualNumber}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void UnityAssertGreaterOrLessOrEqualNumber (const {\b UNITY_INT}  {\i threshold}, const {\b UNITY_INT}  {\i actual}, const {\b UNITY_COMPARISON_T}  {\i compare}, const char *  {\i msg}, const {\b UNITY_LINE_TYPE}  {\i lineNumber}, const {\b UNITY_DISPLAY_STYLE_T}  {\i style})}}
\par
{\bkmkstart AAAAAAABMA}
{\bkmkend AAAAAAABMA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 733 of file unity.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 739 \{\par
740     {\cf18 int} failed = 0;\par
741     RETURN_IF_FAIL_OR_IGNORE;\par
742 \par
743     {\cf19 if} ((threshold == actual) && (compare & UNITY_EQUAL_TO)) \{ {\cf19 return}; \}\par
744     {\cf19 if} ((threshold == actual))                               \{ failed = 1; \}\par
745 \par
746     {\cf19 if} ((style & UNITY_DISPLAY_RANGE_INT) == UNITY_DISPLAY_RANGE_INT)\par
747     \{\par
748         {\cf19 if} ((actual > threshold) && (compare & UNITY_SMALLER_THAN)) \{ failed = 1; \}\par
749         {\cf19 if} ((actual < threshold) && (compare & UNITY_GREATER_THAN)) \{ failed = 1; \}\par
750     \}\par
751     {\cf19 else} {\cf20 /* UINT or HEX */}\par
752     \{\par
753         {\cf19 if} (((UNITY_UINT)actual > (UNITY_UINT)threshold) && (compare & UNITY_SMALLER_THAN)) \{ failed = 1; \}\par
754         {\cf19 if} (((UNITY_UINT)actual < (UNITY_UINT)threshold) && (compare & UNITY_GREATER_THAN)) \{ failed = 1; \}\par
755     \}\par
756 \par
757     {\cf19 if} (failed)\par
758     \{\par
759         UnityTestResultsFailBegin(lineNumber);\par
760         UnityPrint(UnityStrExpected);\par
761         UnityPrintNumberByStyle(actual, style);\par
762         {\cf19 if} (compare & UNITY_GREATER_THAN) \{ UnityPrint(UnityStrGt);       \}\par
763         {\cf19 if} (compare & UNITY_SMALLER_THAN) \{ UnityPrint(UnityStrLt);       \}\par
764         {\cf19 if} (compare & UNITY_EQUAL_TO)     \{ UnityPrint(UnityStrOrEqual);  \}\par
765         {\cf19 if} (compare == UNITY_NOT_EQUAL)   \{ UnityPrint(UnityStrNotEqual); \}\par
766         UnityPrintNumberByStyle(threshold, style);\par
767         UnityAddMsgIfSpecified(msg);\par
768         UNITY_FAIL_AND_BAIL;\par
769     \}\par
770 \}\par
}
}
{\xe \v UnityAssertNumbersArrayWithin\:unity_internals.h}
{\xe \v unity_internals.h\:UnityAssertNumbersArrayWithin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void UnityAssertNumbersArrayWithin (const {\b UNITY_UINT}  {\i delta}, {\b UNITY_INTERNAL_PTR}  {\i expected}, {\b UNITY_INTERNAL_PTR}  {\i actual}, const {\b UNITY_UINT32}  {\i num_elements}, const char *  {\i msg}, const {\b UNITY_LINE_TYPE}  {\i lineNumber}, const {\b UNITY_DISPLAY_STYLE_T}  {\i style}, const {\b UNITY_FLAGS_T}  {\i flags})}}
\par
{\bkmkstart AAAAAAABMB}
{\bkmkend AAAAAAABMB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1427 of file unity.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1435 \{\par
1436     UNITY_UINT32 elements = num_elements;\par
1437     {\cf18 unsigned} {\cf18 int} length   = style & 0xF;\par
1438     {\cf18 unsigned} {\cf18 int} increment = 0;\par
1439 \par
1440     RETURN_IF_FAIL_OR_IGNORE;\par
1441 \par
1442     {\cf19 if} (num_elements == 0)\par
1443     \{\par
1444 {\cf21 #ifdef UNITY_COMPARE_PTRS_ON_ZERO_ARRAY}\par
1445         UNITY_TEST_ASSERT_EQUAL_PTR(expected, actual, lineNumber, msg);\par
1446 {\cf21 #else}\par
1447         UnityPrintPointlessAndBail();\par
1448 {\cf21 #endif}\par
1449     \}\par
1450 \par
1451     {\cf19 if} (expected == actual)\par
1452     \{\par
1453         {\cf19 return}; {\cf20 /* Both are NULL or same pointer */}\par
1454     \}\par
1455 \par
1456     {\cf19 if} (UnityIsOneArrayNull(expected, actual, lineNumber, msg))\par
1457     \{\par
1458         UNITY_FAIL_AND_BAIL;\par
1459     \}\par
1460 \par
1461     {\cf19 while} ((elements > 0) && (elements--))\par
1462     \{\par
1463         UNITY_INT expect_val;\par
1464         UNITY_INT actual_val;\par
1465 \par
1466         {\cf19 switch} (length)\par
1467         \{\par
1468             {\cf19 case} 1:\par
1469                 {\cf20 /* fixing problems with signed overflow on unsigned numbers */}\par
1470                 {\cf19 if} ((style & UNITY_DISPLAY_RANGE_INT) == UNITY_DISPLAY_RANGE_INT)\par
1471                 \{\par
1472                     expect_val = *(UNITY_PTR_ATTRIBUTE {\cf17 const} UNITY_INT8*)expected;\par
1473                     actual_val = *(UNITY_PTR_ATTRIBUTE {\cf17 const} UNITY_INT8*)actual;\par
1474                     increment  = {\cf17 sizeof}(UNITY_INT8);\par
1475                 \}\par
1476                 {\cf19 else}\par
1477                 \{\par
1478                     expect_val = (UNITY_INT)*(UNITY_PTR_ATTRIBUTE {\cf17 const} UNITY_UINT8*)expected;\par
1479                     actual_val = (UNITY_INT)*(UNITY_PTR_ATTRIBUTE {\cf17 const} UNITY_UINT8*)actual;\par
1480                     increment  = {\cf17 sizeof}(UNITY_UINT8);\par
1481                 \}\par
1482                 {\cf19 break};\par
1483 \par
1484             {\cf19 case} 2:\par
1485                 {\cf20 /* fixing problems with signed overflow on unsigned numbers */}\par
1486                 {\cf19 if} ((style & UNITY_DISPLAY_RANGE_INT) == UNITY_DISPLAY_RANGE_INT)\par
1487                 \{\par
1488                     expect_val = *(UNITY_PTR_ATTRIBUTE {\cf17 const} UNITY_INT16*)expected;\par
1489                     actual_val = *(UNITY_PTR_ATTRIBUTE {\cf17 const} UNITY_INT16*)actual;\par
1490                     increment  = {\cf17 sizeof}(UNITY_INT16);\par
1491                 \}\par
1492                 {\cf19 else}\par
1493                 \{\par
1494                     expect_val = (UNITY_INT)*(UNITY_PTR_ATTRIBUTE {\cf17 const} UNITY_UINT16*)expected;\par
1495                     actual_val = (UNITY_INT)*(UNITY_PTR_ATTRIBUTE {\cf17 const} UNITY_UINT16*)actual;\par
1496                     increment  = {\cf17 sizeof}(UNITY_UINT16);\par
1497                 \}\par
1498                 {\cf19 break};\par
1499 \par
1500 {\cf21 #ifdef UNITY_SUPPORT_64}\par
1501             {\cf19 case} 8:\par
1502                 {\cf20 /* fixing problems with signed overflow on unsigned numbers */}\par
1503                 {\cf19 if} ((style & UNITY_DISPLAY_RANGE_INT) == UNITY_DISPLAY_RANGE_INT)\par
1504                 \{\par
1505                     expect_val = *(UNITY_PTR_ATTRIBUTE {\cf17 const} UNITY_INT64*)expected;\par
1506                     actual_val = *(UNITY_PTR_ATTRIBUTE {\cf17 const} UNITY_INT64*)actual;\par
1507                     increment  = {\cf17 sizeof}(UNITY_INT64);\par
1508                 \}\par
1509                 {\cf19 else}\par
1510                 \{\par
1511                     expect_val = (UNITY_INT)*(UNITY_PTR_ATTRIBUTE {\cf17 const} UNITY_UINT64*)expected;\par
1512                     actual_val = (UNITY_INT)*(UNITY_PTR_ATTRIBUTE {\cf17 const} UNITY_UINT64*)actual;\par
1513                     increment  = {\cf17 sizeof}(UNITY_UINT64);\par
1514                 \}\par
1515                 {\cf19 break};\par
1516 {\cf21 #endif}\par
1517 \par
1518             {\cf19 default}: {\cf20 /* default is length 4 bytes */}\par
1519             {\cf19 case} 4:\par
1520                 {\cf20 /* fixing problems with signed overflow on unsigned numbers */}\par
1521                 {\cf19 if} ((style & UNITY_DISPLAY_RANGE_INT) == UNITY_DISPLAY_RANGE_INT)\par
1522                 \{\par
1523                     expect_val = *(UNITY_PTR_ATTRIBUTE {\cf17 const} UNITY_INT32*)expected;\par
1524                     actual_val = *(UNITY_PTR_ATTRIBUTE {\cf17 const} UNITY_INT32*)actual;\par
1525                     increment  = {\cf17 sizeof}(UNITY_INT32);\par
1526                 \}\par
1527                 {\cf19 else}\par
1528                 \{\par
1529                     expect_val = (UNITY_INT)*(UNITY_PTR_ATTRIBUTE {\cf17 const} UNITY_UINT32*)expected;\par
1530                     actual_val = (UNITY_INT)*(UNITY_PTR_ATTRIBUTE {\cf17 const} UNITY_UINT32*)actual;\par
1531                     increment  = {\cf17 sizeof}(UNITY_UINT32);\par
1532                 \}\par
1533                 length = 4;\par
1534                 {\cf19 break};\par
1535         \}\par
1536 \par
1537         {\cf19 if} ((style & UNITY_DISPLAY_RANGE_INT) == UNITY_DISPLAY_RANGE_INT)\par
1538         \{\par
1539             {\cf19 if} (actual_val > expect_val)\par
1540             \{\par
1541                 Unity.CurrentTestFailed = (((UNITY_UINT)actual_val - (UNITY_UINT)expect_val) > delta);\par
1542             \}\par
1543             {\cf19 else}\par
1544             \{\par
1545                 Unity.CurrentTestFailed = (((UNITY_UINT)expect_val - (UNITY_UINT)actual_val) > delta);\par
1546             \}\par
1547         \}\par
1548         {\cf19 else}\par
1549         \{\par
1550             {\cf19 if} ((UNITY_UINT)actual_val > (UNITY_UINT)expect_val)\par
1551             \{\par
1552                 Unity.CurrentTestFailed = (((UNITY_UINT)actual_val - (UNITY_UINT)expect_val) > delta);\par
1553             \}\par
1554             {\cf19 else}\par
1555             \{\par
1556                 Unity.CurrentTestFailed = (((UNITY_UINT)expect_val - (UNITY_UINT)actual_val) > delta);\par
1557             \}\par
1558         \}\par
1559 \par
1560         {\cf19 if} (Unity.CurrentTestFailed)\par
1561         \{\par
1562             {\cf19 if} ((style & UNITY_DISPLAY_RANGE_UINT) && (length < (UNITY_INT_WIDTH / 8)))\par
1563             \{   {\cf20 /* For UINT, remove sign extension (padding 1's) from signed type casts above */}\par
1564                 UNITY_INT mask = 1;\par
1565                 mask = (mask << 8 * length) - 1;\par
1566                 expect_val &= mask;\par
1567                 actual_val &= mask;\par
1568             \}\par
1569             UnityTestResultsFailBegin(lineNumber);\par
1570             UnityPrint(UnityStrDelta);\par
1571             UnityPrintNumberByStyle((UNITY_INT)delta, style);\par
1572             UnityPrint(UnityStrElement);\par
1573             UnityPrintNumberUnsigned(num_elements - elements - 1);\par
1574             UnityPrint(UnityStrExpected);\par
1575             UnityPrintNumberByStyle(expect_val, style);\par
1576             UnityPrint(UnityStrWas);\par
1577             UnityPrintNumberByStyle(actual_val, style);\par
1578             UnityAddMsgIfSpecified(msg);\par
1579             UNITY_FAIL_AND_BAIL;\par
1580         \}\par
1581         {\cf20 /* Walk through array by incrementing the pointers */}\par
1582         {\cf19 if} (flags == UNITY_ARRAY_TO_ARRAY)\par
1583         \{\par
1584             expected = (UNITY_INTERNAL_PTR)(({\cf17 const} {\cf18 char}*)expected + increment);\par
1585         \}\par
1586         actual = (UNITY_INTERNAL_PTR)(({\cf17 const} {\cf18 char}*)actual + increment);\par
1587     \}\par
1588 \}\par
}
}
{\xe \v UnityAssertNumbersWithin\:unity_internals.h}
{\xe \v unity_internals.h\:UnityAssertNumbersWithin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void UnityAssertNumbersWithin (const {\b UNITY_UINT}  {\i delta}, const {\b UNITY_INT}  {\i expected}, const {\b UNITY_INT}  {\i actual}, const char *  {\i msg}, const {\b UNITY_LINE_TYPE}  {\i lineNumber}, const {\b UNITY_DISPLAY_STYLE_T}  {\i style})}}
\par
{\bkmkstart AAAAAAABMC}
{\bkmkend AAAAAAABMC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1380 of file unity.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1386 \{\par
1387     RETURN_IF_FAIL_OR_IGNORE;\par
1388 \par
1389     {\cf19 if} ((style & UNITY_DISPLAY_RANGE_INT) == UNITY_DISPLAY_RANGE_INT)\par
1390     \{\par
1391         {\cf19 if} (actual > expected)\par
1392         \{\par
1393             Unity.CurrentTestFailed = (((UNITY_UINT)actual - (UNITY_UINT)expected) > delta);\par
1394         \}\par
1395         {\cf19 else}\par
1396         \{\par
1397             Unity.CurrentTestFailed = (((UNITY_UINT)expected - (UNITY_UINT)actual) > delta);\par
1398         \}\par
1399     \}\par
1400     {\cf19 else}\par
1401     \{\par
1402         {\cf19 if} ((UNITY_UINT)actual > (UNITY_UINT)expected)\par
1403         \{\par
1404             Unity.CurrentTestFailed = (((UNITY_UINT)actual - (UNITY_UINT)expected) > delta);\par
1405         \}\par
1406         {\cf19 else}\par
1407         \{\par
1408             Unity.CurrentTestFailed = (((UNITY_UINT)expected - (UNITY_UINT)actual) > delta);\par
1409         \}\par
1410     \}\par
1411 \par
1412     {\cf19 if} (Unity.CurrentTestFailed)\par
1413     \{\par
1414         UnityTestResultsFailBegin(lineNumber);\par
1415         UnityPrint(UnityStrDelta);\par
1416         UnityPrintNumberByStyle((UNITY_INT)delta, style);\par
1417         UnityPrint(UnityStrExpected);\par
1418         UnityPrintNumberByStyle(expected, style);\par
1419         UnityPrint(UnityStrWas);\par
1420         UnityPrintNumberByStyle(actual, style);\par
1421         UnityAddMsgIfSpecified(msg);\par
1422         UNITY_FAIL_AND_BAIL;\par
1423     \}\par
1424 \}\par
}
}
{\xe \v UnityAssertWithinFloatArray\:unity_internals.h}
{\xe \v unity_internals.h\:UnityAssertWithinFloatArray}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void UnityAssertWithinFloatArray (const {\b UNITY_FLOAT}  {\i delta}, {\b UNITY_PTR_ATTRIBUTE} const {\b UNITY_FLOAT} *  {\i expected}, {\b UNITY_PTR_ATTRIBUTE} const {\b UNITY_FLOAT} *  {\i actual}, const {\b UNITY_UINT32}  {\i num_elements}, const char *  {\i msg}, const {\b UNITY_LINE_TYPE}  {\i lineNumber}, const {\b UNITY_FLAGS_T}  {\i flags})}}
\par
{\bkmkstart AAAAAAABMD}
{\bkmkend AAAAAAABMD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 933 of file unity.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 940 \{\par
941     UNITY_UINT32 elements = num_elements;\par
942     UNITY_PTR_ATTRIBUTE {\cf17 const} UNITY_FLOAT* ptr_expected = expected;\par
943     UNITY_PTR_ATTRIBUTE {\cf17 const} UNITY_FLOAT* ptr_actual = actual;\par
944     UNITY_FLOAT in_delta = delta;\par
945     UNITY_FLOAT current_element_delta = delta;\par
946 \par
947     RETURN_IF_FAIL_OR_IGNORE;\par
948 \par
949     {\cf19 if} (elements == 0)\par
950     \{\par
951 {\cf21 #ifdef UNITY_COMPARE_PTRS_ON_ZERO_ARRAY}\par
952         UNITY_TEST_ASSERT_EQUAL_PTR(expected, actual, lineNumber, msg);\par
953 {\cf21 #else}\par
954         UnityPrintPointlessAndBail();\par
955 {\cf21 #endif}\par
956     \}\par
957 \par
958     {\cf19 if} (UNITY_IS_INF(in_delta))\par
959     \{\par
960         {\cf19 return}; {\cf20 /* Arrays will be force equal with infinite delta */}\par
961     \}\par
962 \par
963     {\cf19 if} (UNITY_IS_NAN(in_delta))\par
964     \{\par
965         {\cf20 /* Delta must be correct number */}\par
966         UnityPrintPointlessAndBail();\par
967     \}\par
968 \par
969     {\cf19 if} (expected == actual)\par
970     \{\par
971         {\cf19 return}; {\cf20 /* Both are NULL or same pointer */}\par
972     \}\par
973 \par
974     {\cf19 if} (UnityIsOneArrayNull((UNITY_INTERNAL_PTR)expected, (UNITY_INTERNAL_PTR)actual, lineNumber, msg))\par
975     \{\par
976         UNITY_FAIL_AND_BAIL;\par
977     \}\par
978 \par
979     {\cf20 /* fix delta sign if need */}\par
980     {\cf19 if} (in_delta < 0)\par
981     \{\par
982         in_delta = -in_delta;\par
983     \}\par
984 \par
985     {\cf19 while} (elements--)\par
986     \{\par
987         current_element_delta = *ptr_expected * UNITY_FLOAT_PRECISION;\par
988 \par
989         {\cf19 if} (current_element_delta < 0)\par
990         \{\par
991             {\cf20 /* fix delta sign for correct calculations */}\par
992             current_element_delta = -current_element_delta;\par
993         \}\par
994 \par
995         {\cf19 if} (!UnityFloatsWithin(in_delta + current_element_delta, *ptr_expected, *ptr_actual))\par
996         \{\par
997             UnityTestResultsFailBegin(lineNumber);\par
998             UnityPrint(UnityStrElement);\par
999             UnityPrintNumberUnsigned(num_elements - elements - 1);\par
1000             UNITY_PRINT_EXPECTED_AND_ACTUAL_FLOAT((UNITY_DOUBLE)*ptr_expected, (UNITY_DOUBLE)*ptr_actual);\par
1001             UnityAddMsgIfSpecified(msg);\par
1002             UNITY_FAIL_AND_BAIL;\par
1003         \}\par
1004         {\cf19 if} (flags == UNITY_ARRAY_TO_ARRAY)\par
1005         \{\par
1006             ptr_expected++;\par
1007         \}\par
1008         ptr_actual++;\par
1009     \}\par
1010 \}\par
}
}
{\xe \v UnityBegin\:unity_internals.h}
{\xe \v unity_internals.h\:UnityBegin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void UnityBegin (const char *  {\i filename})}}
\par
{\bkmkstart AAAAAAABME}
{\bkmkend AAAAAAABME}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 2221 of file unity.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2222 \{\par
2223     Unity.TestFile = filename;\par
2224     Unity.CurrentTestName = NULL;\par
2225     Unity.CurrentTestLineNumber = 0;\par
2226     Unity.NumberOfTests = 0;\par
2227     Unity.TestFailures = 0;\par
2228     Unity.TestIgnores = 0;\par
2229     Unity.CurrentTestFailed = 0;\par
2230     Unity.CurrentTestIgnored = 0;\par
2231 \par
2232     UNITY_CLR_DETAILS();\par
2233     UNITY_OUTPUT_START();\par
2234 \}\par
}
}
{\xe \v UnityConcludeTest\:unity_internals.h}
{\xe \v unity_internals.h\:UnityConcludeTest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void UnityConcludeTest (void )}}
\par
{\bkmkstart AAAAAAABMF}
{\bkmkend AAAAAAABMF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 546 of file unity.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 547 \{\par
548     {\cf19 if} (Unity.CurrentTestIgnored)\par
549     \{\par
550         Unity.TestIgnores++;\par
551     \}\par
552     {\cf19 else} {\cf19 if} (!Unity.CurrentTestFailed)\par
553     \{\par
554         UnityTestResultsBegin(Unity.TestFile, Unity.CurrentTestLineNumber);\par
555         UnityPrint(UnityStrPass);\par
556     \}\par
557     {\cf19 else}\par
558     \{\par
559         Unity.TestFailures++;\par
560     \}\par
561 \par
562     Unity.CurrentTestFailed = 0;\par
563     Unity.CurrentTestIgnored = 0;\par
564     UNITY_PRINT_EXEC_TIME();\par
565     UNITY_PRINT_EOL();\par
566     UNITY_FLUSH_CALL();\par
567 \}\par
}
}
{\xe \v UnityDefaultTestRun\:unity_internals.h}
{\xe \v unity_internals.h\:UnityDefaultTestRun}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void UnityDefaultTestRun ({\b UnityTestFunction}  {\i Func}, const char *  {\i FuncName}, const int  {\i FuncLineNum})}}
\par
{\bkmkstart AAAAAAABMG}
{\bkmkend AAAAAAABMG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 2193 of file unity.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2194 \{\par
2195     Unity.CurrentTestName = FuncName;\par
2196     Unity.CurrentTestLineNumber = (UNITY_LINE_TYPE)FuncLineNum;\par
2197     Unity.NumberOfTests++;\par
2198     UNITY_CLR_DETAILS();\par
2199     UNITY_EXEC_TIME_START();\par
2200     {\cf19 if} (TEST_PROTECT())\par
2201     \{\par
2202         setUp();\par
2203         Func();\par
2204     \}\par
2205     {\cf19 if} (TEST_PROTECT())\par
2206     \{\par
2207         tearDown();\par
2208     \}\par
2209     UNITY_EXEC_TIME_STOP();\par
2210     UnityConcludeTest();\par
2211 \}\par
}
}
{\xe \v UnityEnd\:unity_internals.h}
{\xe \v unity_internals.h\:UnityEnd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int UnityEnd (void )}}
\par
{\bkmkstart AAAAAAABMH}
{\bkmkend AAAAAAABMH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 2237 of file unity.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2238 \{\par
2239     UNITY_PRINT_EOL();\par
2240     UnityPrint(UnityStrBreaker);\par
2241     UNITY_PRINT_EOL();\par
2242     UnityPrintNumber((UNITY_INT)(Unity.NumberOfTests));\par
2243     UnityPrint(UnityStrResultsTests);\par
2244     UnityPrintNumber((UNITY_INT)(Unity.TestFailures));\par
2245     UnityPrint(UnityStrResultsFailures);\par
2246     UnityPrintNumber((UNITY_INT)(Unity.TestIgnores));\par
2247     UnityPrint(UnityStrResultsIgnored);\par
2248     UNITY_PRINT_EOL();\par
2249     {\cf19 if} (Unity.TestFailures == 0U)\par
2250     \{\par
2251         UnityPrint(UnityStrOk);\par
2252     \}\par
2253     {\cf19 else}\par
2254     \{\par
2255         UnityPrint(UnityStrFail);\par
2256 {\cf21 #ifdef UNITY_DIFFERENTIATE_FINAL_FAIL}\par
2257         UNITY_OUTPUT_CHAR({\cf23 'E'}); UNITY_OUTPUT_CHAR({\cf23 'D'});\par
2258 {\cf21 #endif}\par
2259     \}\par
2260     UNITY_PRINT_EOL();\par
2261     UNITY_FLUSH_CALL();\par
2262     UNITY_OUTPUT_COMPLETE();\par
2263     {\cf19 return} ({\cf18 int})(Unity.TestFailures);\par
2264 \}\par
}
}
{\xe \v UnityFail\:unity_internals.h}
{\xe \v unity_internals.h\:UnityFail}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UNITY_NORETURN} void UnityFail (const char *  {\i message}, const {\b UNITY_LINE_TYPE}  {\i line})}}
\par
{\bkmkstart AAAAAAABMI}
{\bkmkend AAAAAAABMI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 2124 of file unity.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2125 \{\par
2126     RETURN_IF_FAIL_OR_IGNORE;\par
2127 \par
2128     UnityTestResultsBegin(Unity.TestFile, line);\par
2129     UnityPrint(UnityStrFail);\par
2130     {\cf19 if} (msg != NULL)\par
2131     \{\par
2132         UNITY_OUTPUT_CHAR({\cf23 ':'});\par
2133 \par
2134 {\cf21 #ifdef UNITY_PRINT_TEST_CONTEXT}\par
2135         UNITY_PRINT_TEST_CONTEXT();\par
2136 {\cf21 #endif}\par
2137 {\cf21 #ifndef UNITY_EXCLUDE_DETAILS}\par
2138         {\cf19 if} (Unity.CurrentDetail1)\par
2139         \{\par
2140             UnityPrint(UnityStrDetail1Name);\par
2141             UnityPrint(Unity.CurrentDetail1);\par
2142             {\cf19 if} (Unity.CurrentDetail2)\par
2143             \{\par
2144                 UnityPrint(UnityStrDetail2Name);\par
2145                 UnityPrint(Unity.CurrentDetail2);\par
2146             \}\par
2147             UnityPrint(UnityStrSpacer);\par
2148         \}\par
2149 {\cf21 #endif}\par
2150         {\cf19 if} (msg[0] != {\cf23 ' '})\par
2151         \{\par
2152             UNITY_OUTPUT_CHAR({\cf23 ' '});\par
2153         \}\par
2154         UnityPrint(msg);\par
2155     \}\par
2156 \par
2157     UNITY_FAIL_AND_BAIL;\par
2158 \}\par
}
}
{\xe \v UnityFloatToPtr\:unity_internals.h}
{\xe \v unity_internals.h\:UnityFloatToPtr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UNITY_INTERNAL_PTR} UnityFloatToPtr (const float  {\i num})}}
\par
{\bkmkstart AAAAAAABMJ}
{\bkmkend AAAAAAABMJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1868 of file unity.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1869 \{\par
1870     UnityQuickCompare.f = num;\par
1871     {\cf19 return} (UNITY_INTERNAL_PTR)(&UnityQuickCompare.f);\par
1872 \}\par
}
}
{\xe \v UnityIgnore\:unity_internals.h}
{\xe \v unity_internals.h\:UnityIgnore}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UNITY_NORETURN} void UnityIgnore (const char *  {\i message}, const {\b UNITY_LINE_TYPE}  {\i line})}}
\par
{\bkmkstart AAAAAAABMK}
{\bkmkend AAAAAAABMK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 2161 of file unity.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2162 \{\par
2163     RETURN_IF_FAIL_OR_IGNORE;\par
2164 \par
2165     UnityTestResultsBegin(Unity.TestFile, line);\par
2166     UnityPrint(UnityStrIgnore);\par
2167     {\cf19 if} (msg != NULL)\par
2168     \{\par
2169         UNITY_OUTPUT_CHAR({\cf23 ':'});\par
2170         UNITY_OUTPUT_CHAR({\cf23 ' '});\par
2171         UnityPrint(msg);\par
2172     \}\par
2173     UNITY_IGNORE_AND_BAIL;\par
2174 \}\par
}
}
{\xe \v UnityMessage\:unity_internals.h}
{\xe \v unity_internals.h\:UnityMessage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void UnityMessage (const char *  {\i message}, const {\b UNITY_LINE_TYPE}  {\i line})}}
\par
{\bkmkstart AAAAAAABML}
{\bkmkend AAAAAAABML}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 2177 of file unity.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2178 \{\par
2179     UnityTestResultsBegin(Unity.TestFile, line);\par
2180     UnityPrint({\cf22 "INFO"});\par
2181     {\cf19 if} (msg != NULL)\par
2182     \{\par
2183       UNITY_OUTPUT_CHAR({\cf23 ':'});\par
2184       UNITY_OUTPUT_CHAR({\cf23 ' '});\par
2185       UnityPrint(msg);\par
2186     \}\par
2187     UNITY_PRINT_EOL();\par
2188 \}\par
}
}
{\xe \v UnityNumToPtr\:unity_internals.h}
{\xe \v unity_internals.h\:UnityNumToPtr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UNITY_INTERNAL_PTR} UnityNumToPtr (const {\b UNITY_INT}  {\i num}, const {\b UNITY_UINT8}  {\i size})}}
\par
{\bkmkstart AAAAAAABMM}
{\bkmkend AAAAAAABMM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1842 of file unity.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1843 \{\par
1844     {\cf19 switch}(size)\par
1845     \{\par
1846         {\cf19 case} 1:\par
1847             UnityQuickCompare.i8 = (UNITY_INT8)num;\par
1848             {\cf19 return} (UNITY_INTERNAL_PTR)(&UnityQuickCompare.i8);\par
1849 \par
1850         {\cf19 case} 2:\par
1851             UnityQuickCompare.i16 = (UNITY_INT16)num;\par
1852             {\cf19 return} (UNITY_INTERNAL_PTR)(&UnityQuickCompare.i16);\par
1853 \par
1854 {\cf21 #ifdef UNITY_SUPPORT_64}\par
1855         {\cf19 case} 8:\par
1856             UnityQuickCompare.i64 = (UNITY_INT64)num;\par
1857             {\cf19 return} (UNITY_INTERNAL_PTR)(&UnityQuickCompare.i64);\par
1858 {\cf21 #endif}\par
1859 \par
1860         {\cf19 default}: {\cf20 /* 4 bytes */}\par
1861             UnityQuickCompare.i32 = (UNITY_INT32)num;\par
1862             {\cf19 return} (UNITY_INTERNAL_PTR)(&UnityQuickCompare.i32);\par
1863     \}\par
1864 \}\par
}
}
{\xe \v UnityPrint\:unity_internals.h}
{\xe \v unity_internals.h\:UnityPrint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void UnityPrint (const char *  {\i string})}}
\par
{\bkmkstart AAAAAAABMN}
{\bkmkend AAAAAAABMN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 128 of file unity.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 129 \{\par
130     {\cf17 const} {\cf18 char}* pch = string;\par
131 \par
132     {\cf19 if} (pch != NULL)\par
133     \{\par
134         {\cf19 while} (*pch)\par
135         \{\par
136 {\cf21 #ifdef UNITY_OUTPUT_COLOR}\par
137             {\cf20 /* print ANSI escape code */}\par
138             {\cf19 if} ((*pch == 27) && (*(pch + 1) == {\cf23 '['}))\par
139             \{\par
140                 pch += UnityPrintAnsiEscapeString(pch);\par
141                 {\cf19 continue};\par
142             \}\par
143 {\cf21 #endif}\par
144             UnityPrintChar(pch);\par
145             pch++;\par
146         \}\par
147     \}\par
148 \}\par
}
}
{\xe \v UnityPrintFloat\:unity_internals.h}
{\xe \v unity_internals.h\:UnityPrintFloat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void UnityPrintFloat (const {\b UNITY_DOUBLE}  {\i input_number})}}
\par
{\bkmkstart AAAAAAABMO}
{\bkmkend AAAAAAABMO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 334 of file unity.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 335 \{\par
336 {\cf21 #ifdef UNITY_INCLUDE_DOUBLE}\par
337     {\cf17 static} {\cf17 const} {\cf18 int} sig_digits = 9;\par
338     {\cf17 static} {\cf17 const} UNITY_INT32 min_scaled = 100000000;\par
339     {\cf17 static} {\cf17 const} UNITY_INT32 max_scaled = 1000000000;\par
340 {\cf21 #else}\par
341     {\cf17 static} {\cf17 const} {\cf18 int} sig_digits = 7;\par
342     {\cf17 static} {\cf17 const} UNITY_INT32 min_scaled = 1000000;\par
343     {\cf17 static} {\cf17 const} UNITY_INT32 max_scaled = 10000000;\par
344 {\cf21 #endif}\par
345 \par
346     UNITY_DOUBLE number = input_number;\par
347 \par
348     {\cf20 /* print minus sign (does not handle negative zero) */}\par
349     {\cf19 if} (number < 0.0f)\par
350     \{\par
351         UNITY_OUTPUT_CHAR({\cf23 '-'});\par
352         number = -number;\par
353     \}\par
354 \par
355     {\cf20 /* handle zero, NaN, and +/- infinity */}\par
356     {\cf19 if} (number == 0.0f)\par
357     \{\par
358         UnityPrint({\cf22 "0"});\par
359     \}\par
360     {\cf19 else} {\cf19 if} (UNITY_IS_NAN(number))\par
361     \{\par
362         UnityPrint({\cf22 "nan"});\par
363     \}\par
364     {\cf19 else} {\cf19 if} (UNITY_IS_INF(number))\par
365     \{\par
366         UnityPrint({\cf22 "inf"});\par
367     \}\par
368     {\cf19 else}\par
369     \{\par
370         UNITY_INT32 n_int = 0;\par
371         UNITY_INT32 n;\par
372         {\cf18 int}         exponent = 0;\par
373         {\cf18 int}         decimals;\par
374         {\cf18 int}         digits;\par
375         {\cf18 char}        buf[16] = \{0\};\par
376 \par
377         {\cf20 /*}\par
378 {\cf20          * Scale up or down by powers of 10.  To minimize rounding error,}\par
379 {\cf20          * start with a factor/divisor of 10^10, which is the largest}\par
380 {\cf20          * power of 10 that can be represented exactly.  Finally, compute}\par
381 {\cf20          * (exactly) the remaining power of 10 and perform one more}\par
382 {\cf20          * multiplication or division.}\par
383 {\cf20          */}\par
384         {\cf19 if} (number < 1.0f)\par
385         \{\par
386             UNITY_DOUBLE factor = 1.0f;\par
387 \par
388             {\cf19 while} (number < (UNITY_DOUBLE)max_scaled / 1e10f)  \{ number *= 1e10f; exponent -= 10; \}\par
389             {\cf19 while} (number * factor < (UNITY_DOUBLE)min_scaled) \{ factor *= 10.0f; exponent--; \}\par
390 \par
391             number *= factor;\par
392         \}\par
393         {\cf19 else} {\cf19 if} (number > (UNITY_DOUBLE)max_scaled)\par
394         \{\par
395             UNITY_DOUBLE divisor = 1.0f;\par
396 \par
397             {\cf19 while} (number > (UNITY_DOUBLE)min_scaled * 1e10f)   \{ number  /= 1e10f; exponent += 10; \}\par
398             {\cf19 while} (number / divisor > (UNITY_DOUBLE)max_scaled) \{ divisor *= 10.0f; exponent++; \}\par
399 \par
400             number /= divisor;\par
401         \}\par
402         {\cf19 else}\par
403         \{\par
404             {\cf20 /*}\par
405 {\cf20              * In this range, we can split off the integer part before}\par
406 {\cf20              * doing any multiplications.  This reduces rounding error by}\par
407 {\cf20              * freeing up significant bits in the fractional part.}\par
408 {\cf20              */}\par
409             UNITY_DOUBLE factor = 1.0f;\par
410             n_int = (UNITY_INT32)number;\par
411             number -= (UNITY_DOUBLE)n_int;\par
412 \par
413             {\cf19 while} (n_int < min_scaled) \{ n_int *= 10; factor *= 10.0f; exponent--; \}\par
414 \par
415             number *= factor;\par
416         \}\par
417 \par
418         {\cf20 /* round to nearest integer */}\par
419         n = ((UNITY_INT32)(number + number) + 1) / 2;\par
420 \par
421 {\cf21 #ifndef UNITY_ROUND_TIES_AWAY_FROM_ZERO}\par
422         {\cf20 /* round to even if exactly between two integers */}\par
423         {\cf19 if} ((n & 1) && (((UNITY_DOUBLE)n - number) == 0.5f))\par
424             n--;\par
425 {\cf21 #endif}\par
426 \par
427         n += n_int;\par
428 \par
429         {\cf19 if} (n >= max_scaled)\par
430         \{\par
431             n = min_scaled;\par
432             exponent++;\par
433         \}\par
434 \par
435         {\cf20 /* determine where to place decimal point */}\par
436         decimals = ((exponent <= 0) && (exponent >= -(sig_digits + 3))) ? (-exponent) : (sig_digits - 1);\par
437         exponent += decimals;\par
438 \par
439         {\cf20 /* truncate trailing zeroes after decimal point */}\par
440         {\cf19 while} ((decimals > 0) && ((n % 10) == 0))\par
441         \{\par
442             n /= 10;\par
443             decimals--;\par
444         \}\par
445 \par
446         {\cf20 /* build up buffer in reverse order */}\par
447         digits = 0;\par
448         {\cf19 while} ((n != 0) || (digits <= decimals))\par
449         \{\par
450             buf[digits++] = (char)({\cf23 '0'} + n % 10);\par
451             n /= 10;\par
452         \}\par
453 \par
454         {\cf20 /* print out buffer (backwards) */}\par
455         {\cf19 while} (digits > 0)\par
456         \{\par
457             {\cf19 if} (digits == decimals)\par
458             \{\par
459                 UNITY_OUTPUT_CHAR({\cf23 '.'});\par
460             \}\par
461             UNITY_OUTPUT_CHAR(buf[--digits]);\par
462         \}\par
463 \par
464         {\cf20 /* print exponent if needed */}\par
465         {\cf19 if} (exponent != 0)\par
466         \{\par
467             UNITY_OUTPUT_CHAR({\cf23 'e'});\par
468 \par
469             {\cf19 if} (exponent < 0)\par
470             \{\par
471                 UNITY_OUTPUT_CHAR({\cf23 '-'});\par
472                 exponent = -exponent;\par
473             \}\par
474             {\cf19 else}\par
475             \{\par
476                 UNITY_OUTPUT_CHAR({\cf23 '+'});\par
477             \}\par
478 \par
479             digits = 0;\par
480             {\cf19 while} ((exponent != 0) || (digits < 2))\par
481             \{\par
482                 buf[digits++] = (char)({\cf23 '0'} + exponent % 10);\par
483                 exponent /= 10;\par
484             \}\par
485             {\cf19 while} (digits > 0)\par
486             \{\par
487                 UNITY_OUTPUT_CHAR(buf[--digits]);\par
488             \}\par
489         \}\par
490     \}\par
491 \}\par
}
}
{\xe \v UnityPrintLen\:unity_internals.h}
{\xe \v unity_internals.h\:UnityPrintLen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void UnityPrintLen (const char *  {\i string}, const {\b UNITY_UINT32}  {\i length})}}
\par
{\bkmkstart AAAAAAABMP}
{\bkmkend AAAAAAABMP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 150 of file unity.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 151 \{\par
152     {\cf17 const} {\cf18 char}* pch = string;\par
153 \par
154     {\cf19 if} (pch != NULL)\par
155     \{\par
156         {\cf19 while} (*pch && ((UNITY_UINT32)(pch - {\cf18 string}) < length))\par
157         \{\par
158             {\cf20 /* printable characters plus CR & LF are printed */}\par
159             {\cf19 if} ((*pch <= 126) && (*pch >= 32))\par
160             \{\par
161                 UNITY_OUTPUT_CHAR(*pch);\par
162             \}\par
163             {\cf20 /* write escaped carriage returns */}\par
164             {\cf19 else} {\cf19 if} (*pch == 13)\par
165             \{\par
166                 UNITY_OUTPUT_CHAR({\cf23 '\\\\'});\par
167                 UNITY_OUTPUT_CHAR({\cf23 'r'});\par
168             \}\par
169             {\cf20 /* write escaped line feeds */}\par
170             {\cf19 else} {\cf19 if} (*pch == 10)\par
171             \{\par
172                 UNITY_OUTPUT_CHAR({\cf23 '\\\\'});\par
173                 UNITY_OUTPUT_CHAR({\cf23 'n'});\par
174             \}\par
175             {\cf20 /* unprintable characters are shown as codes */}\par
176             {\cf19 else}\par
177             \{\par
178                 UNITY_OUTPUT_CHAR({\cf23 '\\\\'});\par
179                 UNITY_OUTPUT_CHAR({\cf23 'x'});\par
180                 UnityPrintNumberHex((UNITY_UINT)*pch, 2);\par
181             \}\par
182             pch++;\par
183         \}\par
184     \}\par
185 \}\par
}
}
{\xe \v UnityPrintMask\:unity_internals.h}
{\xe \v unity_internals.h\:UnityPrintMask}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void UnityPrintMask (const {\b UNITY_UINT}  {\i mask}, const {\b UNITY_UINT}  {\i number})}}
\par
{\bkmkstart AAAAAAABMQ}
{\bkmkend AAAAAAABMQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 299 of file unity.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 300 \{\par
301     UNITY_UINT current_bit = (UNITY_UINT)1 << (UNITY_INT_WIDTH - 1);\par
302     UNITY_INT32 i;\par
303 \par
304     {\cf19 for} (i = 0; i < UNITY_INT_WIDTH; i++)\par
305     \{\par
306         {\cf19 if} (current_bit & mask)\par
307         \{\par
308             {\cf19 if} (current_bit & number)\par
309             \{\par
310                 UNITY_OUTPUT_CHAR({\cf23 '1'});\par
311             \}\par
312             {\cf19 else}\par
313             \{\par
314                 UNITY_OUTPUT_CHAR({\cf23 '0'});\par
315             \}\par
316         \}\par
317         {\cf19 else}\par
318         \{\par
319             UNITY_OUTPUT_CHAR({\cf23 'X'});\par
320         \}\par
321         current_bit = current_bit >> 1;\par
322     \}\par
323 \}\par
}
}
{\xe \v UnityPrintNumber\:unity_internals.h}
{\xe \v unity_internals.h\:UnityPrintNumber}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void UnityPrintNumber (const {\b UNITY_INT}  {\i number_to_print})}}
\par
{\bkmkstart AAAAAAABMR}
{\bkmkend AAAAAAABMR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 239 of file unity.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 240 \{\par
241     UNITY_UINT number = (UNITY_UINT)number_to_print;\par
242 \par
243     {\cf19 if} (number_to_print < 0)\par
244     \{\par
245         {\cf20 /* A negative number, including MIN negative */}\par
246         UNITY_OUTPUT_CHAR({\cf23 '-'});\par
247         number = (~number) + 1;\par
248     \}\par
249     UnityPrintNumberUnsigned(number);\par
250 \}\par
}
}
{\xe \v UnityPrintNumberByStyle\:unity_internals.h}
{\xe \v unity_internals.h\:UnityPrintNumberByStyle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void UnityPrintNumberByStyle (const {\b UNITY_INT}  {\i number}, const {\b UNITY_DISPLAY_STYLE_T}  {\i style})}}
\par
{\bkmkstart AAAAAAABMS}
{\bkmkend AAAAAAABMS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 188 of file unity.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 189 \{\par
190     {\cf19 if} ((style & UNITY_DISPLAY_RANGE_INT) == UNITY_DISPLAY_RANGE_INT)\par
191     \{\par
192         {\cf19 if} (style == UNITY_DISPLAY_STYLE_CHAR)\par
193         \{\par
194             {\cf20 /* printable characters plus CR & LF are printed */}\par
195             UNITY_OUTPUT_CHAR({\cf23 '\\''});\par
196             {\cf19 if} ((number <= 126) && (number >= 32))\par
197             \{\par
198                 UNITY_OUTPUT_CHAR(({\cf18 int})number);\par
199             \}\par
200             {\cf20 /* write escaped carriage returns */}\par
201             {\cf19 else} {\cf19 if} (number == 13)\par
202             \{\par
203                 UNITY_OUTPUT_CHAR({\cf23 '\\\\'});\par
204                 UNITY_OUTPUT_CHAR({\cf23 'r'});\par
205             \}\par
206             {\cf20 /* write escaped line feeds */}\par
207             {\cf19 else} {\cf19 if} (number == 10)\par
208             \{\par
209                 UNITY_OUTPUT_CHAR({\cf23 '\\\\'});\par
210                 UNITY_OUTPUT_CHAR({\cf23 'n'});\par
211             \}\par
212             {\cf20 /* unprintable characters are shown as codes */}\par
213             {\cf19 else}\par
214             \{\par
215                 UNITY_OUTPUT_CHAR({\cf23 '\\\\'});\par
216                 UNITY_OUTPUT_CHAR({\cf23 'x'});\par
217                 UnityPrintNumberHex((UNITY_UINT)number, 2);\par
218             \}\par
219             UNITY_OUTPUT_CHAR({\cf23 '\\''});\par
220         \}\par
221         {\cf19 else}\par
222         \{\par
223             UnityPrintNumber(number);\par
224         \}\par
225     \}\par
226     {\cf19 else} {\cf19 if} ((style & UNITY_DISPLAY_RANGE_UINT) == UNITY_DISPLAY_RANGE_UINT)\par
227     \{\par
228         UnityPrintNumberUnsigned((UNITY_UINT)number);\par
229     \}\par
230     {\cf19 else}\par
231     \{\par
232         UNITY_OUTPUT_CHAR({\cf23 '0'});\par
233         UNITY_OUTPUT_CHAR({\cf23 'x'});\par
234         UnityPrintNumberHex((UNITY_UINT)number, ({\cf18 char})((style & 0xF) * 2));\par
235     \}\par
236 \}\par
}
}
{\xe \v UnityPrintNumberHex\:unity_internals.h}
{\xe \v unity_internals.h\:UnityPrintNumberHex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void UnityPrintNumberHex (const {\b UNITY_UINT}  {\i number}, const char  {\i nibbles_to_print})}}
\par
{\bkmkstart AAAAAAABMT}
{\bkmkend AAAAAAABMT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 273 of file unity.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 274 \{\par
275     {\cf18 int} nibble;\par
276     {\cf18 char} nibbles = nibbles_to_print;\par
277 \par
278     {\cf19 if} (({\cf18 unsigned})nibbles > UNITY_MAX_NIBBLES)\par
279     \{\par
280         nibbles = UNITY_MAX_NIBBLES;\par
281     \}\par
282 \par
283     {\cf19 while} (nibbles > 0)\par
284     \{\par
285         nibbles--;\par
286         nibble = (int)(number >> (nibbles * 4)) & 0x0F;\par
287         {\cf19 if} (nibble <= 9)\par
288         \{\par
289             UNITY_OUTPUT_CHAR(({\cf18 char})({\cf23 '0'} + nibble));\par
290         \}\par
291         {\cf19 else}\par
292         \{\par
293             UNITY_OUTPUT_CHAR(({\cf18 char})({\cf23 'A'} - 10 + nibble));\par
294         \}\par
295     \}\par
296 \}\par
}
}
{\xe \v UnityPrintNumberUnsigned\:unity_internals.h}
{\xe \v unity_internals.h\:UnityPrintNumberUnsigned}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void UnityPrintNumberUnsigned (const {\b UNITY_UINT}  {\i number})}}
\par
{\bkmkstart AAAAAAABMU}
{\bkmkend AAAAAAABMU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 254 of file unity.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 255 \{\par
256     UNITY_UINT divisor = 1;\par
257 \par
258     {\cf20 /* figure out initial divisor */}\par
259     {\cf19 while} (number / divisor > 9)\par
260     \{\par
261         divisor *= 10;\par
262     \}\par
263 \par
264     {\cf20 /* now mod and print, then divide divisor */}\par
265     {\cf19 do}\par
266     \{\par
267         UNITY_OUTPUT_CHAR(({\cf18 char})({\cf23 '0'} + (number / divisor % 10)));\par
268         divisor /= 10;\par
269     \} {\cf19 while} (divisor > 0);\par
270 \}\par
}
}
{\xe \v UnitySetTestFile\:unity_internals.h}
{\xe \v unity_internals.h\:UnitySetTestFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void UnitySetTestFile (const char *  {\i filename})}}
\par
{\bkmkstart AAAAAAABMV}
{\bkmkend AAAAAAABMV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 2215 of file unity.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2216 \{\par
2217     Unity.TestFile = filename;\par
2218 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v Unity\:unity_internals.h}
{\xe \v unity_internals.h\:Unity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b UNITY_STORAGE_T} Unity{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAABMW}
{\bkmkend AAAAAAABMW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1 of file unity.c.}\par
}
{\xe \v UnityStrErr64\:unity_internals.h}
{\xe \v unity_internals.h\:UnityStrErr64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char UnityStrErr64[]{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAABMX}
{\bkmkend AAAAAAABMX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 63 of file unity.c.}\par
}
{\xe \v UnityStrErrDouble\:unity_internals.h}
{\xe \v unity_internals.h\:UnityStrErrDouble}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char UnityStrErrDouble[]{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAABMY}
{\bkmkend AAAAAAABMY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 62 of file unity.c.}\par
}
{\xe \v UnityStrErrFloat\:unity_internals.h}
{\xe \v unity_internals.h\:UnityStrErrFloat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char UnityStrErrFloat[]{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAABMZ}
{\bkmkend AAAAAAABMZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 61 of file unity.c.}\par
}
{\xe \v UnityStrErrShorthand\:unity_internals.h}
{\xe \v unity_internals.h\:UnityStrErrShorthand}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char UnityStrErrShorthand[]{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAABNA}
{\bkmkend AAAAAAABNA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 60 of file unity.c.}\par
}
{\xe \v UnityStrFail\:unity_internals.h}
{\xe \v unity_internals.h\:UnityStrFail}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char UnityStrFail[]{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAABNB}
{\bkmkend AAAAAAABNB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 34 of file unity.c.}\par
}
{\xe \v UnityStrIgnore\:unity_internals.h}
{\xe \v unity_internals.h\:UnityStrIgnore}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char UnityStrIgnore[]{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAABNC}
{\bkmkend AAAAAAABNC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 35 of file unity.c.}\par
}
{\xe \v UnityStrOk\:unity_internals.h}
{\xe \v unity_internals.h\:UnityStrOk}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char UnityStrOk[]{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAABND}
{\bkmkend AAAAAAABND}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 32 of file unity.c.}\par
}
{\xe \v UnityStrPass\:unity_internals.h}
{\xe \v unity_internals.h\:UnityStrPass}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char UnityStrPass[]{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAABNE}
{\bkmkend AAAAAAABNE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 33 of file unity.c.}\par
}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Index\par 
\pard\plain 
{\tc \v Index}
{\field\fldedit {\*\fldinst INDEX \\c2 \\*MERGEFORMAT}{\fldrslt INDEX}}
}